<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Linux IO 多路复用 #  同步/异步 阻塞/非阻塞 #  概念 #  《UNIX Network Programming》中给出了五种 IO 模型：
  同步阻塞 IO
  同步非阻塞 IO
  IO 多路复用
  信号驱动 IO
  异步 IO
  在考虑 IO 模式之前，要先回顾一些关于操作系统的知识。在程序调用系统调用（System Call）时，程序转而进入内核态，在内核态中完成 IO 操作，并将 IO 的数据从内核空间的 buffer 拷贝到用户空间的 buffer 中。回到用户态之后，程序将可以从 buffer 中取得数据。
同步阻塞 IO #  对于同步阻塞 IO，在调用系统的 recvfrom 调用之后，进入内核态，线程阻塞。直到系统内核接收到数据并把数据拷贝到用户空间 buffer 全部完成后，才能从阻塞中恢复。
同步非阻塞 IO #  在非阻塞模式的 IO 中，如果调用 recvfrom 时系统尚未收到对应的数据，则不会阻塞，而是直接返回 EWOULDBLOCK 错误。如果调用时已经收到了数据，才会在拷贝 buffer 的过程中阻塞。通常来说这个时间是短暂而稳定的，因此这种 IO 模式完全可以认为是非阻塞的。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Linux IO Multiplexing"><meta property="og:description" content="Linux IO 多路复用 #  同步/异步 阻塞/非阻塞 #  概念 #  《UNIX Network Programming》中给出了五种 IO 模型：
  同步阻塞 IO
  同步非阻塞 IO
  IO 多路复用
  信号驱动 IO
  异步 IO
  在考虑 IO 模式之前，要先回顾一些关于操作系统的知识。在程序调用系统调用（System Call）时，程序转而进入内核态，在内核态中完成 IO 操作，并将 IO 的数据从内核空间的 buffer 拷贝到用户空间的 buffer 中。回到用户态之后，程序将可以从 buffer 中取得数据。
同步阻塞 IO #  对于同步阻塞 IO，在调用系统的 recvfrom 调用之后，进入内核态，线程阻塞。直到系统内核接收到数据并把数据拷贝到用户空间 buffer 全部完成后，才能从阻塞中恢复。
同步非阻塞 IO #  在非阻塞模式的 IO 中，如果调用 recvfrom 时系统尚未收到对应的数据，则不会阻塞，而是直接返回 EWOULDBLOCK 错误。如果调用时已经收到了数据，才会在拷贝 buffer 的过程中阻塞。通常来说这个时间是短暂而稳定的，因此这种 IO 模式完全可以认为是非阻塞的。"><meta property="og:type" content="article"><meta property="og:url" content="/cs/linux-io-multiplex/"><meta property="article:section" content="cs"><title>Linux IO Multiplexing | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle checked>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/ class=active>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Linux IO Multiplexing</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#linux-io-多路复用>Linux IO 多路复用</a><ul><li><a href=#同步异步-阻塞非阻塞>同步/异步 阻塞/非阻塞</a><ul><li><a href=#概念>概念</a></li><li><a href=#同步阻塞-io>同步阻塞 IO</a></li><li><a href=#同步非阻塞-io>同步非阻塞 IO</a></li><li><a href=#多路-io-复用>多路 IO 复用</a></li><li><a href=#信号驱动-io>信号驱动 IO</a></li><li><a href=#异步-io>异步 IO</a></li></ul></li><li><a href=#select-与-poll-的问题>select 与 poll 的问题</a><ul><li><a href=#linux-的-wakeup-callback-机制>Linux 的 wakeup callback 机制</a></li><li><a href=#select>select</a></li><li><a href=#poll>poll</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#epoll-的使用示例>epoll 的使用示例</a></li><li><a href=#解决集合拷贝问题>解决集合拷贝问题</a></li><li><a href=#遍历-fd-集合>遍历 fd 集合</a></li></ul></li><li><a href=#epoll-的边缘触发与水平触发>epoll 的边缘触发与水平触发</a><ul><li><a href=#概念-1>概念</a></li><li><a href=#区别>区别</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=linux-io-多路复用>Linux IO 多路复用
<a class=anchor href=#linux-io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8>#</a></h1><h2 id=同步异步-阻塞非阻塞>同步/异步 阻塞/非阻塞
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e5%bc%82%e6%ad%a5-%e9%98%bb%e5%a1%9e%e9%9d%9e%e9%98%bb%e5%a1%9e>#</a></h2><h3 id=概念>概念
<a class=anchor href=#%e6%a6%82%e5%bf%b5>#</a></h3><p>《UNIX Network Programming》中给出了五种 IO 模型：</p><ul><li><p>同步阻塞 IO</p></li><li><p>同步非阻塞 IO</p></li><li><p>IO 多路复用</p></li><li><p>信号驱动 IO</p></li><li><p>异步 IO</p></li></ul><p>在考虑 IO 模式之前，要先回顾一些关于操作系统的知识。在程序调用<strong>系统调用</strong>（System Call）时，程序转而进入内核态，在内核态中完成 IO 操作，并将 IO 的数据从内核空间的 buffer 拷贝到用户空间的 buffer 中。回到用户态之后，程序将可以从 buffer 中取得数据。</p><h3 id=同步阻塞-io>同步阻塞 IO
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e9%98%bb%e5%a1%9e-io>#</a></h3><p>对于同步阻塞 IO，在调用系统的 <code>recvfrom</code> 调用之后，进入内核态，线程阻塞。直到系统内核接收到数据并把数据拷贝到用户空间 buffer 全部完成后，才能从阻塞中恢复。</p><h3 id=同步非阻塞-io>同步非阻塞 IO
<a class=anchor href=#%e5%90%8c%e6%ad%a5%e9%9d%9e%e9%98%bb%e5%a1%9e-io>#</a></h3><p>在非阻塞模式的 IO 中，如果调用 <code>recvfrom</code> 时系统尚未收到对应的数据，则不会阻塞，而是直接返回 <code>EWOULDBLOCK</code> 错误。如果调用时已经收到了数据，才会在拷贝 buffer 的过程中阻塞。通常来说这个时间是短暂而稳定的，因此这种 IO 模式完全可以认为是非阻塞的。</p><h3 id=多路-io-复用>多路 IO 复用
<a class=anchor href=#%e5%a4%9a%e8%b7%af-io-%e5%a4%8d%e7%94%a8>#</a></h3><p><code>select</code> <code>poll</code> <code>epoll</code> 都属于这一类。这种 IO 模式并没有实现真正的异步 IO，却能够获得异步 IO 的一些优点。</p><p>例如，假设我们现在需要监听多个端口的 UDP 数据。在同步阻塞 IO 下，我们需要为每个端口的监听准备一个线程，这些线程全部阻塞住，有数据时再进行处理。这在高并发场景下会带来海量的 RAM 需求。</p><p>然后我们考虑在同步非阻塞 IO 下应该怎样处理。一个比较可行的方法是，在一个线程内对所有的 IO 进行轮询。如果返回错误，就访问下一个监听端口。如果有数据，则处理数据。这种方法十分可行，但编码复杂，也存在一定程度的性能浪费。</p><p>多路 IO 复用可以认为是替我们完成了上述的过程（当然不完全一样）。例如 <code>select</code>，就是阻塞直到所有被监听的事件中有一个获得数据，就立刻返回。这样，我们就能在一个线程之内处理许多个 IO，这就叫做多路 IO 复用。</p><h3 id=信号驱动-io>信号驱动 IO
<a class=anchor href=#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8-io>#</a></h3><p>信号驱动的 IO 并不需要用户程序去查询是否有 IO 数据到达，而是让用户程序在系统中注册。当数据到达时，内核反过来通知用户程序，用户程序阻塞并开始进行 buffer 拷贝。这种形式的 IO 比较少见。</p><h3 id=异步-io>异步 IO
<a class=anchor href=#%e5%bc%82%e6%ad%a5-io>#</a></h3><p>异步 IO 在调用时立刻返回用户态，但并不得到结果。直到系统得到数据并拷贝到 buffer 之后，系统通知客户程序，客户程序可以开始处理数据。</p><p>遗憾的是，Linux 尚未实现真正异步的网络 IO。实际情况下，程序需要阻塞在拷贝 buffer 过程。在 Windows、Solaris 等系统的 IOCP 模型下可以实现真正的异步。</p><p><img src=../io-multiplexing.png alt></p><h2 id=select-与-poll-的问题>select 与 poll 的问题
<a class=anchor href=#select-%e4%b8%8e-poll-%e7%9a%84%e9%97%ae%e9%a2%98>#</a></h2><h3 id=linux-的-wakeup-callback-机制>Linux 的 wakeup callback 机制
<a class=anchor href=#linux-%e7%9a%84-wakeup-callback-%e6%9c%ba%e5%88%b6>#</a></h3><p>在介绍 IO 复用之前需要首先介绍 wakeup callback 机制。Linux 为每个 socket 维护一个 <code>sleep_list</code>，列表中存储 <code>wait_entry</code>，存储监听该 socket 的进程信息。</p><ul><li><p>调用 <code>select</code> <code>poll</code> <code>epoll_wait</code>，陷入内核，查看监听的 socket 是否有事件。如果有，就返回处理。</p></li><li><p>如果没有，为当前进程建立一个 <code>wait_entry</code> 节点，插入到所监控 socket 的 <code>sleep_list</code> 中。</p></li><li><p>进入循环，阻塞</p></li><li><p>当 socket 事件发生时，遍历 socket 对应的 <code>sleep_list</code>，调用其 callback 函数。通常会唤醒对应的进程进入 CPU 就绪队列。</p></li><li><p>队列遍历完成或遇到排他的 <code>wait_entry</code>，停止遍历。</p></li></ul><h3 id=select>select
<a class=anchor href=#select>#</a></h3><p>一个进程可以通过 <code>select</code> 监听多个 socket，并阻塞。在所有监听的事件中有任何一个发生时，进程从阻塞中恢复，我们可以遍历所有监听的事件来查看到底是哪一个可用。</p><p>回到上面的 wakeup callback 机制。要达到这样的效果，我们需要把这个进程插入到所有监听的 socket 的 <code>wait_list</code> 中去。当其中任何一个有事件发生时，进程就会被唤醒。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>select</span>(
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> nfds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#666>*</span><span style=color:green;font-weight:700>restrict</span> readfds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#666>*</span><span style=color:green;font-weight:700>restrict</span> writefds,
</span></span><span style=display:flex><span>    fd_set <span style=color:#666>*</span><span style=color:green;font-weight:700>restrict</span> exceptfds,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>struct</span> timeval <span style=color:#666>*</span><span style=color:green;font-weight:700>restrict</span> timeout
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>这里的 <code>fd_set</code> 的实质内容是一个 <code>long int</code>。可以看到，select 将三类事件分开传入。</p><p>调用时，程序将会把要监听的 <code>fd_set</code> 文件标识符拷贝到内核态。可以想到，这时系统会首先先检查所有的监听事件是否有发生的。如果有，就可以立刻进行返回。如果所有事件都没有，就进入阻塞状态。当然，还可以设置超时时间。</p><p>随后，当事件发生时，我们需要重新遍历一遍所有的监听事件，因为我们不知道是否还有其他事件同时发生。收集到所有的事件之后，我们才可以返回用户态。</p><p><code>select</code> 存在的问题：</p><ul><li><p>将 <code>fd_set</code> 拷贝到内核态的开销。</p></li><li><p>为了减少拷贝 <code>fd_set</code> 的影响，select 的集合大小在内核中限制为 1024。对于高并发的情形，仍然需要做很多额外的工作。</p></li><li><p>得到事件通知后，我们仍然需要遍历整个列表来寻找究竟是哪一个发生了事件。</p></li></ul><h3 id=poll>poll
<a class=anchor href=#poll>#</a></h3><p><code>poll</code> 的出现解决了 <code>select</code> 的 1024 限制问题。函数原型如下：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> pollfd {
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> fd;                        <span style=color:#408080;font-style:italic>/* File descriptor to poll.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>short</span> <span style=color:#b00040>int</span> events;              <span style=color:#408080;font-style:italic>/* Types of events poller cares about.  */</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>short</span> <span style=color:#b00040>int</span> revents;             <span style=color:#408080;font-style:italic>/* Types of events that actually occurred.  */</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>poll</span>(<span style=color:green;font-weight:700>struct</span> pollfd <span style=color:#666>*</span>fds, nfds_t nfds, <span style=color:#b00040>int</span> timeout);
</span></span></code></pre></div><p><code>poll</code> 不再使用 <code>fd_set</code>，而是把要监听的事件封装到 <code>pollfd</code> 中去，减少了参数的数量。</p><p>然而，所有的文件描述符仍然需要拷贝到内核态，并且当描述符超过 1024 个之后，性能仍然会下降。也就是说，<code>poll</code> 并没有解决 <code>select</code> 的根本问题。</p><h2 id=epoll>epoll
<a class=anchor href=#epoll>#</a></h2><h3 id=epoll-的使用示例>epoll 的使用示例
<a class=anchor href=#epoll-%e7%9a%84%e4%bd%bf%e7%94%a8%e7%a4%ba%e4%be%8b>#</a></h3><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>epoll_create</span>(<span style=color:#b00040>int</span> size);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>epoll_ctl</span>(
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> epfd,
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> op,
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> fd,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>struct</span> epoll_event <span style=color:#666>*</span>event
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>epoll_wait</span>(
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> epfd,
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>struct</span> epoll_event <span style=color:#666>*</span>events,
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> maxevents,
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> timeout
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:green;font-weight:700>struct</span> epoll_event ev;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// these functions return -1 while error occurs
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    epfd <span style=color:#666>=</span> epoll_create(argc <span style=color:#666>-</span> <span style=color:#666>1</span>);
</span></span><span style=display:flex><span>    fd <span style=color:#666>=</span> open(argv[j], O_RDONLY);
</span></span><span style=display:flex><span>    epoll_ctl(epfd, EPOLL_CTL_ADD, fd, <span style=color:#666>&amp;</span>ev)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    ready <span style=color:#666>=</span> epoll_wait(epfd, evlist, MAX_EVENTS, <span style=color:#666>-</span><span style=color:#666>1</span>);
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>for</span> (<span style=color:#b00040>int</span> j <span style=color:#666>=</span> <span style=color:#666>0</span>; j <span style=color:#666>&lt;</span> ready; j<span style=color:#666>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> (evlist[j].events <span style=color:#666>&amp;</span> EPOLLIN) {
</span></span><span style=display:flex><span>            <span style=color:#408080;font-style:italic>// process event
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=解决集合拷贝问题>解决集合拷贝问题
<a class=anchor href=#%e8%a7%a3%e5%86%b3%e9%9b%86%e5%90%88%e6%8b%b7%e8%b4%9d%e9%97%ae%e9%a2%98>#</a></h3><p>回顾 <code>select</code> 和 <code>poll</code> 我们会发现，每次调用都需要重新将整个文件描述符集合传入内核态。然而实际情况下，这个集合变化并不频繁，我们的服务器通常固定监听少数几个端口。即使变化，整个集合也很少会全部变化，而是少数的增加和删除。因此，我们首先可以将这个过程剥离成为另一个函数：<code>epoll_ctl</code>。也就是说，一次拷贝，多次使用。然后，我们设立几个操作：<code>EPOLL_CTL_ADD</code> <code>EPOLL_CTL_MOD</code> <code>EPOLL_CTL_DEL</code>。这样，我们在拷贝上的开销就减少到了最低。</p><p>不过，这个过程还涉及到对描述符集合的 CRUD。由于我们已经突破了 1024 的限制，在这里使用一个高效的数据结构就存在必要。在 Linux 2.6.8 之前，这里使用的是 Hash。因此，<code>epoll_create</code> 的原型里包含了初始容量。其后，Linux 改用了红黑树来处理这个问题。因此，这个参数现在没有任何作用。</p><p>其次，在事件就绪后，我们还需要回头再次把文件描述符拷贝出来。对于这个问题，<code>epoll</code> 的解决办法是将用户空间和内核空间的地址映射到同一块物理内存上去。这样，用户程序就无需拷贝可以直接访问。</p><h3 id=遍历-fd-集合>遍历 fd 集合
<a class=anchor href=#%e9%81%8d%e5%8e%86-fd-%e9%9b%86%e5%90%88>#</a></h3><p><code>select</code> 的另一个问题是经常需要遍历整个集合。面对这个问题，<code>epoll</code> 拿出的解决办法是使用一个中间层。</p><p>在 <code>select</code> 中，我们需要在所有 socket 的睡眠队列中插入对应的进程的标识。相比之下，<code>epoll</code> 将进程睡眠在 <code>ready_list</code> 上，而将操作 <code>ready_list</code> 的操作绑定在 socket 的睡眠队列上。这样，当 socket 发生事件时，所对应的事件就被加入到 <code>ready_list</code> 中。于是，在从阻塞中返回之前，我们只要看遍历 <code>ready_list</code>，而不再需要遍历所有监听的事件。总的来看，<code>epoll</code> 把对于整个兴趣列表的遍历变成了对所有已经有事件就绪的兴趣的列表的遍历。</p><h2 id=epoll-的边缘触发与水平触发>epoll 的边缘触发与水平触发
<a class=anchor href=#epoll-%e7%9a%84%e8%be%b9%e7%bc%98%e8%a7%a6%e5%8f%91%e4%b8%8e%e6%b0%b4%e5%b9%b3%e8%a7%a6%e5%8f%91>#</a></h2><h3 id=概念-1>概念
<a class=anchor href=#%e6%a6%82%e5%bf%b5-1>#</a></h3><p>在边缘触发情况下，信号仅在 buffer 状态变化时发出。而在水平触发的情况下，在整个 buffer 的状态，信号都会持续发出。</p><p>以 <code>epoll</code> 的读取就绪事件为具体例子，在 ET 模式下，仅当数据到达 buffer 时，该 socket 对应的事件被加入到 <code>ready_list</code> 以供读取。而在 LT 模式下，只要 buffer 不为空，这个 socket 对应的事件就会保持在 <code>ready_list</code>。</p><h3 id=区别>区别
<a class=anchor href=#%e5%8c%ba%e5%88%ab>#</a></h3><p>显而易见，LT 模式下的触发和遍历都要更多一些，看起来性能会更弱一些。不过，在良好网络状况的状态下，如果一个 socket 紧接着就得到了另一组数据，那么相比 ET 模式，我们就省去了一次重复的复制过程。因此，两种方式的性能区别实际上并不明显。</p><p>考虑我们希望多次读取一个 socket 的情况。显然，我们不能在一次循环中直接调用两次 <code>recv</code>，因为可能会在这里阻塞。然而，如果在 ET 模式下再次调用 <code>epoll_wait</code>，由于 ET 模式没有被触发，无法再次得到这个 socket。总之，在阻塞模式下 ET 模式会遇到很多问题。因此，阻塞模式下不能使用 ET。如果要使用 ET，必须使用非阻塞模式，在一次循环中将所有数据全部读取出来。</p><p>相比之下，在 LT 模式下，我们可以在一次循环中只处理一个请求，因为即使没有处理，下一次 <code>epoll_wait</code> 也会将其取出，不会发生饿死的情况。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#linux-io-多路复用>Linux IO 多路复用</a><ul><li><a href=#同步异步-阻塞非阻塞>同步/异步 阻塞/非阻塞</a><ul><li><a href=#概念>概念</a></li><li><a href=#同步阻塞-io>同步阻塞 IO</a></li><li><a href=#同步非阻塞-io>同步非阻塞 IO</a></li><li><a href=#多路-io-复用>多路 IO 复用</a></li><li><a href=#信号驱动-io>信号驱动 IO</a></li><li><a href=#异步-io>异步 IO</a></li></ul></li><li><a href=#select-与-poll-的问题>select 与 poll 的问题</a><ul><li><a href=#linux-的-wakeup-callback-机制>Linux 的 wakeup callback 机制</a></li><li><a href=#select>select</a></li><li><a href=#poll>poll</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#epoll-的使用示例>epoll 的使用示例</a></li><li><a href=#解决集合拷贝问题>解决集合拷贝问题</a></li><li><a href=#遍历-fd-集合>遍历 fd 集合</a></li></ul></li><li><a href=#epoll-的边缘触发与水平触发>epoll 的边缘触发与水平触发</a><ul><li><a href=#概念-1>概念</a></li><li><a href=#区别>区别</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>