<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Computer Science on czdm75 Blog</title><link>/cs/</link><description>Recent content in Computer Science on czdm75 Blog</description><generator>Hugo</generator><language>en</language><atom:link href="/cs/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux IO Multiplexing</title><link>/cs/linux-io-multiplex/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/cs/linux-io-multiplex/</guid><description>Linux IO 多路复用 # 同步/异步 阻塞/非阻塞 # 概念 # 《UNIX Network Programming》中给出了五种 IO 模型：
同步阻塞 IO
同步非阻塞 IO
IO 多路复用
信号驱动 IO
异步 IO
在考虑 IO 模式之前，要先回顾一些关于操作系统的知识。在程序调用系统调用（System Call）时，程序转而进入内核态，在内核态中完成 IO 操作，并将 IO 的数据从内核空间的 buffer 拷贝到用户空间的 buffer 中。回到用户态之后，程序将可以从 buffer 中取得数据。
同步阻塞 IO # 对于同步阻塞 IO，在调用系统的 recvfrom 调用之后，进入内核态，线程阻塞。直到系统内核接收到数据并把数据拷贝到用户空间 buffer 全部完成后，才能从阻塞中恢复。
同步非阻塞 IO # 在非阻塞模式的 IO 中，如果调用 recvfrom 时系统尚未收到对应的数据，则不会阻塞，而是直接返回 EWOULDBLOCK 错误。如果调用时已经收到了数据，才会在拷贝 buffer 的过程中阻塞。通常来说这个时间是短暂而稳定的，因此这种 IO 模式完全可以认为是非阻塞的。
多路 IO 复用 # select poll epoll 都属于这一类。这种 IO 模式并没有实现真正的异步 IO，却能够获得异步 IO 的一些优点。</description></item></channel></rss>