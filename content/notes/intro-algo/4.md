+++
title = '4. BST, Balanced BSTs'
math = true
+++

# 二叉搜索树

对一个二叉搜索树，任何一个结点的左子结点不大于它本身，右子结点不小于它本身。这样，就可以简单地使用中序遍历查找元素。中序遍历打印出来的序列，就是已经排序完成的序列。中序遍历的时间代价为 $\Theta(n)$。

## 二叉搜索树的基本操作

在高 $h$ 的树上，以下操作的时间代价均为 $O(h)$。

-   查找：比较和当前结点的大小，选择子树。
-   最大和最小：不断取左子结点或右子结点。

深度优先遍历的方式：

-   前序遍历
-   中序遍历
-   后序遍历

## 后继前驱

如果关键字不重复，那么一个结点的中序遍历后继为大于这个结点的最小者，即升序序列中的下一个。如果结点的右子树非空，那么右树中的最左结点即为后继结点，不断向左寻找即可。

如果右子树为空，说明这个结点是某个左子树的最右结点，而这个左子树的父结点即为后继结点。这意味着，遍历这个结点之后，这个左子树遍历完成，进入某个遍历过程的根结点部分。于是，不断向上寻找，如果当前结点不再是右结点，说明已经找到了这个根结点。如果找到了 $nil$，则说明没有后继，这个结点是整个树的最右结点。

前驱和后继的过程对称，时间代价均为 $O(h)$。

## 插入和删除

插入过程比较简单。寻找结点的关键字应该在的位置，并修改父结点的指针即可。

删除结点可分为三种情况：

-   没有子结点，直接删除并修改父结点的指针即可。
-   只有一个孩子，则用这个孩子来替代这个结点。
-   两个孩子，则使用后继结点来替代这个结点。由于被删除的这个后继结点是右子树的最左结点，其一定没有左子节点。因此，使用其右子节点代替它的位置，并用这个节点代替待删除的结点。于是，删除完成。

显然，这两种操作的时间代价也是 $O(h)$。

## 随机构建二叉搜索树

二叉搜索树的构建由插入和删除操作完成。显然，实际情况中，这是一个随机过程。在最坏情况下，当元素严格升序或降序插入，二叉搜索树将成为一个链表。十分显而易见的是，在完全随机的情况下，元素均匀插入，二叉树接近完全，其高度的期望为 $O(\log_2n)$。

# 红黑树

## 性质

一个基于二叉搜索树增加一个颜色属性的树，保证没有任何路径会比另一条路径长出二倍的近似平衡树。

-   每个结点是红色或黑色的
-   根结点是黑色的
-   每个叶子结点都是黑色的
-   如果一个结点是红色的，则其两个子结点都是黑色的
-   对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同树木的黑色结点。

性质 5 是红黑树的核心：红黑树是一颗近似平衡二叉树。

为了避免叶子结点的空间浪费，可以指定一个哨兵结点为 NIL，并使所有叶子都指向这一个结点。通常忽略叶子结点，因为其并不储存 key 值。

![An example of a red-black tree](https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/1350px-Red-black_tree_example.svg.png)

定义任何一个结点的黑高为从该结点到其后代叶子结点的路径上黑色结点的数目。根据性质 5，任何一条简单路径的黑高都相同。一颗有 $n$ 个内部结点的红黑树的高度至多为 $2\log_2(n+1)$。

## 旋转操作

显然，红黑树的查找和一般的二叉搜索树一样。对于插入和删除，为了维护红黑树的性质，需要进行旋转操作。两种操作的时间代价均为 $O(\log_2n)$。旋转操作分为左旋和右旋。旋转的目的是改变两棵子树的高度。旋转前后二叉搜索树的性质不变。可以看到，旋转前后，除 P、Q 两个结点之外的其他三个之间的左右顺序不变，这保持了二叉搜索树的性质。

![Rotation of Tree](https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png)

## 插入

将要插入的结点按照正常二叉搜索树插入，这时有可能破坏性质 4、5。我们把这个结点标记为红色，于是只可能违反性质 4。然后，调用一个过程，从这个新结点开始进行红黑树的调整。我们将所有情形概括为 5 种：

1.  如果新插入的结点是整棵树的根结点结点，显然直接将其涂为黑色即可。

2.  或者，新结点的父结点是黑色。这时，红黑树的任何性质都没有受到影响，无需任何操作。否则，为了保证被插入结点的父结点左右黑高相等，我们就需要进行旋转调整。旋转调整分为以下三种情形：

3.  父结点和叔父结点（父结点的兄弟结点）都是红色的。为了满足性质 4，将这两个结点都涂成黑色，并将祖父结点涂成红色。这时，新加入的结点和两个父辈结点都能保证符合红黑树的性质，而被涂红的祖父结点不一定。将祖父结点当成新加入的结点，递归地从情形 1 开始进行整个检查过程。

![情形3示意图](https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png)

4.  父结点是红色，叔父结点为黑色或不存在（实际上是黑色的哨兵结点），并且，子结点方向不一致。形象地说，新结点、父结点、祖父结点不在同一条直线上，有一个拐弯。此时，首先进行一次旋转，将其与其父结点 P 对调。三代结点现在位于一条直线上，都是左子结点或右子结点。随后，把被调换到下面的 P 当做新加入的结点，进行情形 5 的操作。

![情形4示意图](https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png)

5.  父结点是红色，叔父结点为黑色或不存在，并且新结点 N 和其父结点 P 都是各自父结点的同一个方向的子结点。即，三代结点在一条直线上。对新结点的父结点和祖父结点进行一次旋转。即，将这条直线的中间一点变成高点。这个过程，实际上是由于无法直接通过着色来满足性质 4，于是选择通过旋转来改变新结点的父结点。

![情形5示意图](https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png)

所有的情形，使用的都是尾递归。因此，整个算法是一个原地算法。算法的时间代价为 $O(\log_2n)$，且最多发生两次旋转，即情形 4-5 的路径。

## 删除操作

对任何一个结点，它本身有红色和黑色两种可能，子结点的情况有 0、1、2 三种可能，得到以下的这些情况：

-   被删结点为红色，没有子结点：直接删除即可。

-   被删结点为黑色，并有一个子结点。这时，这个子结点必然为红色。于是，交换这两个结点并改变颜色，就可以安全删除。

-   被删结点为红色，并有一个子结点。这种情况不可能存在。

-   被删结点有两个子结点。这时，首先使用与二叉搜索树一样的方法，用后继结点替代这个结点。在这里只对 key 进行替代即可。此时，实际上就变成了删除后继结点的情况，可以进行递归讨论。

接下来讨论被删结点为黑色且没有子结点的情况。以下所有的图中，N 为被删除的结点的位置，P 是父结点，S 是兄弟结点。

1.  兄弟结点为黑色，且有一个与兄弟结点方向一致的红色子结点。这时，进行旋转操作。

![情形 6 示意图](https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png)

2.  兄弟结点为黑色，且兄弟结点有一个方向不一致的红色子结点。这时，先将兄弟结点进行一次旋转，转化为第 1 种情形。

![情形 5 示意图](https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png)

3.  兄弟结点为黑色，且兄弟结点没有红色子结点。

    1. 若父结点为红，直接对兄弟结点和父结点重新着色即可。

    2. 若父结点为黑色，则对兄弟结点标为黑色，并对父结点进行递归判断。

![情形 4 示意图](https://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png)

![情形 3 示意图](https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png)

4.  兄弟结点为红色。此时，父结点一定是黑色。对父结点和兄弟结点进行一次旋转并重新上色。

![情形 2 示意图](https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png)

# AVL 树

AVL 树是另一种二叉平衡树。由于这种树的维护代价比较高，在实际应用中并不常见。不过其操作的复杂度同样为 $O(\log_2n)$。在 AVL 树中，两个分支的高度最多相差 1。AVL 树的旋转操作与红黑树类似，只是对于每个结点，不再有红黑属性值，而是变成了高度值（从一个布尔值变成一个整型）。另一种实现是存储两个子树高度的差，此时这个值的范围是 -1、0 或 1。

由于所有路径的高度最多相差 1，从任何一个结点向上到根的路径上，最多有两个不平衡的结点（只有一个子结点）。在改变结点之后，如果路径上存在两个不平衡的结点，就需要调整。

## 插入

我们把插入之后得到的情况分为 4 种，分别称为 LL、LR、RL、RR。通过旋转操作，将树重新平衡。在按照二叉搜索树的方法插入新结点后，要从新的结点一直回溯到根，逐个遍历，判断是否需要进行旋转。

![avl树旋转的图形描述](https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png)

## 删除

与一般的二叉搜索树一样，将含有两个子结点的结点的删除操作转化为其前驱或后继结点的删除。随后，同样回溯到根，检查是否出现失衡。

# B 树与红黑树

## 2-3 树（3 阶 B 树）

我们将结点分为两种，2 - 结点有一个 key，并有两个子结点。3 - 结点有两个 key，有三个子结点并保持类似于二叉搜索树的性质。注意，2-3 树中每一层都必须是完全的，也就是不存在 NIL。在向 3 - 结点进行插入时，结点分裂，挤出一个 key 给父结点，并向上回溯。2-3 树是一个绝对平衡的树，操作的复杂度为 $\Theta(\log_2n)$。

![2-3 树的插入](https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/2-3_insertion.svg/581px-2-3_insertion.svg.png)

## 2-3-4 树与红黑树

2-3-4 树的结构和 2-3 树类似，只是最大的结点变成了 4- 结点。可以看到，这类树的实现比较复杂。现在考虑：将红黑树的所有红色的边放平。并合并。于是，红黑树的黑高变成了 2-3-4 树的高，红色的结点与其父结点合并变成了 2-3-4 树的结点。于是，红黑树与 2-3-4 树是等价的。

