+++
title = '5. Trie-Tree, Extending Data Structures'
math = true
+++

# Trie 树（前缀树）

前缀树的结构是这样的：每个结点的一个分支代表一位数据。这里的一位不一定是一个 bit，也可以是一个字符等，因为前缀树经常被用在字符串处理，如输入时的提示。在这里，节点内部并不需要保存 key，因为其所有位都已经表示在了路径上。

![Trie 树](https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png)

如果每一个分支不只保存一个位，将唯一子树与其父节点合并，就变成了基数树。基数树需要保存的路径信息变多了，但不再使用无用的结点。

![基数树](https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Patricia_trie.svg/400px-Patricia_trie.svg.png)

# Huffman 编码

Huffman 编码就是一种使用前缀的编码方法，其核心是前缀树的构建。Huffman 编码采用这样的基于概率的前缀构建：将所有可能的值作为叶子，并不断合并频率和最小的两个节点，最终构成一颗二叉前缀树。

![Huffman 编码动图](https://upload.wikimedia.org/wikipedia/commons/c/c8/Huffman_algorithm.gif)

树构建完成之后，在每一个节点，以左侧为 0，右侧为 1，构建前缀编码。Huffman 编码是最优的前缀编码。类似地，自顶向下构建前缀树，在每一步尽量使两侧概率相等的编码方式称为 Shannon-Fano 编码，这种方法不一定总能得到最优编码。

# 数据结构的扩展

在这里，数据结构的扩展指的是在原有数据结构上做出一些修改，使得其能够支持更多的特性。这些修改包括设计新的操作，以及增加可能的域。

## 动态顺序统计

为了获得一个集合里每个元素的次序，在红黑树结点的基础上增加一个域 `size`，用于保存以这个节点为根的子树的总结点数。即顺序统计量。定义中序遍历的顺序为这个元素的秩。

给定秩，寻找相应的元素。从根出发，左子树的 `size+1` 就是这个节点所在的位置。判断和输入的大小关系，选择子树继续寻找。

给定元素寻找秩的过程与之相反。从这个节点回溯到根，将所有的左子树 `size+1` 加起来，就是这个结点的秩。两种查找的复杂度均为 $O(\log_2n)$。

为了维护 `size` 域的值，在每一次插入和删除时，都需要回溯至根来修改，复杂度为 $O(\log_2n)$。此外，当发生旋转时，也要分别修改 `size`。修改的复杂度为 $O(1)$，所以插入和删除的复杂度不变，仍为 $O(\log_2n)$。

## 区间树

接下来，我们以红黑树为基础，构建一个可以保存区间对象的数据结构，以展示如何进行数据结构的扩展。

1.  基础数据结构：每个节点包含一个区间信息，并以区间的低端点作为其关键字。

2.  附加信息：每个节点额外维护一个值 `max`，它是以这个节点为根的子树中的所有区间端点的最大值。

3.  对信息的维护：每个结点的 `max` 为 `max(x.int.high, x.left.max, x.right.max)`。于是，更新这个属性的复杂度为 $O(\log_2n)$。实际上，操作的复杂度只有 $O(1)$。

4.  设计新的操作：查找与指定区间相交的区间。在查找时，如果左子结点的 `max` 大于查找目标的左端点，说明左子树中有重叠的部分，则进入左子树继续查找。

