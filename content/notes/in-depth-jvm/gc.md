# GC 算法

## 判断对象是否存活

判断对象存活的算法主要有两个：引用计数算法与可达性算法。其中，引用计数的实现十分简单，但这个算法对于循环引用不能很好地解决。因此，包括 C#、JAVA、Lisp 在内的主流实现使用的都是可达性分析算法。

### 可达性分析算法

可达性分析算法的首要问题是 GC Roots 的选择。GC Root 可以理解为我们"希望存活"的引用。JVM 中可以作为 GC Root 的包括:

-   VM 栈帧中的引用
-   方法区中的静态属性
-   方法区中的常量属性
-   本地栈中的本地方法中的引用

此外，在进行部分 GC 时，还可能把不收集部分指向收集部分的引用包括在内。例如，对新生代的 GC，老年代的对象中的引用也应该成为 GC Roots。此外，弱引用在新生代 GC 不被回收，因此属于 GC Root。到了 Full GC，弱引用需要被回收，就不属于 Root。当然，这些优化同时也会带来一定的代价，不同的 GC 器可能有不同的实现和权衡。无论如何，上面列出的四种时一定会作为 GC Root 出现的。

JDK 1.2 之后，为了进行更加细致的 GC 处理，Java 引入了四种不同强度的引用。具体可以参见[这里](/posts/java-from-threadlocal-to-weak-reference.html)。

### Finalize() 方法

`finalize()` 方法的规范比较奇怪，这和 Java 的历史沿革有一定的关系。这个方法不应该在正常的开发中被使用。

在 GC 过程中，对象要首先被标记（回忆对象头部分的内容），然后再进行真正的 GC。在标记之后，JVM 会对对象进行判断。如果：

-   对象所在的类覆盖了 `finalize()` 方法
-   对象的 `finalize()` 方法没有被调用过

那么这个对象将会被放进队列，并执行 `finalize()` 方法。如果在 `finalize()` 方法中，对象重新建立了自己与存活对象的引用关系，例如将自己放进了一个集合中，那么这个对象就不会被回收。不过，`finalize()` 方法只能被调用一次。在下一次回收中，如果这个对象再次被标记，就没有机会再次"拯救自己"。而且，这个方法的优先级相当低。

``` java
public class FinalizeEscapeExample {
    public static Object obj = null;

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        Systemout.println("Finalize() Called");
        obj = this;                                   // escape from gc
    }

    public static void printStatus() {
        System.out.println(obj == null ? "dead" : "alive");
    }

    public static void main(String[] args) {
        obj = new FinalizeEscapeExample();
        obj = null;
        System.gc();                                  // not promised a gc, so use VM arg
        Thread.Sleep(500);
        printStatus();

        obj = null;
        System.gc();
        Thread.sleep(500);
        printStatus();
    }
}
```

得到的结果是：

``` sh
Finalize() Called
alive
dead
```

这说明，在第一次被回收时，对象成功从 GC 中逃脱。但 `finalize()` 只能被调用一次，因此第二次 GC 中这个对象被回收了。

### 方法区的回收策略

JVM 并未要求虚拟机对方法区进行垃圾回收。实际应用中这个区域也很少变得非常大，但在现代框架大量的动态生成的状况下，进行垃圾回收仍有必要。现在，HotSpot 默认为 Metaspace 不规定最大大小，但仍然在达到一定大小后进行 Full GC。

方法区中的常量池的 GC 相对比较简单，只要这个常量没有被引用，就可以认为是无用的而进行 GC。而类型信息的 GC 必须满足：

-   不存在任何该类的实例对象
-   加载类的 ClassLoader 已经被回收
-   类对应的 `java.lang.Class` 对象没有在任何地方被引用。这意味着无法通过反射访问该类的方法。

类至少要满足这样的条件才能被回收。相关的 JVM 参数包括：`-Xnoclassgc` `-verbose:class` `-XX:+TraceClassLoading` 等。

## GC 算法

### 标记 - 清除算法 Mark-Sweep

标记清除算法的实现十分显而易见。这个算法的缺点主要有两个：首先，标记和清除两个过程的效率都不算高。其次，简单的标记清除会带来大量的内存碎片。不仅为内存分配管理带来困难，也可能在内存仍有大量剩余时就出现无法分配对象的情况（在 HotSpot 这类对象需要连续空间的 JVM 上）。

### 复制算法

复制算法是当前绝大部分现代 JVM 用来处理新生代对象的算法。朴素的复制算法将内存分成两半，每次只使用一块。进行 GC 时，将所有存活的对象复制到另一块，这样得到的新的内存空间就是连续完整的。当然，这样做的代价未免太大。

现代 JVM 使用的复制算法将新生代内存分成三部分：一块 Eden 和两块 Survivor 部分。JVM 在同一时间使用 Eden 空间和其中一块 Survivor 空间。

在分配新对象时，所有的新生对象都被分配在 Eden 空间中。进行 GC 时，将 Eden 和 From Survivor 中所有存活的对象全部复制到 To Survivor 区域中。这样，我们就得到了新的 Survivor 和空白的 Eden 空间。

这种设计基于 90 % 以上的对象都是 "朝生夕死" 这个实际情况。我们认为，一块 Survivor 足以装下上次 GC 到现在的所有仍然存活的对象。Eden 和 Survivor 的比例默认是 8，也就是 8:1:1 的分配比例，同时也意味着会有 10% 的内存被空闲。当 Survivor 空间不足时，我们使用老年代内存来进行**分配担保**（Handle Promotion）。

### 标记 - 整理算法 Mark-Compact

复制算法在对象存活率较高时需要大量的复制，并且如果不适用分配担保，就需要两倍的内存空间。因此，这种算法不适用于老年代的收集。因此，在这里通常使用标记 - 整理算法。其基本流程和标记清除算法一样，只是会将对象进行移动，"紧凑" 到内存区域的头部。

## HotSpot 中的算法实现：GC 停顿

### 枚举 GC Root

枚举 GC Root 过程的主要问题是 Stop the World。显然，如果引用关系发生变化，就不可能进行 GC。考虑到现代很多应用仅方法区就能达到数百 MB，排查引用关系的时间可能是无法接受的。即使是几乎不会停顿的 CMS 收集器，枚举 GC Root 也要进行停顿。

早期 Solaris 平台上出现的 Exact VM 提出了准确式 GC 的概念。这类 GC 的特点是，收集器明确地知道内存中每一块数据的实际类型，例如是整数还是引用地址。这样的结果是在进行对象的一次移动之后，收集器可以十分迅速的将所有指向该对象的引用进行修改。通过这种方式，Exact VM 抛弃了基于句柄的对象查找方式，减少了寻址的开销。

在 HotSpot 中，使用一组称为 `OopMap` 的数据结构来完成这件事。在类加载过程和 JIT 编译过程中，虚拟机都会记录下对象内、寄存器内和栈中引用的位置。

### 安全点 SafePoint

但是，将所有引用的变化都记录到 `OopMap` 中是不现实的。因此，HotSpot 规定了一定的 "安全点"，只有在安全点才会发生 `OopMap` 的修改，也才能进行 GC。显然，SafePoint 太少会造成 GC 的等待，太多则会降低性能。为此，HotSpot 以 "长时间执行" 或 "指令序列复用" 的原则来规定 SafePoint，例如方法调用、循环跳转、异常跳转等。

另一个需要考虑的问题是，GC 时需要让所有的线程都停下来，这就带来了线程之间的互相等待。这个过程主要有两种想法：

-   抢先式中断，即首先中断所有的线程，再将未达到 SafePoint 的线程重新唤醒。显然，这种方式下线程的实现较简单，而收集器实现较复杂，而且会带来性能浪费。目前几乎没有 JVM 使用这种方式。
-   主动式中断，即在要进行 GC 时，将一个全局的中断标记设置好，由线程去轮询这个标记。轮询的位置和安全点相同。

### 安全区域

实际情况中，线程不一定始终都是运行的。如果线程被阻塞，就不会到达安全点，更不会去轮询标记。不过，这种情况下的线程显然对 GC 没有不良影响。因此，处于休眠或阻塞状态的线程被认为进入了安全区域（Safe Region）。GC 可以正常在此时发生。当线程被重新唤醒时，首先要检查GC Root 枚举或者 GC 是否已经完成。如果没有，就要等待完成才能离开安全区域，继续任务。

# 垃圾收集器

OpenJDK / Oracle JDK 7u14 之后，G1 收集器正式脱离了试验阶段。至此，HotSpot 中一共有七个可用的收集器。在下面的图示中，有连线的收集器可以协同使用。

![JVM的GCer](/img/201805/JVM_GC_GCers.png)

## Serial / Serial Old / ParNew

Serial 是最早的收集器，使用单线程的方式进行 GC。进行 GC 时，JVM 在 SafePoint 停止所有的线程，并由 GC 线程完成的 GC 工作。二者的区别是使用场景，Serial Old 使用标记 - 整理算法，适合老年代。Serial 使用复制算法，适合新生代。在某些环境下，尤其是桌面客户端环境下，Serial 仍然是默认的收集器，因为其单线程模式对 CPU 的负担较小，且对于几百兆的堆，几十毫秒的暂停完全可以接受。

同时，Serial Old 还担负着作为 CMS 收集器 和 G1 收集器的后备预案的作用，在新生代或老年代的 Minor GC 无法正常完成时，进行 Full GC，使用这个收集器。同时，Parallel Scavenge 收集器的老年代部分与 Serial Old 也十分相似。

ParNew 收集器是 Serial 的多线程版本，适用于新生代。其控制参数、收集算法、暂停情况、回收策略等几乎都与 Serial 一样。这个收集器被广泛用于 Server 的一个原因是，Parallel Scavenge 无法和 CMS 收集器配合工作，ParNew 就成为了新生代收集最合适的选择。当然，简单的多线程在单核心上带来的效果可能是负优化的，因此客户端上 Serial 仍然是一个比较好的选择。

## Parallel Scavenge / Parallel Old

Parallel Scavenge 是一个新生代收集器。与追求最短的停顿时间的 CMS 不同，Parallel Scavenge 追求一个可控制的吞吐量（Throughput）。这个概念是指，希望更多的 CPU 时间被用来运行用户代码而非垃圾收集。这意味着，追求短暂停顿的 CMS 适合需要与用户交互的程序，能够带来更短的响应时间。而 Parallel Scavenge 追求更大的用户代码占比，也就是希望更快地完成一个后台批处理式的任务。这个收集器也被称为 "吞吐量优先" 收集器。

相关的参数主要是： `-XX:GCTimeRatio`，控制 GC 时间在总时间中的占比，即吞吐量。若为默认值 99，即允许 1% 的 GC 时间。如果设置为 19，则允许 5% 的 GC 时间。`-XX:MaxGCPauseMillis` 指定允许的最长 GC 停顿。当然，停顿越短，GC 就会发生得越多，吞吐量也会下降。此外还有 `-XX:+UseAdaptiveSizePolicy`，如果开启，就不需要手动指定新生代大小、Eden 区域比例等参数。

这时我们会发现，如果使用 Parallel Scavenge 作为新生代收集器，那么老年代就只能使用老旧的 Serial Old。因此，JDK 1.6 之后引入了 Parallel Old 收集器，这是 Parallel Scavenge 的老年代版本。总的来看，这两个收集器的合作效果相对于 Serial + Serial Old 的主要区别，是在暂停所有线程开始 GC 时，能够充分利用多个线程的优势，更快地完成 GC。

## CMS

### CMS 的流程

CMS（Concurrent Mark Sweep）的设计目标是争取最短的停顿时间，以适应交互式应用的需求，尤其适合 Web 场景。为了尽量减少 Stop The World，CMS 分成了四个步骤：

-   初始标记 Initial Mark
-   并发标记 Concurrent Mark
-   重新标记 Remark
-   并发清除 Concurrent Sweep

其中初始标记和重新标记阶段需要 Stop The World，另外两个则可以在线程继续运行时进行。

初始标记阶段只标记 GC Root 直接关联的对象，这个过程通常很快。然后，线程可以重启，CMS 进行并发标记，即 GC Root Tracing 过程，判断对象的存亡。接下来，再次停下线程，进行重新标记，目标是处理那些在并发标记阶段发生了引用关系变化的对象。这个过程虽然比初始标记略长，但比并发标记短得多。最后的清除过程显然可以在程序运行时进行，不受干扰。

于是，一次 CMS 的 GC 需要停顿两次，但耗时最长的部分都能够并发地进行而不需要中断线程。因此一些文档也将其称为 Concurrent Low Pause Collector。

### CMS 的缺点

首先，并发的 CMS 收集器必然会消耗相当多的 CPU 资源，降低总的吞吐量。并发数越高，消耗的 CPU 核心必然越大。这也是为什么尽管它能够带来高响应，却不能用于客户端应用。

其次，CMS 会面临浮动垃圾问题，也就是在并发标记阶段用户程序新产生的垃圾。由于这时还没有进行清除，且本次 GC 不会清除它们，如果用户产生的浮动垃圾很多，就会引发内存不足，需要一次 Full GC 才能解决。这个错误被报告为 Concurrent Mode Failure。因此，上面我们提到，在这时使用 Serial Old 作为后备预案进行老年代 GC，这个时间在服务器的大堆上就变得相当长了。为此，CMS 并不像其他收集器一样等到老年代几乎满了再收集，而是使用 `-XX:CMSInitiatingOccupancyFraction` 定义的比例来判断。如果这个比例太高，就会产生大量糟糕的 Concurrent Mode Failure。

最后，CMS是一款标记 - 清除类型的收集器，这意味着它可能产生内存碎片。当大对象找不到位置来分配时，就会引发 Full GC。JVM 的设计者在这里提供了两个参数，`-XX:+UseCMSCompactAtFullCollection` 默认开启，指定在 CMS 导致的内存碎片带来 Full GC 时使用标记 - 整理算法，不过整理过程时无法并发的，性能较差。或者使用 `-XX:CMSFullGCsBeforeCompaction` 来制定每经过多少次 Full GC 就进行一次整理，默认为 0，即每次都整理。

## G1

### G1 的特点与核心思想

G1（Garbage First）收集器在 JDK 7u4 才从实验状态移出，投入实用，这是一种面向服务端的收集器，同时包括新生代和老年代的管理能力。其主要特点包括：

-   并行与并发
-   分代收集
-   空间整理：G1 整体来看基于标记 - 整理算法，局部来看则是复制算法。无论哪个，都不会造成内存碎片。
-   可预测停顿：除了减少停顿之外，G1 还追求可预测的停顿时间。允许指定一定时间内用于 GC 的最多时间。

首先，G1 将内存分为多个 Region。新生代和老年代不再是直接区分，而是分别由一系列 Region 组成。G1 跟踪各个 Region 垃圾堆积的价值大小，即回收后能够释放的空间大小与回收所需时间的评判。每次 GC 时，G1 根据所允许的 GC 停顿时间，选择回收价值最大的 Region。这样，就能够保证尽量高的收集效率和可控的收集时间。

可以看到，G1 时采用了 "化整为零" 的方式进行 GC。不过，每个 Region 都不是独立的，在进行引用关系分析时必然要对整个堆进行扫描。为了解决这个问题，虚拟机为每个 Region 维护了一个 Remembered Set。每当引用关系发生变化时，虚拟机检查引用的对象是否位于不同的 Region，并记录到 Remembered Set 中去。对 Region 进行回收时，只要将 Remembered Set 加入到 GC Root 中即可。回顾上面说到的 GC Root 的概念，也就是说，被其他 Region 引用的对象不会被回收。在这种部分收集中，不收集部分也可以作为 GC Root，以避免全堆扫描。这里的 Remembered Set 起到的就是这个作用。也就是说，最终的结果来看，Remembered Set 中存储的是从其他 Region 指向这个 Region 的引用的信息。在进行可达性分析时，只需要从这里出发即可。

### G1 的运行

排除更新 Remembered Set 的过程，G1 GC 基本上可以分为四部分：

-   初始标记 Initial Marking
-   并发标记 Concurrent Marking
-   最终标记 Final Marking
-   筛选回收 Live Data Counting & Evacuation

可以看到，这个流程与 CMS 有一定的相似性。首先，单线程地进行快速的初始标记，记录下与 GC Root 直接相连的对象，并修改 TAMS（Next Top at Mark Start）的值，以改变下一阶段并发进行时，用户程序分配新对象的 Region。然后，并发标记阶段回复程序运行，并进行可达性分析，找出存活的对象。

与 CMS 类似，最终标记阶段也是用来处理并发标记过程中标记发生改变的部分对象。虚拟机将这段时间的变化记录在 Remembered Set Logs 中，最终标记阶段会检查这部分内容并将其合并到 Remembered Set 中去。这个阶段需要停顿线程，但可以并行执行。最后，筛选回收阶段根据优先级和用户定义的停顿时间制定回收计划。在目前的实现中，这个阶段也要停顿线程，以追求更快的回收。在筛选回收的阶段，G1 将 Region 中所有存活的对象拷贝到其他 Region，并将这个清空。这样，就能得到整理内存的效果。

G1 同时提供了新生代和老年代的 GC。它不再严格区分新生代和老年代，而是以 Region 为单位管理内存。当部分收集也出现了内存问题时，就只能使用 Serial Old 的 Full GC。

在下面的图示中，浅色箭头表示 CPU 正在执行用户线程，深色表示 JVM 的收集器线程。

![G1运行](/img/201805/JVM_GC_CMS&G1.png)

# 内存分配策略

下面介绍的内容基于 Serial / Serial Old 组合，目的是介绍最基本的一些内存分配原则。不同的收集器下，分配的规则会发生变化。在这个搭配下，Minor GC 仅针对于新生代，Major GC / Full GC 指老年代回收，通常在其之前伴随一次 Minor GC，但并不绝对。

-   优先分配于 Eden

-   大对象直接进入老年代（避免复制）

-   长期存活的对象进入老年代：每经过一次 Minor GC，年龄加一。

-   动态对象年龄判定：若 Survivor 中相同年龄对象超过了总 Survivor 空间的一半，这个年龄及更老的直接进入老年代。

-   空间分配担保：若老年代的剩余空间大于新生代所有对象的总和，则可以确保安全。否则检查 `HandlePromotionFailue`。如果允许，则继续检查老年代最大的连续可用空间是否大于历次晋升数量的平均大小。如果是，则尝试一次有风险的 Minor GC。剩余的情况，都会改成一次 Full GC。

这个做法略微复杂。总的来看，就是需要保证老年代能够承接 Survivor 装不下的对象。如果第一个条件不满足，我们就只能取一个平均值作为 Survivor 中存活的对象量的一个预测。因此这时的 Minor GC 是有风险的。极端情况就是，所有的新生代对象都存活。担保失败或选择不予担保的情况，就只能通过 Full GC 来解决。
