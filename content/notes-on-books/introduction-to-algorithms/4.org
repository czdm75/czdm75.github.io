#+TITLE: Balanced BST, Trie-Tree
#+MATH: true

* 红黑树

** 性质

一个基于二叉搜索树增加一个颜色属性的树，保证没有任何路径会比另一条路径长出二倍的近似平衡树。

- 每个结点是红色或黑色的
- 根结点是黑色的
- 每个叶子结点都是黑色的
- 如果一个结点是红色的，则其两个子结点都是黑色的
- 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同树木的黑色结点。

性质 5 是红黑树的核心：红黑树是一颗近似平衡二叉树。

为了避免叶子结点的空间浪费，可以指定一个哨兵结点为 NIL，并使所有叶子都指向这一个结点。通常忽略叶子结点，因为其并不储存 key
值。

#+caption: An example of a red-black tree
[[https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/1350px-Red-black_tree_example.svg.png]]

定义任何一个结点的*黑高*为从该结点到其后代叶子结点的路径上黑色结点的数目。根据性质 5 ，任何一条简单路径的黑高都相同。一颗有 \(n\) 个内部结点的红黑树的高度至多为 \(2\log_2(n+1)\)。

** 旋转操作

显然，红黑树的查找和一般的二叉搜索树一样。对于插入和删除，为了维护红黑树的性质，需要进行旋转操作。两种操作的时间代价均为 \(O(\log_2n)\)。旋转操作分为左旋和右旋。旋转的目的是改变两棵子树的高度。旋转前后二叉搜索树的性质不变。可以看到，旋转前后，除 P、Q 两个结点之外的其他三个之间的左右顺序不变，这保持了二叉搜索树的性质。

#+caption: img
[[https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png]]

** 插入

将要插入的结点按照正常二叉搜索树插入，这时有可能破坏性质 4、5。我们把这个结点标记为红色，于是只可能违反性质 4。然后，调用一个过程，从这个新结点开始进行红黑树的调整。我们将所有情形概括为 5 种：

1. 如果新插入的结点是整棵树的根结点结点，显然直接将其涂为黑色即可。

2. 或者，新结点的父结点是黑色。这时，红黑树的任何性质都没有受到影响，无需任何操作。

否则，为了保证被插入结点的父结点左右黑高相等，我们就需要进行旋转调整。旋转调整分为以下三种情形：

3. 父结点和叔父结点（父结点的兄弟结点）都是红色的。为了满足性质 4，将这两个结点都涂成黑色，并将祖父结点涂成红色。这时，新加入的结点和两个父辈结点都能保证符合红黑树的性质，而被涂红的祖父结点不一定。将祖父结点当成新加入的结点，递归地从情形 1 开始进行整个检查过程。

   #+caption: 情形3示意图
   [[https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png]]

4. 父结点是红色，叔父结点为黑色或不存在（实际上是黑色的哨兵结点），并且，子结点方向不一致。形象地说，新结点、父结点、祖父结点不在同一条直线上，有一个拐弯。

   此时，首先进行一次旋转，将其与其父结点 P 对调。三代结点现在位于一条直线上，都是左子结点或右子结点。随后，把被调换到下面的 P 当做新加入的结点，进行情形 5 的操作。

   #+caption: 情形4示意图
   [[https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png]]

5. 父结点是红色，叔父结点为黑色或不存在，并且新结点 N 和其父结点 P 都是各自父结点的同一个方向的子结点。即，三代结点在一条直线上。对新结点的父结点和祖父结点进行一次旋转。即，将这条直线的中间一点变成高点。

这个过程，实际上是由于无法直接通过着色来满足性质 4，于是选择通过旋转来改变新结点的父结点。

#+caption: 情形5示意图
[[https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png]]

所有的情形，使用的都是尾递归。因此，整个算法是一个原地算法。算法的时间代价为 \(O(\log_2n)\)，且最多发生两次旋转，即情形 4-5 的路径。

** 删除操作

对任何一个结点，它本身有红色和黑色两种可能，子结点的情况有 0、1、2 三种可能，得到以下的这些情况：

- 被删结点为红色，没有子结点：直接删除即可。

- 被删结点为黑色，并有一个子结点。这时，这个子结点必然为红色。于是，交换这两个结点并改变颜色，就可以安全删除。

- 被删结点为红色，并有一个子结点。这种情况不可能存在。

- 被删结点有两个子结点。这时，首先使用与二叉搜索树一样的方法，用后继结点替代这个结点。在这里只对 key 进行替代即可。

  此时，实际上就变成了删除后继结点的情况，可以进行递归讨论。

接下来讨论被删结点为黑色且没有子结点的情况。以下所有的图中，N 为被删除的结点的位置，P 是父结点，S 是兄弟结点。

1. 兄弟结点为黑色，且有一个与兄弟结点方向一致的红色子结点。这时，进行旋转操作。

   #+caption: 情形6示意图
   [[https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png]]

2. 兄弟结点为黑色，且兄弟结点有一个方向不一致的红色子结点。这时，先将兄弟结点进行一次旋转，转化为第 1 种情形。
   [[https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png]]

3. 兄弟结点为黑色，且兄弟结点没有红色子结点。若父结点为红，直接对兄弟结点和父结点重新着色即可。

   #+caption: 情形4示意图
   [[https://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png]]

   若父结点为黑色，则对兄弟结点标为黑色，并对父结点进行递归判断。

   #+caption: 情形3示意图
   [[https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png]]

4. 兄弟结点为红色。此时，父结点一定是黑色。对父结点和兄弟结点进行一次旋转并重新上色。

   #+caption: 情形2示意图
   [[https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png]]

* AVL 树

AVL 树是另一种二叉平衡树。由于这种树的维护代价比较高，在实际应用中并不常见。不过其操作的复杂度同样为 \(O(\log_2n)\)。在 AVL 树中，两个分支的高度最多相差 1。AVL 树的旋转操作与红黑树类似，只是对于每个结点，不再有红黑属性值，而是变成了高度值（从一个布尔值变成一个整型）。另一种实现是存储两个子树高度的差，此时这个值的范围是 -1、0 或 1。

由于所有路径的高度最多相差 1，从任何一个结点向上到根的路径上，最多有两个不平衡的结点（只有一个子结点）。在改变结点之后，如果路径上存在两个不平衡的结点，就需要调整。

** 插入

我们把插入之后得到的情况分为 4 种，分别称为 LL、LR、RL、RR。通过旋转操作，将树重新平衡。在按照二叉搜索树的方法插入新结点后，要从新的结点一直回溯到根，逐个遍历，判断是否需要进行旋转。

#+caption: avl树旋转的图形描述
[[https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png]]

** 删除

与一般的二叉搜索树一样，将含有两个子结点的结点的删除操作转化为其前驱或后继结点的删除。随后，同样回溯到根，检查是否出现失衡。

* B 树与红黑树

** 2-3 树（3 阶 B 树）

我们将结点分为两种，2 - 结点有一个 key ，并有两个子结点。3 - 结点有两个 key ，有三个子结点并保持类似于二叉搜索树的性质。注意，2-3 树中每一层都必须是完全的，也就是不存在 NIL 。在向 3 - 结点进行插入时，结点分裂，挤出一个 key 给父结点，并向上回溯。2-3 树是一个绝对平衡的树，操作的复杂度为 \(\Theta(\log_2n)\)。

#+caption: img
[[https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/2-3_insertion.svg/581px-2-3_insertion.svg.png]]

** 2-3-4 树与红黑树

2-3-4 树的结构和 2-3 树类似，只是最大的结点变成了 4- 结点。可以看到，这类树的实现比较复杂。现在考虑：将红黑树的所有红色的边放平。并合并。于是，红黑树的黑高变成了 2-3-4 树的高，红色的结点与其父结点合并变成了 2-3-4 树的结点。于是，红黑树与 2-3-4 树是等价的。

* Trie 树（前缀树）

前缀树的结构是这样的：每个结点的一个分支代表一位数据。这里的一位不一定是一个 bit，也可以是一个字符等，因为前缀树经常被用在字符串处理，如输入时的提示。在这里，节点内部并不需要保存 key ，因为其所有位都已经表示在了路径上。

#+caption: img
[[https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png]]

如果每一个分支不只保存一个位，将唯一子树与其父节点合并，就变成了基数树。基数树需要保存的路径信息变多了，但不再使用无用的结点。

#+caption: img
[[https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Patricia_trie.svg/400px-Patricia_trie.svg.png]]

** Huffman 编码

Huffman 编码就是一种使用前缀的编码方法，其核心是前缀树的构建。Huffman 编码采用这样的基于概率的前缀构建：将所有可能的值作为叶子，并不断合并频率和最小的两个节点，最终构成一颗二叉前缀树。

#+caption: img
[[https://upload.wikimedia.org/wikipedia/commons/c/c8/Huffman_algorithm.gif]]

树构建完成之后，在每一个节点，以左侧为 0，右侧为 1，构建前缀编码。Huffman 编码是最优的前缀编码。类似地，自顶向下构建前缀树，在每一步尽量使两侧概率相等的编码方式称为 Shannon-Fano 编码，这种方法不一定总能得到最优编码。
