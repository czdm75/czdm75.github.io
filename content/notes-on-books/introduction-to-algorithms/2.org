#+TITLE: 2. HeapSort and QuickSort
#+MATH: true

* 排序算法

- 原地排序 (in place) ：仅需要常数的额外存储空间

- 堆排序：\(O(n\log_2n)\) 的原地排序算法

- 快速排序：期望为 \(\Theta(n\log_2n)\)，最坏情况为 \(\Theta(n^2)\)，实际应用中通常比堆排序快。同时，其常数系数很小，是排序大数组时的常用算法。

- 比较排序：通过对元素进行比较来决定，快排、归并、堆排序都是比较排序。比较排序的代价下界为 \(\Omega(n\log_2n)\)。

- 线性时间排序：计数排序、基数排序、桶排序，在一定条件下，可以取得线性时间代价。

| *算法*   | *最坏情况代价*        | *代价期望*            |
|----------+-----------------------+-----------------------|
| 插入排序 | \(\Theta(n^2)\)       | \(\Theta(n^2)\)       |
| 归并排序 | \(\Theta(n\log_2n)\) | \(\Theta(n\log_2n)\) |
| 堆排序   | \(O(n\log_2n)\)      |                       |
| 快速排序 | \(\Theta(n^2)\)       | \(\Theta(n\log_2n)\) |
| 计数排序 | \(\Theta(k+n)\)       | \(\Theta(k+n)\)       |
| 基数排序 | \(\Theta(d(k+n))\)    | \(\Theta(d(k+n))\)    |
| 桶排序   | \(\Theta(n^2)\)       | \(\Theta(n)\)         |

* 堆排序

复杂度为 \(O(n\log_2n)\)，常数个额外空间（原地排序）。

** 最大堆结构

最大堆是一个完全二叉树，且对于每一个结点，其子结点都比这个结点的值更小。通常使用数组来存储。这样，如果数组的下标从1开始，那么任意一个结点 \(n\) 的左子结点为 \(2n\)，右子结点为 \(2n+1\)，父结点为 \(\lfloor i/2\rfloor\)（向下取整）。这样，我们可以轻松地利用移位指令来取得结点下标，获得比较高的性能。显然，二叉树的高度为 \(\Theta(\log_2n)\)。于是，我们能得到一些堆上的基本操作的复杂度：

- 最大堆化（Max-heapify），复杂度为 \(\Theta(\log_2n)\)。

- 构建最大堆（Build-max-heap），线性时间复杂度，将无序数据转化为最大堆。

- 堆排序（Heapsort），复杂度为 \(O(n\log_2n)\)，对一个数组进行原地排序。

- 插入（Max-Heap-Insert）、删除最大（Heap-Extract-Max）、增长key（Heap-Increase-Key）、取得最大（Heap-Maximum），时间复杂度为 \(O(\log_2n)\)，功能是利用堆实现一个优先队列。

** 维护堆的性质：最大堆化

最大堆化（Max-heapify）的输入是一个数组 \(A\) 和一个下标 \(i\)。其中， \(i\) 结点的左右子树都是已经构建完成的最大堆，而 \(A[i]\) 不一定是。然后，我们通过“逐级下降”过程，将 \(A[i]\) 插入到适当的位置，使得以 \(A[i]\) 为根结点的子树是一个最大堆。

算法如下：在程序的每一步，判断当前结点和其左右子结点的大小关系。如果父结点最大，显然最大堆已经完成。否则，将父结点与更大的一个子结点交换，并下降到交换的位置，重复这个流程。通过这样的不断与子结点交换的过程，目标将下降到适当的位置，使整个二叉树成为一个最大堆。

这个过程中的代价包括：判断和调整三个结点的过程，代价为 \(\Theta(1)\) ，加上递归调用的代价。每个子树的大小最多为 \(\frac{2n}3\)（当树的最底层半满时），那么我们可以用递归式 \(T(n)\leqslant T(\frac{2n}3+\Theta(1))\) 来描述这个递归调用。使用主定理解得 \(T(n)=O(\log_2n)\)。也就是说，对于一个树高为 \(h\) 的结点，最大堆化的时间复杂度为 \(O(h)\)。

** 建堆

#+begin_example
for i = A.length/2 downto 1
    MAX-HEAPIFY(A,i)
#+end_example

将数组当成一个二叉树，从第一个非叶子结点开始，直到堆顶，不断进行最大堆化。在这个过程中，二叉树底部的结点，实行最大堆化的代价越小，而数量越多。结合上一部分得到的最大堆化的时间复杂度为
\(O(h)\) 的结论，这个过程的代价为：

\[\sum_{h=0}^{\lfloor \log_2n\rfloor}\lceil\frac n{2^{k+1}}\rceil O(h)=O(n)\sum_{h=0}^{\lfloor \log_2n\rfloor}\frac h{2^h}\]

又有公式：

\[\sum_{k=0}^{\infty}x^k=\frac x{(1-x)^2}\]

令 \(x=\frac12\) 可以得到：

\[\sum_{k=0}^{\infty}\frac h{2^h}=\frac{\frac12}{(1-\frac12)^2}=2\]

于是：

\[O(n)\sum_{h=0}^{\lfloor \log_2n\rfloor}\frac h{2^h}=O(n)\sum_{h=0}^{\infty}\frac h{2^h}=O(n)\]

因此，我们可以在线性时间内构建一个最大堆。

** 堆排序

最大堆只能保证父子结点之间的大小关系，而不能保证同一层之间的关系，因此，排序尚未完成。为此，我们可以不断取出最大堆的根结点，并放置在堆后面。这样，所有元素将以升序摆放好。

首先，将最大堆的根结点与最后一个结点互换。随后，对这个被换上来的结点执行最大堆化。在它被放置在正确的位置之后，整个序列中最大的值就被放置在了适当的位置，即数组的末尾，而其余值则仍然组成一个大小为 \(n-1\) 的最大堆（这也是从最大堆中取出最大值的方法）。不断重复这个过程，缩小最大堆，就能够将所有元素摆放在适当的位置。

** 优先队列

决定优先队列的顺序的值称为关键字（key）。 一个最大优先队列可以：

- 插入元素
- 取最大元素
- 删除最大元素
- 增大 key：将序列中一个元素的 key 修改为一个更大的值

最大优先队列可用于批处理式计算机系统的作业调度，用来寻找当前所有任务中优先级最高的开始执行。

显然，取得最大元素的时间复杂度为 \(\Theta(1)\)，删除最大元素的时间复杂度为 \(O(\log_2n)\)（相当于堆排序的第一步）。增大某个元素的key，可以在修改之后将其不断与其父结点比较并交换，直到这个结点小于其父结点，意味着它来到了适合的位置上。这个过程的复杂度为 \(O(\log_2n)\)。在队列中增加结点，可以先在末尾加入一个 key 为 \(-\infty\) 的结点（此时二叉树仍然是一个最大堆），再将其 key 增加为需要的值，并应用上面的算法。显然，复杂度为 \(O(\log_2n)\)。

* 快速排序

** 算法描述

- 分解：将数组划分为两个子数组和一个分界，并使所有左侧数组的值小于右侧数组。
- 解决：对两个子数组递归调用快速排序
- 合并：数组已经排序完成。

当数组长度为 1 时，可以直接认为这个子数组排序已完成。

快速排序划分算法的一种实现是：以数组末尾为主元（pivot），在内存中维护两个指针，分别代表两个数组的分界和右侧数组的末尾，初始化到数组头部。向右扫描，如果当前元素大于
pivot，说明其应该被放置在右侧数组，于是增长右侧指针的值。如果小于，则将其与右侧数组的第一个元素交换，并增长左侧指针的值。如下：

|   |   |   |   |   |  i | j |
|---+---+---+---+---+----+---|
| 2 | 8 | 7 | 1 | 4 | -1 | 0 |
| 2 | 8 | 7 | 1 | 4 |  0 | 1 |
| 2 | 8 | 7 | 1 | 4 |  0 | 2 |
| 2 | 8 | 7 | 1 | 4 |  0 | 3 |
| 2 | 1 | 7 | 8 | 4 |  1 | 4 |
| 2 | 1 | 4 | 8 | 7 |  - | - |

在第5步，由于 j 遇到了应该被放在左侧数组的元素，所以进行一次交换。最后，将 pivot 交换到合适位置。

数组划分的另一种实现，使用分别向左和向右的两个指针，交替进行扫描。取第一个元素为 pivot ，开始从右向左扫描。当遇到小于 pivot ，应该放在左侧的元素时，将其放在之前取 pivot 留下的空位，即左指针指向的位置。相应的，此时右侧指针指向的位置即为空位。并开始从左向右扫描，交替进行，直到两个指针重合（此时应同时指向空位），将 pivot 放置在空位上。过程如下：

|   |   |   |   |   | l | r |
|---+---+---+---+---+---+---|
| 2 | 8 | 7 | 1 | 4 | 0 | 4 |
| - | 8 | 7 | 1 | 4 | 0 | 4 |
| - | 8 | 7 | 1 | 4 | 0 | 3 |
| 1 | 8 | 7 | - | 4 | 1 | 3 |
| 1 | - | 7 | 8 | 4 | 1 | 2 |
| 1 | 2 | 7 | 8 | 4 | 1 | 1 |

这种情况下，两个指针时刻有一个执行扫描任务，一个指向空位，预备交换。

** 性能分析

最坏情况下，对于每次划分，都把数组划分为一个单独的元素与一个长度为 \(n-1\) 的数组。或者说，分解成一个长度为 0 的数组和另一个数组。此时，可以用递归式：

\[T(n)=T(n-1)+T(0)+\Theta(n)=T(n-1)+\Theta(n)=\Theta(n^2)\]

来表示算法的代价。

最好情况下，所有的划分都是平均的。此时，代价的递归式为：

\[T(n)=2T(\frac n2)+\Theta(n)=\Theta(n\log_2n)\]

可以证明，任何一种*常数*比例的划分，即使相当不均衡，都会得到 \(\Theta(n\log_2n)\) 的结果。

除此之外，我们还可以在划分中取随机的 pivot ，并经过一次交换后再开始正常的流程。通过这种方式，可以在算法中引入随机性，避免最差情况的出现。

** 快速排序的概率分析

快速排序的运行时间取决于划分过程中进行比较的次数。定义一个随机指示器变量 \(X_{ij}=\mathrm I\{\text{compare $z_i$ with $z_j$}\}\)，那么总的比较次数的期望为：

\[\mathrm E(X)=\mathrm E[\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}X_{ij}]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\mathrm E[X_{ij}]=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\Pr\{\text{compare $z_i$ with $z_j$}\}\]

考虑划分过程中的情况：所有元素都要与主元比较，且划分得到的两个数组之间不会发生比较。于是：

\[\Pr\{\text{compare $z_i$ with $z_j$}\}=\Pr\{\text{$z_i$ is first pivot of set $Z_{ij}$}\}\\+\Pr\{\text{$z_j$ if first pivot of set $Z_{ij}$}\}=\frac 2{j-i+1}\]

代入得到：

\[\mathrm E(X)=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac 2{j-i+1}=\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac2{k+1}<\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\frac2k=O(n\log_2n)\]

* 扩展

快速排序和堆排序是两种效率很高且十分常见的排序算法。然而，能够一次将其写成代码而不出错的人其实并不多，因为这两种算法分别涉及到不同的其他关键要素。快排的核心是 partition 函数。除了随机选取 pivot 避免恶意攻击带来的糟糕情形，一种比较好的方式是随机取三个数，并以其中位数为 pivot。
