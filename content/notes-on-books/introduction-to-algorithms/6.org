#+TITLE: 6. B-Tree, vEB-Tree, Set
#+MATH: true

* B 树

B 树的基本思想是这样的：设想一个树，每个节点都被储存在磁盘里，我们每次取出一个结点，这是很自然的。在进入下一层时，需要访问一个新的结点，这常常意味着新的磁盘访问。相应地，在节点内部进行的比较操作，也就是寻找前进方向的操作，只需要在主存里进行。

显然，主存中的操作的时间代价要低得多。所以，我们让每个节点持有众多的关键字和众多的结点，从而尽量降低树的高度。这意味着，相比于二叉树，使用 B 树将会带来更多的比较操作和更少的磁盘访问。因此，这种数据结构适合大块的数据访问。典型的例子如 BtrFS。

和其他各种树一样，B 树上操作的时间复杂度同样为 \(O(\log_tn)\)，只是这里的 \(t\) 比二叉树中的 2 通常要大得多。

** B 树的操作

B 树的基本操作在之前的 2-3 树已经介绍过。在插入关键字时，如果结点的大小超过了限制，就 “挤出” 一个最中间的关键字给父节点，并分裂当前结点。由于被挤出的是中间关键字，分类得到的两个新节点的长度应该相近。随后我们需要递归地对父节点进行判断，直到根节点分裂，这是 B 树高度增长的唯一方式。

在回顾了分裂结点的操作后，我们就可以理解 B 树定义中 \(t\) 的意义：每个节点内关键字的数量在 \(t\) 和 \(2t\) 之间，这分别是刚刚分裂过的结点和即将要分裂的结点。

[[https://www.cs.usfca.edu/~galles/visualization/BTree.html][这里]]有一个不错的 B 树操作的可视化演示。

** B+ 树

B+ 树是 B 树的一个变种，其所有的关键字都储存在叶子节点当中。由于 B 树中所有的结点高度相同，其查找的时间复杂度非常稳定。 B+ 树可以接受重复关键字，将实际数据存储在叶子节点中，内部结点只用来指示存储位置即可。

* 斐波那契堆

** 可合并堆

一个可合并堆应当支持以下的操作：

- 创建空堆，插入关键字，取得最小值，删除最小值，合并两个堆

除此之外，斐波那契堆还可以支持减小已有元素的关键字和删除关键字的操作。

之前出现过的二叉堆在前四个操作上效果都不错，时间代价为 \(O(\log_2n)\)。然而，在合并堆的操作上，二叉堆的速度非常慢。可以这样实现：将两个堆直接合并起来，再执行建堆操作。这样，复杂度会达到 \(\Theta(n)\)。斐波那契堆通常相比二叉堆具有更好的摊还代价。

| *堆*     | *新建*        | *插入*              | *取堆顶*      | *删除堆顶*          | *合并堆*      | *减小*              | *删除*              |
|----------+---------------+---------------------+---------------+---------------------+---------------+---------------------+---------------------|
| 二叉     | \(\Theta(1)\) | \(\Theta(\log_2n)\) | \(\Theta(1)\) | \(\Theta(\log_2n)\) | \(\Theta(n)\) | \(\Theta(\log_2n)\) | \(\Theta(\log_2n)\) |
| 斐波那契 | \(\Theta(1)\) | \(\Theta(1)\)       | \(\Theta(1)\) | \(\Theta(n)\)       | \(\Theta(1)\) | \(\Theta(1)\)       | \(\Theta(n)\)       |

不过，实际情况下，斐波那契堆的常数代价比较高，编程实现也比较困难。因此，并不十分常用。

** 斐波那契堆

一个斐波那契堆是一个森林，其中的每一棵树都符合最小堆性质，即，任何子节点的 key 大于其父节点。所有的根，即每一个结点的所有子节点，都被链接成一个环形双向链表。这样做的目的是，可以非常快速地向链表中插入一个新的节点，或者合并两个链表（在堆的合并操作中）。同一个链表中所有元素的顺序是任意的。

每个结点有两个额外的属性：子节点的数目 \(degree\)，和标记其自改变了父节点以来，是否失去过孩子的布尔值 \(mark\)。也就是说，新插入的结点和改变了父节点的结点的 \(mark\) 都是 \(False\)。堆的入口是一个指向 key 最小的根节点的指针 \(H.min\)。除此之外，堆还有一个属性 \(H.n\) 用来指示整个堆中的结点数。以 \(t(H)\) 为树的数目，\(m(H)\) 为已标记的结点数目，那么势函数：

\[\Phi(H)=t(H)+2m(H)\]

另外，斐波那契堆中结点的度数，即子节点数将会得到限制。当支持堆合并操作时，最大度数 \(D(n)\leqslant\lfloor\log_2n\rfloor\)，当支持后两个操作时，会使得
\(D(n)=O(\log_2n)\)。

** 斐波那契堆的操作

斐波那契堆的核心思想是尽量推后操作。所有的数据结构整理操作都被放在取出最小值的过程中。

- 合并两个堆时，直接根链表连接起来中，并依需更新 \(H.min\) 和 \(H.n\) 即可。

- 插入一个新的元素时，实际上和把当前堆与一个大小为 1 的堆合并是一样的。

- 取得最小节点时，直接取 \(H.min\) 即可。

- 抽取最小节点时，首先将 \(H.min\) 指向的结点的所有子节点修改到根链表中。判断堆是否变成了空堆，随后，遍历所有根结点，把相同度数的根节点合并起来。操作结束后的根链表中所有结点的度都不相同。

  这个过程可以使用一个数组，数组的下标代表结点的度数。当出现冲突时，说明需要进行合并操作。合并时，直接把根节点较大的那个树变成另一棵树的子树即可。

** 斐波那契堆的其他操作

在*降低*一个节点的 key 值时，如果其父节点的 \(mark\) 为 \(False\)，可以直接将其切断变成一个根节点。这样，所有的性质都不被破坏。此时，依据上面所说，将其父节点的 \(mark\) 标记为 \(True\) 。

当下一次要再次降低这个父节点的另一个儿子时，其父节点的 \(mark\) 就是 \(True\)，需要进行一次级联切断，将其父节点也切断变成根节点，并一直向上递归判断 \(mark\) 的值。

在*删除*一个结点时，相当于把这个节点的 key 降为最小，进行降低 key 值操作后，再执行取出最小值的操作。

* vEB 树

** 叠加二叉树结构

如图，使用一个二叉树作为索引，指示下面数组的对应位置是否存在元素。

#+caption: 二叉树结构
[[../chap20_1.png]]

类似地，可以将其扩展，增加结点的大小：

#+caption: 扩展的树索引
[[../chap20_2.png]]

** vEB 树

vEB 树可以认为是从带树索引的数组演化而来。其空间占用与 key 的取值范围 \(u\) 有关。使用多层的树，树的每个节点都是另外一个 vEB 树，其取值范围是父节点所在树的二次方。自顶向下直到取值范围达到 2，成为叶子节点。

对于每一个结点，其数据结构包括其取值范围 \(u\) ，极值 \(min\) 和 \(max\)，一个指向 \(vEB(\sqrt u)\) 的指针 \(summary\) ，以及一个长为 \(\sqrt u\) 的数组，其中每个位置是一个指向 \(vEB(\sqrt u)\) 的指针，即下一层 vEB 树。

\(summary\) 的作用是上一节中每一层的 0-1 数组的作用。因为其大小同样为 \(\sqrt u\) ，所以同样使用 vEB 树来储存。在访问时，需要先在 \(summary\) 中寻找对应的值，再去 \(cluster\) 中寻找数据。

#+caption: 二叉树结构
[[../chap20_3.png]]

实际情况中，\(\sqrt u\) 不一定是整数。因此，使用 \(\sqrt[\uparrow]u>\sqrt u>\sqrt[\downarrow]u\)，使得\(\sqrt[\uparrow]u\cdot\sqrt[\downarrow]u=u\)。那么，\(summary\) 指向一棵 \(vEB(\sqrt[\uparrow]u)\)，\(cluster\) 数组中的每一个指针指向 \(vEB(\sqrt[\downarrow]u)\)。

** vEB 树的查找

#+begin_example
vEB_FIND(V, x)
if x == min or x == max
    return TRUE
else if u == 2
    return FALSE
else return vEB_FIND(V.cluster[high(x)], x)
#+end_example

查找最大值和最小值相当于把上面的流程简化。

* 用于处理不相交集合的数据结构

** 不相交集合的操作

- MAKE_SET：新建一个仅包含参数的集合
- UNION：取两个集合的并集
- FIND_SET：寻找包含参数的集合

不相交集合的一个应用是处理无向图的连通分量。在寻找连通分量的过程中将会需要大量的不相交集合操作。

** 不相交集合的链表表示

使用一个链表来表示一个不相交集合，集合对象保留 \(head\) 和 \(tail\) 属性，每个元素对象保留指向集合的指针。这样，在寻找元素所在的集合时，就可以直接用指针返回集合。合并两个集合的链表非常容易，但合并时还需要修改其中一个集合的所有指向集合的指针。于是，最终操作的摊还代价达到了 \(\Theta(n)\)。

** 不相交集合森林

使用一棵树来表示一个集合。这样，FIND_SET 操作就变成了一直追随父节点直到树的根。UNION 操作只需要把一棵树变成另一棵的子树，即将其根节点指向另一棵树的根节点即可。

显然，无论链表还是森林，使较小或较矮的集合合并到较大的集合里都是提高效率的方法。此外，对于森林表示，还可以使用*路径压缩*的方式，这种方式的 FIND_SET 这样实现：

#+begin_example
FIND_SET(x)
if x != x.p
    x.p = FIND_SET(x.p)
return x.p
#+end_example

这样，整个函数经过的路径上所有的结点都变成了直接指向根节点的结点。于是在未来的查询中，效率就能得到提升。
