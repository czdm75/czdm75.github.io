#+TITLE: 7. Graph, Stream
#+MATH: true

* 图的表示与基本算法

- \(G(V,E)\) 其中 \(G\) 为 Graph 图，\(V\) 为 Verticle 结点，\(E\) 为 Edge 边。
- 邻接链表
- 邻接矩阵

** BFS 广度优先遍历（队列）

在 BFS 中，把未发现的结点和边标记为白色，发现但未完成的为灰色，已完成的为黑色。在 BFS 中，不需要对灰色和黑色进行区分。这个颜色用法也适用于 DFS 的结点。边只分为黑白两种。

BFS 可以发现两个结点间的最短路径。

** DFS 深度优先遍历（栈）

让 DFS 中一个节点的*发现时间*和*完成时间*分别为 \(u.d\) 和 \(u.f\)。那么，对于任意两个节点，它们的 \([d,f]\) 时间区间要么完全分离，要么互相包含。被包含的在 DFS 树中是另一个节点的后代。

结点 \(v\) 是 \(u\) 的后代，当且仅当发现 \(u\) 时，存在一条白色（完全未发现的）路径连接二者。

在 DFS 中将边分类。DFS 树中的称为树边，从一个节点连接到其祖先的为后向边，连接到其子孙的为前向边，其余的为横向边。于是，当且仅当图中无后向边，有向图无环。

当第一次查看边 \((u,v)\) 时，若 \(v\) 为白色，说明这是一条树边。若为灰色，说明是一条后向边（栈中的都是当前结点的祖先）。若为黑色，是前向或横向边（结点已经被访问过）

** 拓扑排序

拓扑排序可以看做把图排列成一条直线，让所有的边都指向同一个方向。显然，有环图不能被线性排序。拓扑排序可以这样被简单实现：在 DFS 中，每完成一个结点，就将其排列到直线的最前面第一个位置。

** 强连通分量

强连通分量是指任何两个节点都能从正逆两个方向连通的一个分量。可以由 DFS 获得。在下面的算法中，我们以这样一个图为例：

#+caption: 一个图的例子
[[/img/201802/introduction_algorithm_chap22_diagram.png]]

*** Kosaraju 算法

首先得到 DFS 树，然后将所有边的方向反转，在考虑完成时间 \(u.f\) 顺序的前提下，再进行一次 DFS 。最后完成的结点将被作为 DFS 的最先结点。这一次 DFS 得到的每一个树，就是一个强连通分量。其复杂度为 \(O(V+E)\)。不过，由于其需要两次 DFS ，常数项相对下面的方法较大。

以上面的图为例。在从 0 开始的 DFS 中，得到的完成时间序列从晚到早将会是：0,1,2,3,4,5。在如下的反向图中，以同样的顺序进行 DFS ，将会首先得到 0,1,2 这棵树。然后，开启第二次 DFS ，从 序列中下一个结点：3 开始，得到另一个强连通分量。

#+caption: 反向图
[[/img/201802/introduction_algorithm_chap22_diagram_reverse.png]]

*** Tarjan 算法

这个算法只需要一次 DFS。对于每个节点，我们需要记录其发现时间 \(u.d​\) 和从其出发能够到达所有结点中 \(d​\) 的最小值 \(lowlink​\)，这个值将会在结点完成时确定下来。显然，\(lowlink \leqslant d​\)。当从结点出发无法到达其他的结点时，二者相等，这个结点在这个算法中称为强连通分量的根。

每当一个节点完成时，检查其是否是一个强连通分量的根。如果是，那么在其之前完成的尚未被划分入一个强连通分量的结点构成一个强连通分量。

在上图的例子中，第一轮从 0 开始的 DFS 中 \(u.d\) 的顺序将会是：0,1,2,3,4,5 。而相应的 \(lowlink\) 的序列将会是：0,0,0,3,3,3 。由此得到两个根 0 和 3 ，两个强连通分量。

*** Gabow 算法

Gabow 算法与 Tarjan 算法的思想是相同的。区别是，Gabow 使用一个栈代替了 \(lowlink\) 属性。

* 最小生成树算法

最小生成树是指，对于一个无向有权连通图，寻找一棵生成树，使得所有边的权重相加最小。注意，图的最小生成树的边数是一定的，为 \(V-1\)。下面的两种常用算法都使用了贪心策略。

** Kruskal 算法

Kruskal 算法的核心是，不断寻找权最小的边，加入到生成树中。把每一个节点看成一棵树，并对所有的边进行排序。从权最小的边开始寻找，如果一条边能够将两棵树连接起来，就将其加入到树中。最终，所有的树都将连接起来变成一棵。可以看到，这里实际上利用了之前提到的不相交集合相关的算法。如果使用之前的路径压缩的森林实现，算法的复杂度为 \(O(E\log_2V)\)。

** Prim 算法

Prim 算法同样采取贪心策略，可以认为这个算法是在不断寻找权值最小的结点。以一个节点为起点构建一棵树。在其所有经过一条边能够抵达的结点中，选取需要的权最小的一个节点加入到树中。可以看到，这里适合使用之前的最小优先队列算法。事实上，算法的代价取决于最小优先队列。如果使用二叉最小优先队列，渐进代价将被控制在 \(O(E\log_2V)\)。

* 单源最短路径算法

BFS 就是一个可以寻找最短路径的算法，但它不能被应用于有权图。在这里，单源最短路径问题，指从一个节点出发求取其到所有节点距离的算法。其他类型的最短路径可以认为是这个算法的变体。下面的 Dijikstra 算法将是一个 贪心算法，而 Floyd 算法将是一个动态规划算法。

定义一个边的*松弛*（Relax）操作。也就是，判断这条边是否能够对最短路径带来一定优化。在以下的算法中，我们常常为每一个节点维护一个值 \(d\) 及其前驱 \(\pi\)，代表从这个节点到源的目前已知的最短路径的值，初始化为正无穷。那么，对于一条边，将一个节点的 \(d\) 与权相加，如果小于另一个节点的值，就进行替换。

对于任何一个结点，其最短路径的前驱子图上所有的结点都取到了最短路径。

** Bellman-Ford 算法

Bellman-Ford 算法可以接受负权重的图。不过，如果图中存在一个从源节点可以抵达的负权重的环，最短路径就无法被定义。显然，再次经过这个环就能得到一个权重更小的路径。因此，Bellman-Ford 算法在遇到这种情况时将会返回 False。算法相当简单：两层嵌套的循环去松弛每一条边。

#+begin_example
for i=1 to V-1
    for each egde
        relax(edge)
for each edge
    if can relax
        return FALSE
return TRUE
#+end_example

** 有向无环图中的单源最短路径

在有向无环图中，由于不存在环路，无论权重是正或负都可以找到最短路径。由于有向无环图可以进行拓扑排序，得到的图中所有的边都沿同一方向，于是直接按照这个方向去松弛每一条边即可。

** Dijikstra 算法

Dijikstra 算法要求所有边权重非负。算法在运行过程中维持一个集合 \(S\)，这个集合内所有的结点都已经找到了最短路径。算法重复地从集合 \(V-S\) 中选择最短路径估计最小的结点合并到 \(S\) 内，并松弛所有从这个节点发出的边。

算法的总运行时间依赖于最小优先队列的实现。如果使用二叉堆来构建，则可以控制在 \(O((V+E)\log_2V)\)。如果使用线性数组来构建优先队列，则为 \(O(VE)\)。

** 差分约束和最短路径

线性规划问题是，在满足一组线性不等式的条件下优化一个线性函数。这里我们先讨论一个特例，这个特例可以被规约到单源最短路径问题，以期用 Bellman-Ford 算法来解决。

*** 线性规划问题

在通用的线性规划问题是：给定一个 \(m\times n\) 的矩阵 \(A\)，一个 \(m\) 维向量 \(b\)，一个 \(n\) 维向量 \(c\)。那么，\(Ax\leqslant b\) 就是一组不等式。我们的目的是，在满足这一组不等式，即约束条件的前提下，优化目标函数 \(\sum_{i=1}^nc_ix_i\) 的值，使其取得最大。很多时候，我们只是希望寻找是否存在这样一个 \(x\) 成为可行解。

*** 差分约束系统

差分约束问题是线性规划的一个特例。矩阵 \(A\) 的内容只包括 0、1 和 -1，于是问题变成了一组形如 \(x_j-x_i\leqslant b_k\) 的不等式。例如，寻找以下的向量 \(x=(x_i)\)：

\[\begin{bmatrix}1&-1&0\\ 1&0&-1\end{bmatrix} \begin{bmatrix}x_1\\ x_2\\ x_3\end{bmatrix} \leqslant \begin{bmatrix}0\\ -1\end{bmatrix}\]

相当于寻找三个变量，使得：

\[x_1-x_2\leqslant0\\ x_1-x_3\leqslant-1\]

*** 约束图

可以从图论的观点来理解差分约束系统。将矩阵 \(A^\mathrm{T}\) 看做一个由 \(n\) 个结点和 \(m\) 条边组成的图的邻接矩阵。那么，图中的每一个节点对应目标向量 \(x\) 中的一个维度 \(x_i\)。每条有向边对应一个不等式。这时，寻找一个最短路径就是寻找一个解。目标向量 \(x\) 的每一个维度就是从起点到每一个结点的最短路径长度。即：

\[x=(\delta(v_0,v_1),\delta(v_0,v_2),\delta(v_0,v_3),\cdots,\delta(v_0,v_n))\]

显然。作为一个允许存在负权重的图，如果存在负权重环路，则问题无解。使用 Bellman-Ford 算法可以把代价控制在 \(O(n^2+nm)\)。如果进一步优化算法，则可以达到 \(O(nm)\)。

** 扩展

Karp 最小平均权重路径算法

* 所有节点间的最短路径问题

显然，可以通过 \(|V|\) 次单源最短路径算法来解决这个问题。如果使用 Dijkstra 算法，在线性数组作为优先队列的情况下，复杂度为 \(O(V^3)\)。使用二叉堆时，将控制在 \(O(VE\log_2V)\)。当图中有负权时，使用 Bellman-Ford 算法将会使复杂度来到 \(O(V^2E)\)。在图非常稠密的情况下，这个值将会逼近 \(O(V^4)\)。

在接下来的算法中，我们将会更多地使用邻接矩阵，这种形式更适合这类问题的解决。算法的输出将同样是一个 \(n\) 阶矩阵，内容为两个结点之间的最短路径长度。为了得到最短路径本身，还需要一个同样为 \(n\) 阶的前驱结点矩阵。这样，通过不断地查询前驱结点矩阵，就可以得到任何两个节点之间的完整路径。（因为最短路径去掉最后一个节点，即前驱结点后，仍然是一个最短路径。）

** 基于矩阵乘法动态规划的算法

*** 递归解决最短路径问题

我们知道，一条最短路径的一部分必然也是一条最短路径。我们规定 \(l^{(m)}_{ij}\) 为从 \(i\) 到 \(j\) 所有包含边数不大于 \(m\) 的路径中最小的权重。显然，当两个节点在 \(m\) 条边内不可达时，\(l^{(m)}_{ij}\) 为 \(\infty\)。当两个节点重合时，该值为 0 。设 \(k\) 是 \(j\) 可能的前驱结点。那么：

\[{l^{(m)}_{ij}}=\min_{1\leqslant k\leqslant n}\{l^{(m-1)}_{ik}+w_{kj}\}\]

其中 \(w_{kj}\) 是结点 \(k\) 和 \(j\) 之间边的权重。又因为，简单路径的长度不可能大于结点数，所以实际的最短路径权重 \(\delta(i,j)=l^{(n-1)}_{ij}\)。

*** 自底向上计算最短路径权重

现在我们可以将所有的 \(l^{(m)}_{ij}\) 组成一个矩阵 \(L^{(m)}\)。那么，我们就可以从 \(L^{(1)}\) 开始，利用上面的公式，求取下一个矩阵，直到 \(L^{(n-1)}\)，就是我们需要的最短路径权重矩阵。

这个算法和矩阵乘法的形式十分类似，只是把求和工作变成求最小值工作。这样我们就可以定义这样一种新的 “矩阵乘法”，那么 \(L^{(m)}=L^{(m-1)}\cdot W=W^m\)，其中 \(W\) 为邻接矩阵。显然，每次 “矩阵乘法” 的复杂度为 \(\Theta(n^3)\)，总的算法复杂度为 \(\Theta(n^4)\)。

*** 使用重复平方技术改进算法

然而，我们并不关心其他的矩阵，只需要 \(L^{(n-1)}\)。因此，我们可以将上面逐个求取 \(L^{(m)}\) 的过程进行修改。首先，我们知道，对于任意 \(m\geqslant n-1\)，\(L^{(m)}=L^{(n-1)}\)。然后，我们使用 \(L^{(2m)}=(L^{(m)})^2\) 来求取更靠后的矩阵。每次矩阵乘法的复杂度仍然为 \(\Theta(n^3)\)，总的算法复杂度被控制在了 \(\Theta(n^3\log_2n)\)。

** Floyd-Warshall 算法

*** 递归求解的方法

也称 Floyd 算法。算法的核心是，维护一个结点的集合，及其所有节点之间，仅在集合内部的最短路径。不断将新的结点加入到这个集合里，并检查这个边是否对节点之间的最短路径发生了改变。令 \(d^{(k)}_{ij}\) 为所有位于节点集合 \(\{1,2,\cdots,k\}\) 内部的从 \(i\) 到 \(j\) 的最短路径的权重。那么就可以使用递归式来求解其值：

\[d^{(k)}_{ij}=\begin{cases} w_{ij}&\text{if }k=0\\ \min(d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj})&\text{if }k\geqslant 1 \end{cases}\]

于是，矩阵 \(D^{(n)}=(d^{(n)}_{ij})\) 给出的就是我们的最后答案。

*** 自底向上实现算法

当 \(k=0\) 时，最短路径权重矩阵 \(D^{(0)}\) 既是所有直接相连结点之间的关系。然后，逐渐加入结点到集合内，即增大 \(k\) 的值。每加入一个节点，就调用 \(d^{(k)}_{ij}=\min(d^{(k-1)}_{ij},d^{(k-1)}_{ik}+d^{(k-1)}_{kj})\)，更新所有节点之间的路径关系。即三层 for 循环的嵌套。因此，算法的复杂度为 \(\Theta(n^3)\)。

*** 有向图的传递闭包

给定一个有向图 \(G=(V,E)\)，我们希望知道任意两个结点是否可达。定义图 \(G\) 的传递闭包为 \(G^\*=(V,E^\*)\)，其中若结点 \(i\)、\(j\) 可达，则 \((i,j)\in E^\*\)，即所有可达关系的集合。

一种有效的方法是为所有边赋权重 1 ，再运行 Floyd 算法，以得到所有可达的路径。另一种效率更高的方法是，以逻辑*或操作*和*与操作*来代替 Floyd 算法中的 min 和 +。这样，可以将整数型的存储空间减少到布尔型的，同时也能够带来更快的速度。

** Johnson 算法

Johnson 算法适用于在稀疏图中寻找最短路径，复杂度为 \(O(V^2\log_2V+VE)\) ，或者通常情况使用二叉堆时的 \(O(VE\log_2V))\)。当 \(E\) 较小时，其时间代价低于上面两种算法。Johnson 算法的基本思想是*重新赋予权重*。

首先，对于非负权重的图，我们可以对每个节点使用 Dijkstra 算法来寻找单源最短路径，如果使用斐波那契堆，其复杂度为 \(O(V^2\log_2V+VE)\)。如果图中包含负权重但没有负权重的环，则只要计算出一组新的非负权重进行替换，再使用 Dijkstra 算法即可。我们将在这个过程耗费 \(O(VE)\) 的时间。

*** 重新赋予权重的方法

显然，赋予权重不能改变最短路径。权重函数如下定义：

\[\hat w(p)=w(p)+h(v_0)-h(v_k)\]

可以做如下的证明：

\[\hat w(p)=\sum^k_{i=1}\hat w(v_{i-1},v_i)=\sum^k_{i=1}(w(v_{i-1},v_i)+h(v_{i-1})-h(v_i)) \\ =\sum^k_{i-1}w(v_{i-1},v_i)+h(v_0)-h(v_k)=w(p)+h(v_0)-h(v_k)\]

又因为 \(h(v)\) 不依赖于当前的具体路径，对于更大的 \(w(v_1,v_2)\)，必然有更大的 \(\hat w(v_1,v_2)\)。而且，如果原图中有一个权重为负的环路，在新图中同样会是一个负权重的环路。

接下来，我们需要让 \(\hat w\) 取得非负值。首先，我们为一个新图 \(G'=(V',E')\) 增加一个结点，并让其具备指向每一个结点的边，权重为 0。

然后，我们定义 \(h(v)=\delta(s,v)\)。这样，对于所有与 \(s\) 间以负权重相连的结点，其 \(h\) 都将是负值，而以正权重路径相连的结点的 \(h\) 将会是 0 。这样，我们就得到了新的权重函数。 这个过程可以使用 Bellman-Ford 算法来实现，既能够发现负权重环又能够求得 \(h(v)\)。


* 最大流算法

** 流网络

*** 流网络的形式

流网络可以被概括成这样一个有向图：图中包括一个源点和一个汇点，二者的速率相等。每条边都有一个固定的最大流量。物料在结点上不能储存，即每个节点的入量与出量应当相等。这条流量守恒性质与基尔霍夫电流定律等价。图中不能存在两个节点之间往返的两条边（反平行边）。

形式上，我们使用一个有向图 \(G=(V,E)\)，每条边有一个非负的最大流量值 \(c(u,v)\)，及其实际流量 \(f(u,v)\)。为方便起见，把所有不存在的边的流量设置为 0 ，并假设所有节点都在源点 \(s\) 与汇点 \(t\) 的一条路径上。这样，流网络一定是连通的，并且除了 \(s\) 之外，每个节点都有入边。因此，\(|E|\geqslant|V|-1\)。我们将其特性总结为两个显而易见的性质：\(0\leqslant f(u,v)\leqslant c(u,v)\)，以及任何一个节点的出流量和入流量相等。

*** 使用反平行边来模拟问题

我们的算法中通常不允许反平行边的出现。当遇到这种问题时，可以通过加入一个节点来规避这种情况。如，对于 \(u\to v\to u\)，可以转化为 \(u\to e\to v\to u\)。

*** 具有多个源点和汇点的问题

解决这个问题的方法实际相当简单。加入新的超级源点和超级汇点，并将所有的源点和汇点变成与它们直接连接的结点即可。显然，这些新加入的边的容量应当为 \(\infty\)。这样才能使得新的图与旧的图性质相同。

** Ford-Fulkerson 方法

*** 残存网络

已知一个流网络 \(G(V,E)\) 及其中的一个流 \(f\)，定义*残存网络*的容量 \(c_f(u,v)\)，则：

\[c_f(u,v)=\begin{cases}
c(u,v)-f(u,v)&\text{if }(u,v)\in E\\
f(v,u)&\text{if }(v,u)\in E\\
0&\text{otherwise}
\end{cases}\]

残存网络的容量相当于这个流在这个流网络中还能变动的空间，其形式与流网络类似，只是允许反平行边的存在。如果 \(f'\) 是残存网络中的一个流，那么定义流 \(f'\) 对流 \(f\) 的*递增*（augmentation）：

\[f\uparrow f'=\begin{cases}
f(u,v)+f'(u,v)-f'(v,u)&\text{if }(u,v)\in E\\
0&\text{otherwise}
\end{cases}\]

相当于在叠加了这两个流之后得到的新流。

*** 增广路径

增广路径是残存网络中的一条从 \(s\) 到 \(t\) 的简单路径。定义这条路径 \(p\) 的*残存容量* \(c_f(p)=\min\{c_f(u,v):(u,v)\text{belongs to path }p\}\)。

那么，我们就可以在原来的流基础上，将这条增广路径上的所有边的流量均增加 \(c_f(p)\)，而不会破坏流网络的性质。此外，由于增广路径有可能经过与原网络中的边相反的边，这时原图中的流的某些边的流量就会减小。

可以证明，新的到的流比原来的流更加接近最大流。而且，当且仅当残存网络中不再存在增广路径时，得到的流是最大流。这就是 Ford-Fulkerson 方法的核心思想。

*** Ford-Fulkerson 算法的实现

在算法的每次迭代中，寻找一条增广路径，并将其应用到流上，以 \(f\uparrow f_p\) 来代替 \(f\)，直到不存在增广路径为止。

算法的时间代价取决于寻找增广路径的方法。不过，当边的容量为无理数时，寻找增广路径的过程有可能无法终止。实际情况中我们处理的大多是整数容量，如果遇到有理数容量，则可以将其乘一个系数。

我们以整数容量的情况为例。如果使用 DFS 或 BFS 来寻找路径，那么找到一条路径的时间为 \(O(V+E')=O(E)\)。每一次使用增广路径都对流的容量带来一次增加，所以整个算法的运行时间为 \(O(E|f^\*|)\)，其中 \(|f^\*|\) 为最大流的容量。

使用 BFS 作为路径算法的 Ford-Fulkerson 方法称为 Edmonds-Karp 算法。由于使用 BFS，每次找到的增广路径都必定是一个最短路径。整个算法的复杂度为 \(O(VE^2)\)。

** 最大二分分配

最大二分分配问题是指，给定一个二分图（由两组结点组成的图，边只存在两种结点之间，而不存在于同种结点之间），求一组边，实现最大匹配。即，一个所有边组成的集合的子集，这个子集的元素数量最多。

这个问题相当于一个多源点多汇点的最大流问题，每条边的容量都被设定为 1。随后，应用 Ford-Fulkerson 方法即可。
