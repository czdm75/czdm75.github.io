<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java NIO: 应用 #  基本概念 #  Java NIO 是一种非阻塞的、面向块而非字节的 IO 方式。虽然 Java 的传统 IO 也进行了一些基于 NIO 的改造，NIO 仍然能够带来许多优势。
面向流的 IO 方便我们一个字节一个字节地处理数据，有利于实现过滤等功能，更加优雅和简单。相应地，其速度通常比较慢。
Java NIO 的模型由三部分组成。
 Channel 通道，类似于传统 IO 中的流，用来实际传输数据。 Buffer 缓冲，我们用来读取和发送数据的位置。 Selector 选择器，可以在一个线程上绑定多个 Channel 和对应的 Buffer。  Channel #  Channel 和流非常相似。区别是，通道支持异步读写，支持双向读写，而且基于缓冲区。相比之下，流通常是单向同步读写的。
常用的 Channel 主要包括：
 FileChannel 文件 DatagramChannel UDP数据报 SocketChannel TCP 套接字 ServerSocketChannel TCP 服务端套接字  Buffer #  Java 中的各种基本类型都有其对应的 Buffer，最常用的是 ByteBuffer。可以通过 Channel 或者手动写入数据。
ByteBuffer buffer = ByteBuffer."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Java NIO Usage"><meta property="og:description" content="Java NIO: 应用 #  基本概念 #  Java NIO 是一种非阻塞的、面向块而非字节的 IO 方式。虽然 Java 的传统 IO 也进行了一些基于 NIO 的改造，NIO 仍然能够带来许多优势。
面向流的 IO 方便我们一个字节一个字节地处理数据，有利于实现过滤等功能，更加优雅和简单。相应地，其速度通常比较慢。
Java NIO 的模型由三部分组成。
 Channel 通道，类似于传统 IO 中的流，用来实际传输数据。 Buffer 缓冲，我们用来读取和发送数据的位置。 Selector 选择器，可以在一个线程上绑定多个 Channel 和对应的 Buffer。  Channel #  Channel 和流非常相似。区别是，通道支持异步读写，支持双向读写，而且基于缓冲区。相比之下，流通常是单向同步读写的。
常用的 Channel 主要包括：
 FileChannel 文件 DatagramChannel UDP数据报 SocketChannel TCP 套接字 ServerSocketChannel TCP 服务端套接字  Buffer #  Java 中的各种基本类型都有其对应的 Buffer，最常用的是 ByteBuffer。可以通过 Channel 或者手动写入数据。
ByteBuffer buffer = ByteBuffer."><meta property="og:type" content="article"><meta property="og:url" content="/pl/java-nio-1/"><meta property="article:section" content="pl"><title>Java NIO Usage | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle checked>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/ class=active>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Java NIO Usage</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-nio-应用>Java NIO: 应用</a><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#channel>Channel</a></li><li><a href=#buffer>Buffer</a></li><li><a href=#scatter--gather>Scatter / Gather</a></li></ul></li><li><a href=#网络和异步-io>网络和异步 IO</a><ul><li><a href=#tcp-异步-io-的例子>TCP 异步 IO 的例子</a></li><li><a href=#selectionkey>SelectionKey</a></li><li><a href=#selector>Selector</a></li></ul></li><li><a href=#异步-io-设计>异步 IO 设计</a><ul><li><a href=#概述>概述</a></li><li><a href=#message-reader-的实现>Message Reader 的实现</a><ul><li><a href=#拷贝扩容>拷贝扩容</a></li><li><a href=#追加扩容>追加扩容</a></li><li><a href=#使用-tlv-消息>使用 TLV 消息</a></li></ul></li><li><a href=#写不完整的消息>写不完整的消息</a></li><li><a href=#集成>集成</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java-nio-应用>Java NIO: 应用
<a class=anchor href=#java-nio-%e5%ba%94%e7%94%a8>#</a></h1><h2 id=基本概念>基本概念
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><p>Java NIO 是一种非阻塞的、面向块而非字节的 IO 方式。虽然 Java 的传统 IO 也进行了一些基于 NIO 的改造，NIO 仍然能够带来许多优势。</p><p>面向流的 IO 方便我们一个字节一个字节地处理数据，有利于实现过滤等功能，更加优雅和简单。相应地，其速度通常比较慢。</p><p>Java NIO 的模型由三部分组成。</p><ul><li>Channel 通道，类似于传统 IO 中的流，用来实际传输数据。</li><li>Buffer 缓冲，我们用来读取和发送数据的位置。</li><li>Selector 选择器，可以在一个线程上绑定多个 Channel 和对应的 Buffer。</li></ul><h3 id=channel>Channel
<a class=anchor href=#channel>#</a></h3><p>Channel 和流非常相似。区别是，通道支持异步读写，支持双向读写，而且基于缓冲区。相比之下，流通常是单向同步读写的。</p><p>常用的 Channel 主要包括：</p><ul><li><code>FileChannel</code> 文件</li><li><code>DatagramChannel</code> UDP数据报</li><li><code>SocketChannel</code> TCP 套接字</li><li><code>ServerSocketChannel</code> TCP 服务端套接字</li></ul><h3 id=buffer>Buffer
<a class=anchor href=#buffer>#</a></h3><p>Java 中的各种基本类型都有其对应的 Buffer，最常用的是 <code>ByteBuffer</code>。可以通过 Channel 或者手动写入数据。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ByteBuffer buffer <span style=color:#666>=</span> ByteBuffer<span style=color:#666>.</span><span style=color:#7d9029>allocate</span><span style=color:#666>(</span>1024<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// through a channel
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>int</span> bytesRead <span style=color:#666>=</span> inChannel<span style=color:#666>.</span><span style=color:#7d9029>read</span><span style=color:#666>(</span>buf<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// manually input
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>buf<span style=color:#666>.</span><span style=color:#7d9029>put</span><span style=color:#666>((</span><span style=color:#b00040>byte</span><span style=color:#666>)</span>127<span style=color:#666>);</span>
</span></span></code></pre></div><p>然后，要从 buffer 中读取数据，需要首先 <code>flip()</code> 它，变成读取模式。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buf<span style=color:#666>.</span><span style=color:#7d9029>flip</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// write from buffer into channel.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>int</span> bytesWritten <span style=color:#666>=</span> inChannel<span style=color:#666>.</span><span style=color:#7d9029>write</span><span style=color:#666>(</span>buf<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// manually get
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>byte</span> aByte <span style=color:#666>=</span> buf<span style=color:#666>.</span><span style=color:#7d9029>get</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>需要注意的是，很多 Channel ,如 <code>FileChannel</code> 和非阻塞模式下的 <code>SocketChannel</code> 的 <code>write</code> 方法<strong>并不能</strong>保证将 buffer 全部写入文件。因此，要使用循环来处理：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>while</span><span style=color:#666>(</span>buf<span style=color:#666>.</span><span style=color:#7d9029>hasRemaining</span><span style=color:#666>())</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    channel<span style=color:#666>.</span><span style=color:#7d9029>write</span><span style=color:#666>(</span>buf<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>下面是一个简单的输出文件内容的示例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RandomAccessFile aFile <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> RandomAccessFile<span style=color:#666>(</span><span style=color:#ba2121>&#34;data/nio-data.txt&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;rw&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>FileChannel inChannel <span style=color:#666>=</span> aFile<span style=color:#666>.</span><span style=color:#7d9029>getChannel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>ByteBuffer buf <span style=color:#666>=</span> ByteBuffer<span style=color:#666>.</span><span style=color:#7d9029>allocate</span><span style=color:#666>(</span>48<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> bytesRead <span style=color:#666>=</span> inChannel<span style=color:#666>.</span><span style=color:#7d9029>read</span><span style=color:#666>(</span>buf<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>while</span> <span style=color:#666>(</span>bytesRead <span style=color:#666>!=</span> <span style=color:#666>-</span>1<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    buf<span style=color:#666>.</span><span style=color:#7d9029>flip</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span><span style=color:#666>(</span>buf<span style=color:#666>.</span><span style=color:#7d9029>hasRemaining</span><span style=color:#666>()){</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>print</span><span style=color:#666>((</span><span style=color:#b00040>char</span><span style=color:#666>)</span> buf<span style=color:#666>.</span><span style=color:#7d9029>get</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    buf<span style=color:#666>.</span><span style=color:#7d9029>clear</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    bytesRead <span style=color:#666>=</span> inChannel<span style=color:#666>.</span><span style=color:#7d9029>read</span><span style=color:#666>(</span>buf<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>aFile<span style=color:#666>.</span><span style=color:#7d9029>close</span><span style=color:#666>();</span>
</span></span></code></pre></div><p><code>InputStream</code> 和 <code>OutputStream</code> 类也有类似的 <code>getChannel</code> 方法。当然，这样开启的通道只能是单向的。下面是一个将输入内容传输到输出的可复用的代码片段：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>while</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>true</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    buffer<span style=color:#666>.</span><span style=color:#7d9029>clear</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> r <span style=color:#666>=</span> fcin<span style=color:#666>.</span><span style=color:#7d9029>read</span><span style=color:#666>(</span> buffer <span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>r<span style=color:#666>==-</span>1<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>break</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    buffer<span style=color:#666>.</span><span style=color:#7d9029>flip</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    fcout<span style=color:#666>.</span><span style=color:#7d9029>write</span><span style=color:#666>(</span> buffer <span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h3 id=scatter--gather>Scatter / Gather
<a class=anchor href=#scatter--gather>#</a></h3><p>Scatter 和 Gather 可以译为分散和聚集，指的是向同一个通道写入和读出多个 Buffer 的过程。在处理复杂结构的数据，如 Header-Content 时，有利于代码整洁。Scatter Read 指从一个 Channel 读取到多个 Buffer，Gather Write 指从多个 Buffer 写入到一个 Channel。关于网络的内容还会在后面进一步解释。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ServerSocketChannel ssc <span style=color:#666>=</span> ServerSocketChannel<span style=color:#666>.</span><span style=color:#7d9029>open</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>ssc<span style=color:#666>.</span><span style=color:#7d9029>socket</span><span style=color:#666>().</span><span style=color:#7d9029>bind</span><span style=color:#666>(</span> address <span style=color:#666>);</span>
</span></span><span style=display:flex><span>SocketChannel sc <span style=color:#666>=</span> ssc<span style=color:#666>.</span><span style=color:#7d9029>accept</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> messageLength <span style=color:#666>=</span> firstHeaderLength <span style=color:#666>+</span> secondHeaderLength <span style=color:#666>+</span> bodyLength<span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ByteBuffer buffers<span style=color:#666>[]</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> ByteBuffer<span style=color:#666>[</span>3<span style=color:#666>];</span>
</span></span><span style=display:flex><span>buffers<span style=color:#666>[</span>0<span style=color:#666>]</span> <span style=color:#666>=</span> ByteBuffer<span style=color:#666>.</span><span style=color:#7d9029>allocate</span><span style=color:#666>(</span> firstHeaderLength <span style=color:#666>);</span>
</span></span><span style=display:flex><span>buffers<span style=color:#666>[</span>1<span style=color:#666>]</span> <span style=color:#666>=</span> ByteBuffer<span style=color:#666>.</span><span style=color:#7d9029>allocate</span><span style=color:#666>(</span> secondHeaderLength <span style=color:#666>);</span>
</span></span><span style=display:flex><span>buffers<span style=color:#666>[</span>2<span style=color:#666>]</span> <span style=color:#666>=</span> ByteBuffer<span style=color:#666>.</span><span style=color:#7d9029>allocate</span><span style=color:#666>(</span> bodyLength <span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> bytesRead <span style=color:#666>=</span> 0<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>while</span> <span style=color:#666>(</span>bytesRead <span style=color:#666>&lt;</span> messageLength<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>long</span> r <span style=color:#666>=</span> sc<span style=color:#666>.</span><span style=color:#7d9029>read</span><span style=color:#666>(</span> buffers <span style=color:#666>);</span>
</span></span><span style=display:flex><span>    bytesRead <span style=color:#666>+=</span> r<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// flip all buffers
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#b00040>long</span> bytesWritten <span style=color:#666>=</span> 0<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>while</span> <span style=color:#666>(</span>bytesWritten<span style=color:#666>&lt;</span>messageLength<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>long</span> r <span style=color:#666>=</span> sc<span style=color:#666>.</span><span style=color:#7d9029>write</span><span style=color:#666>(</span> buffers <span style=color:#666>);</span>
</span></span><span style=display:flex><span>    bytesWritten <span style=color:#666>+=</span> r<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=网络和异步-io>网络和异步 IO
<a class=anchor href=#%e7%bd%91%e7%bb%9c%e5%92%8c%e5%bc%82%e6%ad%a5-io>#</a></h2><p>异步 IO 的模式实际上来自于操作系统，如 Linux 的 IO 复用和 Windows 的 IOCP。因此，类似的编程模式很可能也适用于其他语言。</p><h3 id=tcp-异步-io-的例子>TCP 异步 IO 的例子
<a class=anchor href=#tcp-%e5%bc%82%e6%ad%a5-io-%e7%9a%84%e4%be%8b%e5%ad%90>#</a></h3><p>异步 IO 不会阻塞，这也使得它可以处理许多的 IO 连接。在传统 IO 下，这通常需要通过轮询或多线程来实现。</p><p>首先回顾一下普通的 IO 编程中处理 TCP 连接的方法：<code>ServerSocket</code> 类监听端口，客户端的 <code>Socket</code> 类构造时发出连接请求。这时，<code>ServerSocket.accept()</code> 从阻塞中脱离，返回服务端的 <code>Socket</code> 对象。</p><p>然后，我们来看异步处理的方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span><span style=color:#666>[]</span> ports <span style=color:#666>=</span> <span style=color:#666>...;</span>
</span></span><span style=display:flex><span>Selector selector <span style=color:#666>=</span> Selector<span style=color:#666>.</span><span style=color:#7d9029>open</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span><span style=color:#b00040>int</span> i <span style=color:#666>:</span> ports<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// new channel
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    ServerSockertChannel channel <span style=color:#666>=</span> ServerSocketChannel<span style=color:#666>.</span><span style=color:#7d9029>open</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// config
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    channel<span style=color:#666>.</span><span style=color:#7d9029>configureBlocking</span><span style=color:#666>(</span><span style=color:green;font-weight:700>false</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    channel<span style=color:#666>.</span><span style=color:#7d9029>socket</span><span style=color:#666>().</span><span style=color:#7d9029>bind</span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> InetSocketAddress<span style=color:#666>(</span>i<span style=color:#666>));</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// register to selector
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    SelectionKey key <span style=color:#666>=</span> channel<span style=color:#666>.</span><span style=color:#7d9029>register</span><span style=color:#666>(</span>selector<span style=color:#666>,</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_ACCEPT</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这里的 <code>SelectionKey.OP_ACCEPT</code> 是适用于 <code>ServerSocketChannel</code> 的唯一事件，即 TCP 连接建立的事件。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span> num <span style=color:#666>=</span> selector<span style=color:#666>.</span><span style=color:#7d9029>select</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>Set<span style=color:#666>&lt;</span>SelectionKey<span style=color:#666>&gt;</span> keys <span style=color:#666>=</span> selector<span style=color:#666>.</span><span style=color:#7d9029>selectedKeys</span><span style=color:#666>()</span>
</span></span></code></pre></div><p><code>select()</code> 方法会阻塞直到有任何一个连接建立。<code>selectedKeys</code> 返回一个 <code>Set&lt;SelectionKey></code> 对象。在异步 IO 的类似处理过程中，由于我们已经通过 <code>select</code> 得到了这个连接信息，就不必再担心 <code>accept</code> 会阻塞：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>SelectKey key <span style=color:#666>:</span> keys<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> <span style=color:#666>((</span>key<span style=color:#666>.</span><span style=color:#7d9029>readyOps</span><span style=color:#666>()</span> <span style=color:#666>&amp;</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_ACCEPT</span><span style=color:#666>)</span> <span style=color:#666>==</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_ACCEPT</span><span style=color:#666>){</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>// Accept the new connection
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        <span style=color:#408080;font-style:italic>// accept() the new socket and register to selector
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        ServerSocketChannel channel <span style=color:#666>=</span> <span style=color:#666>(</span>ServerSocketChannel<span style=color:#666>)</span>key<span style=color:#666>.</span><span style=color:#7d9029>channel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        SocketChannel sc <span style=color:#666>=</span> ssc<span style=color:#666>.</span><span style=color:#7d9029>accept</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        sc<span style=color:#666>.</span><span style=color:#7d9029>configureBlocking</span><span style=color:#666>(</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>);</span>
</span></span><span style=display:flex><span>        SelectionKey newKey <span style=color:#666>=</span> sc<span style=color:#666>.</span><span style=color:#7d9029>register</span><span style=color:#666>(</span>selector<span style=color:#666>,</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_READ</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span> <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>((</span>key<span style=color:#666>.</span><span style=color:#7d9029>readyOps</span><span style=color:#666>()</span> <span style=color:#666>&amp;</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_READ</span><span style=color:#666>)</span> <span style=color:#666>==</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_READ</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>// Read the data from socket
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        SocketChannel sc <span style=color:#666>=</span> <span style=color:#666>(</span>SocketChannel<span style=color:#666>)</span>key<span style=color:#666>.</span><span style=color:#7d9029>channel</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>// use buffer to proccess
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    keys<span style=color:#666>.</span><span style=color:#7d9029>remove</span><span style=color:#666>(</span>key<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>可以看到，我们将 <code>accept</code> 得到的结果重新放回了 <code>selector</code> 的监听列表，并且将监听事件修改为了 <code>SelectionKey.OP_READ</code>，即有数据到达的事件。这个过程和传统 IO 中从 <code>ServerSocket.accept()</code> 获得 <code>Socket</code> 的过程类似。</p><p>然后，在 <code>if</code> 语句的另一个分支，我们来处理接收数据的过程。使用 <code>channel()</code> 方法得到双向读写的通道对象。随后，我们就可以使用之前熟悉的 buffer 来处理这个连接了。</p><p>最后，我们需要把处理结束的连接从 <code>keys</code> 中删除，以免重复处理。在实际的应用场景中，我们还需要把关闭的连接从 <code>Selector</code> 中去除，并且很有可能使用多线程。</p><h3 id=selectionkey>SelectionKey
<a class=anchor href=#selectionkey>#</a></h3><p>上面我们见到了 <code>OP_READ</code> 和 <code>OP_ACCEPT</code>。除此之外，NIO 还有 <code>OP_WRITE</code> 和 <code>OP_CONNECT</code> 两种事件。可以认为每个事件代表"就绪"：例如当连接另一方传来数据时，连接处于"读就绪"状态，对应事件 <code>OP_READ</code>。因此，写就绪和连接就绪这两种事件并不常用。</p><p>四种事件的值分别为 1、2、8、16，因此可以使用位操作来处理这些事件。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span> intreastSet <span style=color:#666>=</span> OP_READ <span style=color:#666>|</span> OP_ACCEPT<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>if</span> <span style=color:#666>((</span>interest <span style=color:#666>&amp;</span> OP_READ<span style=color:#666>)</span> <span style=color:#666>==</span> OP_READ<span style=color:#666>)</span> <span style=color:#666>{}</span>
</span></span></code></pre></div><p>相应地，<code>SelecttionKey</code> 也提供了一些处理这些信息的方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>boolean</span> <span style=color:#00f>isAcceptable</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>interestOps</span><span style=color:#666>();</span>  <span style=color:#408080;font-style:italic>// all interest ops
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>int</span> <span style=color:#00f>readyOps</span><span style=color:#666>();</span>     <span style=color:#408080;font-style:italic>// ops that already triggered
</span></span></span></code></pre></div><p>还可以为每个 <code>SectionKey</code> 附加一个对象，以方便识别类似的对象。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>selectionKey<span style=color:#666>.</span><span style=color:#7d9029>attach</span><span style=color:#666>(</span>theObject<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// or
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>SelectionKey key <span style=color:#666>=</span> channel<span style=color:#666>.</span><span style=color:#7d9029>register</span><span style=color:#666>(</span>selector<span style=color:#666>,</span> SelectionKey<span style=color:#666>.</span><span style=color:#7d9029>OP_READ</span><span style=color:#666>,</span> theObject<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Object attachedObj <span style=color:#666>=</span> selectionKey<span style=color:#666>.</span><span style=color:#7d9029>attachment</span><span style=color:#666>();</span>
</span></span></code></pre></div><h3 id=selector>Selector
<a class=anchor href=#selector>#</a></h3><p>除了 <code>select()</code> 方法外，<code>Selector</code> 类同样提供了带有超时的阻塞方法和非阻塞，允许返回 0 的方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>select</span><span style=color:#666>(</span><span style=color:#b00040>int</span> timeout<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#b00040>int</span> <span style=color:#00f>selectNow</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>如果在阻塞期间调用 <code>Selector</code> 的 <code>wakeUp()</code> 方法（当然，是在另一个线程里），线程会立刻放弃阻塞。在操作结束之后，需要使用 <code>Selector.close()</code> 方法。这将会使所有的 <code>SelectionKey</code> 都无效，但并不会关闭 Channel。</p><h2 id=异步-io-设计>异步 IO 设计
<a class=anchor href=#%e5%bc%82%e6%ad%a5-io-%e8%ae%be%e8%ae%a1>#</a></h2><h3 id=概述>概述
<a class=anchor href=#%e6%a6%82%e8%bf%b0>#</a></h3><p>阻塞 IO 和异步 IO 的区别是显而易见的。阻塞 IO 是一种成功的设计，它能够保证 IO 的可靠和简单。但在这种模式下，每个 IO 都需要单独的一个线程来处理。在 JVM 的默认参数下，32 bit 系统的一个栈为 320kB，64 bit 下更达到了 1MB，在高并发情况下这是完全无法接受的。线程池是解决这个问题的一种途径，但当我们面临大量低速长链接的时候，问题仍然没有被彻底解决。而这正是大规模互联网应用的常态。因此，异步 IO 成为了必然的选择。异步 IO 的最典型特征是，每一次检查不再是<em>阻塞或获得整块数据</em>，而是<em>0或数据</em>。这虽然解决了多线程的问题，却带来了另外一些需要解决的问题。</p><p>异步 IO 首先要解决的问题是，怎样用一个线程处理许多连接。于是，我们有了 Selector，使用一个 Selector 来处理许多连接，以实现"阻塞直到有一个"的效果，而不需要去处理那些尚未读到数据的连接。于是，线程资源被充分地利用起来。</p><p>第二个问题是，由于所有的操作都被立即返回，异步 IO 下读到的数据不总是完整的。甚至，在连续传输的情况下，几乎总是不完整的。于是，我们需要做两件事：</p><ul><li><p>判断当前的数据是否是完整的</p></li><li><p>将不完整的数据暂存起来，以备下一次传输时拼合起来。</p></li></ul><p>于是，我们在 Selector 与 Channel 之间加入一个 Message Reader，用来处理这些工作。在工程化的实践中，我们可能希望这套系统能够处理各种不同的协议。因此，可能会接收一个 Message Reader 的工厂作为参数，以进行依赖注入。</p><h3 id=message-reader-的实现>Message Reader 的实现
<a class=anchor href=#message-reader-%e7%9a%84%e5%ae%9e%e7%8e%b0>#</a></h3><p>前面我们看到，Message Reader 需要能够在内部的一个 Buffer 中存储不完整的 Message。显而易见，这个 buffer 的大小应该等于消息的最大值。但这时我们又遇到了之前说的内存不足的问题：百万级别的 1 MB buffer 意味着 1 TB 的 RAM 空间。因此，我们需要在这里使用可伸缩的（flexible）buffer。</p><h4 id=拷贝扩容>拷贝扩容
<a class=anchor href=#%e6%8b%b7%e8%b4%9d%e6%89%a9%e5%ae%b9>#</a></h4><p>一种常见的方法是熟悉的拷贝扩容，也就是当 buffer 已满后将所有内容复制到一个更大的数组中去。在这种方式下，threshold 的 选取就是一个重要的问题。例如，假设一个系统的请求消息不大于 4 kB，传输的文件通常不大于 128 kB，更大的文件则没有规律性。那么，我们就会将 threshold 设置为 4kB 和 128 kB，将最终的内存占用控制在 GB 级别。</p><h4 id=追加扩容>追加扩容
<a class=anchor href=#%e8%bf%bd%e5%8a%a0%e6%89%a9%e5%ae%b9>#</a></h4><p>另一种常见的方式是追加（append）扩容，方法是用一个列表将所有小的 buffer 片段集合起来，或者将一个大的数组分片，再用列表来管理分片。后者在内存模型上会更有利一些，但需要对并发量的准确判断。追加扩容的缺点也很明显，维护和读取都比较复杂。</p><h4 id=使用-tlv-消息>使用 TLV 消息
<a class=anchor href=#%e4%bd%bf%e7%94%a8-tlv-%e6%b6%88%e6%81%af>#</a></h4><p>许多协议，包括 HTTP/2 在内，开始使用 TLV 格式的消息。TLV 指的是 Type-Length-Value 的元组。对于这类消息，我们可以在一开始就知道消息的长度，并为其开辟好内存空间，避免了上面的方式中对内存资源的浪费。</p><p>当然，TLV 格式也有其缺点。对于很长的 TLV 消息，我们就需要很大的内存空间的预开辟，这也为 DoS 攻击提供了空间。一种解决方案是使用分段 TLV 的消息格式，但这并不能彻底解决问题。另一种方式是为消息设置超时时间。这样，服务器至少能够在一段时间的无响应后恢复。</p><h3 id=写不完整的消息>写不完整的消息
<a class=anchor href=#%e5%86%99%e4%b8%8d%e5%ae%8c%e6%95%b4%e7%9a%84%e6%b6%88%e6%81%af>#</a></h3><p>前面已经提到，非阻塞模式的通道并不能对一次 <code>write()</code> 实际写入的数据量做出保证，而是将写入的数据的字节数返回给调用者。于是，为了进一步解耦和提高效率，我们还需要在数据处理者和 Channel 同样准备一个 Message Writer，用来处理这个不稳定的输出过程。</p><p>回过头来想，我们在这里并不想为每个连接都维护一个线程。因此，我们只希望对有消息可写的 Writer 进行处理。因此，我们使用这样一个过程：</p><p>当 Message Writer 有消息可写时，才将其对应的 Channel 注册到 Selector。然后，服务器在空闲时检查 Selector 来获取可写的 Channel，并寻找其对应的 Writer 以写入数据。在 Writer 已经没有数据可写时，将 Channel 从 Selector 上解绑。</p><h3 id=集成>集成
<a class=anchor href=#%e9%9b%86%e6%88%90>#</a></h3><p>现在我们已经理清了输入和输出两个部分，现在我们从整个服务器的角度来思考。总的来说，一个服务器会执行这样一个循环：</p><p>从 ServerSocket 中获取 Socket => Select 读事件 => 将接受的数据交给 Reader 来处理 => 在核心部分处理 Reader 传来的完整数据 => 将处理后的数据交给 Writer => Select 写事件</p><p>当然，这些功能还可以在多个线程内完成。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-nio-应用>Java NIO: 应用</a><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#channel>Channel</a></li><li><a href=#buffer>Buffer</a></li><li><a href=#scatter--gather>Scatter / Gather</a></li></ul></li><li><a href=#网络和异步-io>网络和异步 IO</a><ul><li><a href=#tcp-异步-io-的例子>TCP 异步 IO 的例子</a></li><li><a href=#selectionkey>SelectionKey</a></li><li><a href=#selector>Selector</a></li></ul></li><li><a href=#异步-io-设计>异步 IO 设计</a><ul><li><a href=#概述>概述</a></li><li><a href=#message-reader-的实现>Message Reader 的实现</a><ul><li><a href=#拷贝扩容>拷贝扩容</a></li><li><a href=#追加扩容>追加扩容</a></li><li><a href=#使用-tlv-消息>使用 TLV 消息</a></li></ul></li><li><a href=#写不完整的消息>写不完整的消息</a></li><li><a href=#集成>集成</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>