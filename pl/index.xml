<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming Languages on czdm75 Blog</title><link>/pl/</link><description>Recent content in Programming Languages on czdm75 Blog</description><generator>Hugo -- gohugo.io</generator><atom:link href="/pl/index.xml" rel="self" type="application/rss+xml"/><item><title>Java NIO Internal</title><link>/pl/java-nio-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/pl/java-nio-2/</guid><description>Java NIO: 原理 # Buffer 内部实现与包装 # 更多形式的 get 与 put # 也存在一些其他形式的 get() 和 put() 方法。
byte get(); ByteBuffer get(byte dst[]); ByteBuffer get(byte dst[], int offset, int length); byte get(int index); ByteBuffer put(byte b ); ByteBuffer put(byte src[]); ByteBuffer put(byte src[], int offset, int length); ByteBuffer put(ByteBuffer src); ByteBuffer put(int index, byte b); 可以认为，这里接收 index 参数的方法是&amp;quot;绝对的&amp;quot;，它们直接对 buffer 中某个位置进行操作，而不受 buffer 目前状态的影响，绕过了下面我们将提到的 buffer 的统计方法。
Buffer 的统计方式 # Buffer 的行为相当于一个简单的数组，它有三个重要的属性：</description></item><item><title>Java NIO Usage</title><link>/pl/java-nio-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/pl/java-nio-1/</guid><description>Java NIO: 应用 # 基本概念 # Java NIO 是一种非阻塞的、面向块而非字节的 IO 方式。虽然 Java 的传统 IO 也进行了一些基于 NIO 的改造，NIO 仍然能够带来许多优势。
面向流的 IO 方便我们一个字节一个字节地处理数据，有利于实现过滤等功能，更加优雅和简单。相应地，其速度通常比较慢。
Java NIO 的模型由三部分组成。
Channel 通道，类似于传统 IO 中的流，用来实际传输数据。 Buffer 缓冲，我们用来读取和发送数据的位置。 Selector 选择器，可以在一个线程上绑定多个 Channel 和对应的 Buffer。 Channel # Channel 和流非常相似。区别是，通道支持异步读写，支持双向读写，而且基于缓冲区。相比之下，流通常是单向同步读写的。
常用的 Channel 主要包括：
FileChannel 文件 DatagramChannel UDP数据报 SocketChannel TCP 套接字 ServerSocketChannel TCP 服务端套接字 Buffer # Java 中的各种基本类型都有其对应的 Buffer，最常用的是 ByteBuffer。可以通过 Channel 或者手动写入数据。
ByteBuffer buffer = ByteBuffer.</description></item><item><title>Lambda Calculus and Y Combinator</title><link>/pl/lambda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/pl/lambda/</guid><description>Lambda 演算与 Y 组合子 # λ 演算 # λ 项 # 只有三种有效的 λ 项：
一个变量 $x$ 一个抽象 $\lambda f.\lambda x.x$，大致上等同于 Python 中的 lambda f, x: x 函数的应用 $ts$，大致上等同于 Python 中的 t(s) α-等价 # 在一个抽象中，变量的名字并不重要。例如 $\lambda x.x$ 和 $\lambda y.y$ 是 α-等价的。
描述这种变换的一种记法是使用：$t[x:=r]$，表示在 $t$ 中将所有的 $x$ 重命名为 $r$。于是有：
$x[x:=r]=r$，将 $x$ 替换为 $r$ $y[x:=r]=y$，$y$ 中不包括 $x$，无需替换 $(ts)[x:=r]=(t[x:=r])(s[x:=r])$，对应用，将两部分分别替换 $\lambda x.t[x:=r]=\lambda x.t$，替换前后并没有区别（α-等价） $\lambda y.t[x:=r]=\lambda t.t[x:=r]$ 自由变量与约束变量 # 自由变量被定义为这样的集合：</description></item><item><title>Scala: Currying, Partially Applied, Partial</title><link>/pl/curry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/pl/curry/</guid><description>Scala 中的柯里化、偏函数与部分应用函数 # 柯里化（Currying）、部分应用函数（Partially Applied Function）和偏函数（Partial Function）是 Scala 中三个非常容易混淆的元素。在 Groovy 中，部分应用函数也被称作了柯里化。实际上，二者的作用十分相似，思维上却有微妙的差异。
在传统面向对象方法中涉及到工厂或模板的场合，通常正是柯里化和部分应用函数发挥作用的地方。另一种常见的场合是，在一系列代码中需要为一个函数绑定某一个固定的参数。在传统方式中，我们可能会抽象一个函数出来。但在函数式范式中，我们可以直接将这个&amp;quot;临时函数&amp;quot;绑定在一个变量中。
概念上的区别 # 简单来说，柯里化的结果是&amp;quot;一串函数中的下一个&amp;quot;，而部分应用函数的结果是一个&amp;quot;减少了参数的函数&amp;quot;。对于函数 f(x, y, z)，其完全柯里化的结果是 f(x)(y)(z)。然后，我们将参数应用进去，例如规定 x 的值，得到的结果将是 g(y)(z)。反过来，对于部分应用函数，其结果将是 g(y, z)。
偏函数之所以会被混淆则是因为名字过于相似。偏函数的&amp;quot;Partial&amp;quot;意味着其只能处理其所接受的参数的一部分。这种情况常见于模式匹配。偏函数可以被连接起来，上一个函数无法处理的参数被传递至下一个函数去处理。
Groovy &amp;amp; Clojure # def volume = {h, w, l -&amp;gt; h * w * l} def area = volume.curry(1) def lengthPartialApplied = volume.curry(1, 1) def lengthCurried = volume.curry(1).curry(1) Groovy 的这些操作实际上是部分应用而不是柯里化。不过，这两种操作毕竟是十分相似的。而且，Groovy 也允许我们返回一个函数，以进行函数的复合。
def composite = { f, g, x -&amp;gt; return f(g(x)) } def func = composite.</description></item><item><title>Scala: Monad, from Scala Perspective</title><link>/pl/monad/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/pl/monad/</guid><description>从 Scala 视角看 Monad # 群 Group # 群是由一个集合与一个二元运算组成，满足四个性质：封闭性、结合律、单位元和逆元。以整数集 $\mathbb{Z}$ 与加法运算组合起来的群为例：
封闭性：所有集合内的元素经过二元运算得到的结果仍然在这个集合内。即，任意两个整数相加的结果仍为整数。 结合律：加法结合律 $(a+b)+c=a+(b+c)$。 单位元 / 幺元：存在一个元素与任意元素运算结果仍为那个元素。即，0 加任何整数结果都为那个整数。 逆元：对任意一个元素，总存在一个元素使得二者相运算结果为单位元。在这里即相反数。 如果省略逆元要求，则为一个幺半群（独异点，Monoid）。如果再省略单位元，则为一个半群（Semigroup）。从上面的结论可知，自然数与加法为一个幺半群，正整数与加法为一个半群。
群的性质落实到程序设计中形成了一定操作的可能性。因为集合在运算上的封闭，op 的参数和返回值是同样的类型。基于集合的归约操作也依赖运算的性质。因为运算满足结合律，所以归约操作可以并行化。因为幺半群的操作有幺元，我们可以从一个起始点进行归约，也就是 Scala 中的 reduce 和 fold 方法。
仍然以上面的加法为例。在求一个整数集合的和时，我们可以将集合拆分进行分布式计算，这是因为结合律。如果不使用 reduce 而使用 fold ,则需要一个初始值。这个初始值理所当然地就是 0，即运算的幺元。
从程序设计的角度来讲，幺半群可以用这样的形式表示。其封闭性通过类型参数保证，而幺元的正确性则需要我们自己来保证。
trait Monoid[A] { def op(a1: A, a2: A): A def zero: A } val intAddMonoid = new Monoid[Int] { def op(a1: Int, a2: Int) = a1 + a2 def zero = 0 } val intMultiplyMonoid = new Monoid[Int] { def op(a1: Int, a2: Int) = a1 * a2 def zero = 1 } val stringMonoid = new Monoid[String] { def op(a1: String, a2: String) = a1 + a2 def zero = &amp;#34;&amp;#34; } def listMonoid[A] = new Monoid[List[A]] { def op(a1: List[A], a2: List[A]) = a1 ++ a2 def zero = Nil } def optionMonoid[A] = new Monoid[Option[A]] { def op(a1: Option[A], a2: Option[A]) = a1 orElse a2 def zero = None } 范畴 Category # 范畴有三个条件：一个范畴由一系列物件 Object 构成的类 $ob(C)$ 和物件之间的态射组成的类 $hom(C)$ 构成。每一个态射是一个物件指向另一个物件的保持结构的一种关系。态射可以复合，就是说，如果对物件 $a,b,c$，有 $f:a\rightarrow b,g:b\rightarrow c$，那么存在 $g\circ f:a\rightarrow c$。一个范畴还满足两条公理：</description></item></channel></rss>