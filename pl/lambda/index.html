<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Lambda 演算与 Y 组合子 #  λ 演算 #  λ 项 #  只有三种有效的 λ 项：
 一个变量 $x$ 一个抽象 $\lambda f.\lambda x.x$，大致上等同于 Python 中的 lambda f, x: x 函数的应用 $ts$，大致上等同于 Python 中的 t(s)  α-等价 #  在一个抽象中，变量的名字并不重要。例如 $\lambda x.x$ 和 $\lambda y.y$ 是 α-等价的。
描述这种变换的一种记法是使用：$t[x:=r]$，表示在 $t$ 中将所有的 $x$ 重命名为 $r$。于是有：
 $x[x:=r]=r$，将 $x$ 替换为 $r$ $y[x:=r]=y$，$y$ 中不包括 $x$，无需替换 $(ts)[x:=r]=(t[x:=r])(s[x:=r])$，对应用，将两部分分别替换 $\lambda x.t[x:=r]=\lambda x.t$，替换前后并没有区别（α-等价） $\lambda y.t[x:=r]=\lambda t.t[x:=r]$  自由变量与约束变量 #  自由变量被定义为这样的集合："><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Lambda Calculus and Y Combinator"><meta property="og:description" content="Lambda 演算与 Y 组合子 #  λ 演算 #  λ 项 #  只有三种有效的 λ 项：
 一个变量 $x$ 一个抽象 $\lambda f.\lambda x.x$，大致上等同于 Python 中的 lambda f, x: x 函数的应用 $ts$，大致上等同于 Python 中的 t(s)  α-等价 #  在一个抽象中，变量的名字并不重要。例如 $\lambda x.x$ 和 $\lambda y.y$ 是 α-等价的。
描述这种变换的一种记法是使用：$t[x:=r]$，表示在 $t$ 中将所有的 $x$ 重命名为 $r$。于是有：
 $x[x:=r]=r$，将 $x$ 替换为 $r$ $y[x:=r]=y$，$y$ 中不包括 $x$，无需替换 $(ts)[x:=r]=(t[x:=r])(s[x:=r])$，对应用，将两部分分别替换 $\lambda x.t[x:=r]=\lambda x.t$，替换前后并没有区别（α-等价） $\lambda y.t[x:=r]=\lambda t.t[x:=r]$  自由变量与约束变量 #  自由变量被定义为这样的集合："><meta property="og:type" content="article"><meta property="og:url" content="/pl/lambda/"><meta property="article:section" content="pl"><title>Lambda Calculus and Y Combinator | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle checked>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/ class=active>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Lambda Calculus and Y Combinator</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#lambda-演算与-y-组合子>Lambda 演算与 Y 组合子</a><ul><li><a href=#λ-演算>λ 演算</a><ul><li><a href=#λ-项>λ 项</a></li><li><a href=#α-等价>α-等价</a></li><li><a href=#自由变量与约束变量>自由变量与约束变量</a></li><li><a href=#β-归约>β-归约</a></li><li><a href=#η-变换>η-变换</a></li></ul></li><li><a href=#邱奇数>邱奇数</a></li><li><a href=#邱奇逻辑>邱奇逻辑</a></li><li><a href=#y-组合子>Y 组合子</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=lambda-演算与-y-组合子>Lambda 演算与 Y 组合子
<a class=anchor href=#lambda-%e6%bc%94%e7%ae%97%e4%b8%8e-y-%e7%bb%84%e5%90%88%e5%ad%90>#</a></h1><h2 id=λ-演算>λ 演算
<a class=anchor href=#%ce%bb-%e6%bc%94%e7%ae%97>#</a></h2><h3 id=λ-项>λ 项
<a class=anchor href=#%ce%bb-%e9%a1%b9>#</a></h3><p>只有三种有效的 λ 项：</p><ul><li>一个变量 $x$</li><li>一个抽象 $\lambda f.\lambda x.x$，大致上等同于 Python 中的 <code>lambda f, x: x</code></li><li>函数的应用 $ts$，大致上等同于 Python 中的 <code>t(s)</code></li></ul><h3 id=α-等价>α-等价
<a class=anchor href=#%ce%b1-%e7%ad%89%e4%bb%b7>#</a></h3><p>在一个抽象中，变量的名字并不重要。例如 $\lambda x.x$ 和 $\lambda y.y$ 是 α-等价的。</p><p>描述这种变换的一种记法是使用：$t[x:=r]$，表示在 $t$ 中将所有的 $x$ 重命名为 $r$。于是有：</p><ul><li>$x[x:=r]=r$，将 $x$ 替换为 $r$</li><li>$y[x:=r]=y$，$y$ 中不包括 $x$，无需替换</li><li>$(ts)[x:=r]=(t[x:=r])(s[x:=r])$，对应用，将两部分分别替换</li><li>$\lambda x.t[x:=r]=\lambda x.t$，替换前后并没有区别（α-等价）</li><li>$\lambda y.t[x:=r]=\lambda t.t[x:=r]$</li></ul><h3 id=自由变量与约束变量>自由变量与约束变量
<a class=anchor href=#%e8%87%aa%e7%94%b1%e5%8f%98%e9%87%8f%e4%b8%8e%e7%ba%a6%e6%9d%9f%e5%8f%98%e9%87%8f>#</a></h3><p>自由变量被定义为这样的集合：</p><ul><li>对于变量 $x$，其自由变量集合仅包括 $x$</li><li>对于抽象 $\lambda x.t$，其自由变量集合为 $t$ 的自由变量集合去掉 $x$。</li><li>对于应用 $ts$，其自由变量为 $t$ 和 $s$ 自由变量集合的并集。</li></ul><p>定义这些的目的是在进行β-归约时避免变量名的冲突。不严谨地说，自由变量就是"可以被替换"的变量集合。</p><h3 id=β-归约>β-归约
<a class=anchor href=#%ce%b2-%e5%bd%92%e7%ba%a6>#</a></h3><p>β-归约表示，在应用函数时，可以直接对结果中相应的变量进行替换。即，$(\lambda x.t)s=t[x:=s]$。</p><p>在无类型 λ 演算中，有些形式无法被化到最简（称范式），如：</p><p>$$
(\lambda x.xx)(\lambda y.yy) = (\lambda y.yy)(\lambda y.yy)
$$</p><p>甚至，对于 $\lambda x.xxy$，反而会越来越长（$y$ 越来越多），顺序也会影响归约会否进入死循环。好在，有两个定理解决了这个问题：</p><ul><li>Church-Rosser 定理：如果一个 λ 项有范式，那么这个范式（在α-等价的意义上）是唯一的。</li><li>对一个 λ 项，始终归约其最左侧最外侧的可约式，总能得到β-范式（如果存在）。</li></ul><h3 id=η-变换>η-变换
<a class=anchor href=#%ce%b7-%e5%8f%98%e6%8d%a2>#</a></h3><p>η-变换并不是必需的，实际上它是前两者的一个推论：$\lambda x.f x=f$，其中 $x$ 不是 $f$ 中的自由变量。</p><h2 id=邱奇数>邱奇数
<a class=anchor href=#%e9%82%b1%e5%a5%87%e6%95%b0>#</a></h2><p>邱奇数是为 λ 演算而生的数的表示方式，同样基于皮亚诺公理（使用一个基础，即0或1，以及一个后继的定义来描述自然数）。我们令：</p><p>$$
\begin{align*} \operatorname{zero} &= \lambda f.\lambda x.x \\ \operatorname{succ} &= \lambda n.\lambda f.\lambda x.f(n\ f\ x) \end{align*}
$$</p><p>记得柯里化的原则：$n\ f\ x=n(f)(x)$。于是，就能得到：</p><p>$$
\begin{align*} \operatorname{one}&=\operatorname{succ\ zero}\\ &=(\lambda n.\lambda f.\lambda x.f(n\ f\ x))(\lambda g.\lambda y.y)\\ &=\lambda f.\lambda x.f\ x\\ \operatorname{two}&=\lambda f.\lambda x.f(f\ x)\\ \operatorname{three}&=\lambda f.\lambda x.f(f(f\ x)) \end{align*}
$$</p><p>在这个定义中，$f$ 的次数就意味着自然数的值。因此可以有：</p><p>$$
\begin{align*} \operatorname{plus}&=\lambda m.\lambda n.m\ \operatorname{succ}\ n\\ \operatorname{plus\ one\ two}&= (\lambda g.\lambda y. g y) (\lambda n.\lambda f.\lambda x f(n f x))\ \operatorname{two}\\ &=(\lambda y.(\lambda n.\lambda f.\lambda x.f(n\ f\ x))y)\ \operatorname{two}\\ &=(\lambda y.(\lambda f.\lambda x.f(y\ f\ x)))\ \operatorname{two}\\ &=(\lambda n.\lambda f.\lambda x. f(n\ f\ x))\ \operatorname{two}\\ &=\operatorname{succ\ two}\\ \end{align*}
$$</p><p>同理，有：</p><p>$$
\begin{align*} \operatorname{mult}&=\lambda m.\lambda n.\lambda f.n(m\ f)\\ \operatorname{exp}&=\lambda m.\lambda n.n\ m\\ \operatorname{pred}&=\lambda n.\lambda f.\lambda x.n(\lambda g.\lambda h.h(g\ f))(\lambda u.x)(\lambda u.u)\\ \operatorname{sub}&=\lambda m.\lambda n.m\ \operatorname{pred}\ n \end{align*}
$$</p><h2 id=邱奇逻辑>邱奇逻辑
<a class=anchor href=#%e9%82%b1%e5%a5%87%e9%80%bb%e8%be%91>#</a></h2><p>$$
\begin{align*} \operatorname{true}&=\lambda a.\lambda b.a\\ \operatorname{false}&=\lambda a.\lambda b.b\\ \operatorname{and} &= \lambda p.\lambda q.p\ q\ p\\ \operatorname{or} &= \lambda p.\lambda q.p\ p\ q\\ \operatorname{if} &= \lambda p.\lambda a.\lambda b.p\ a\ b \end{align*}
$$</p><p>更进一步，可以基于这些进行谓词逻辑的运算：</p><p>$$
\begin{align*} \operatorname{iszero}&=\lambda n.n (\lambda x.\operatorname{false}) \operatorname{true}\\ \operatorname{leq}&=\lambda m.\lambda n.\operatorname{iszero} (\operatorname{sub}m\ n)\\ \operatorname{eq}&=\lambda m.\lambda n. \operatorname{and} (\operatorname{leq}m\ n)(\operatorname{leq}n\ m) \end{align*}
$$</p><h2 id=y-组合子>Y 组合子
<a class=anchor href=#y-%e7%bb%84%e5%90%88%e5%ad%90>#</a></h2><p>接下来考虑一个递归函数：</p><p>$$
\operatorname{fact} = \lambda n.\operatorname{if}(\operatorname{iszero}\ n)\ \operatorname{one}\ (\operatorname{mult}\ n (\operatorname{fact}(\operatorname{pred}\ n))
$$</p><p>直接进行递归是不行的，这里只是一个简单的演算，$\operatorname{fact}$ 这个名字，甚至所有的名字都是不必要的。一种方式是这样的：</p><p>$$
\begin{align*} \operatorname{fact1}&=\lambda f.\lambda n.\operatorname{if}(\operatorname{iszero}\ n)\ \operatorname{one}\ (\operatorname{mult}\ n (f\ f(\operatorname{pred}\ n))\\ \operatorname{fact}&=\operatorname{fact1}\ \operatorname{fact1} \end{align*}
$$</p><p>通过这种方式，使用 $f\ f$来代替原来的递归，就能做到调用自身。不过，这样做仍然不够优雅。因此，Haskell 和图灵分别发现了两个不动点组合子（常用的是前者）：</p><p>$$
\begin{align*} \operatorname Y&=\lambda f.(\lambda x.(f(x\ x))(\lambda x.(f(x\ x))))\\ \operatorname\Theta&=(\lambda x.\lambda y.(y (x x y))) (\lambda x.\lambda y.(y (x x y))) \end{align*}
$$</p><p>由于其前半部分和后半部分相同，经常也写作：</p><p>$$
\operatorname Y=\lambda f.(\lambda g.g\ g)(\lambda x.f(x\ x))
$$</p><p>经过简单的演算，可以得到：</p><p>$$
\begin{align*} \operatorname Y\ g&=\lambda f.(\lambda x.(f(x\ x))(\lambda x.(f(x\ x))))\ g\\ &=(\lambda x.(g(x\ x)))(\lambda y.(g(y\ y)))\\ &=g\ ((\lambda y.(g(y\ y)))(\lambda y.(g(y\ y))))\\ &=g\ (\operatorname Y\ g) \end{align*}
$$</p><p>除了符合函数不动点的定义之外，更重要的是在程序中它可以"再次调用函数"，直到抵达递归中的结束条件。需要注意的是这两种形式都使用于 call-by-name 的求值策略，传值调用下需要稍微修改一下形式：</p><p>$$
\begin{align*} \operatorname Z&=\lambda f.(\lambda x.f(\lambda y.x\ x\ y))(\lambda x.f(\lambda y.x\ x\ y))\\ \operatorname\Theta_V&=(\lambda x.\lambda y.(y(\lambda z.x\ x\ y\ z)))(\lambda x.\lambda y.(y(\lambda z.x\ x\ y\ z))) \end{align*}
$$</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#lambda-演算与-y-组合子>Lambda 演算与 Y 组合子</a><ul><li><a href=#λ-演算>λ 演算</a><ul><li><a href=#λ-项>λ 项</a></li><li><a href=#α-等价>α-等价</a></li><li><a href=#自由变量与约束变量>自由变量与约束变量</a></li><li><a href=#β-归约>β-归约</a></li><li><a href=#η-变换>η-变换</a></li></ul></li><li><a href=#邱奇数>邱奇数</a></li><li><a href=#邱奇逻辑>邱奇逻辑</a></li><li><a href=#y-组合子>Y 组合子</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>