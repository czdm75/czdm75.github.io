<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='Java NIO: 原理 # Buffer 内部实现与包装 # 更多形式的 get 与 put # 也存在一些其他形式的 get() 和 put() 方法。
byte get(); ByteBuffer get(byte dst[]); ByteBuffer get(byte dst[], int offset, int length); byte get(int index); ByteBuffer put(byte b ); ByteBuffer put(byte src[]); ByteBuffer put(byte src[], int offset, int length); ByteBuffer put(ByteBuffer src); ByteBuffer put(int index, byte b); 可以认为，这里接收 index 参数的方法是"绝对的"，它们直接对 buffer 中某个位置进行操作，而不受 buffer 目前状态的影响，绕过了下面我们将提到的 buffer 的统计方法。
Buffer 的统计方式 # Buffer 的行为相当于一个简单的数组，它有三个重要的属性：
capacity 数组的大小。'><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/pl/java-nio-2/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="Java NIO Internal"><meta property="og:description" content='Java NIO: 原理 # Buffer 内部实现与包装 # 更多形式的 get 与 put # 也存在一些其他形式的 get() 和 put() 方法。
byte get(); ByteBuffer get(byte dst[]); ByteBuffer get(byte dst[], int offset, int length); byte get(int index); ByteBuffer put(byte b ); ByteBuffer put(byte src[]); ByteBuffer put(byte src[], int offset, int length); ByteBuffer put(ByteBuffer src); ByteBuffer put(int index, byte b); 可以认为，这里接收 index 参数的方法是"绝对的"，它们直接对 buffer 中某个位置进行操作，而不受 buffer 目前状态的影响，绕过了下面我们将提到的 buffer 的统计方法。
Buffer 的统计方式 # Buffer 的行为相当于一个简单的数组，它有三个重要的属性：
capacity 数组的大小。'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="pl"><title>Java NIO Internal | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle checked>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/ class=active>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Java NIO Internal</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-nio-原理>Java NIO: 原理</a><ul><li><a href=#buffer-内部实现与包装>Buffer 内部实现与包装</a><ul><li><a href=#更多形式的-get-与-put>更多形式的 get 与 put</a></li><li><a href=#buffer-的统计方式>Buffer 的统计方式</a></li><li><a href=#类型化包装>类型化、包装</a></li><li><a href=#只读直接缓冲区内存映射>只读、直接缓冲区、内存映射</a></li></ul></li><li><a href=#nio-中的各种-channel>NIO 中的各种 Channel</a><ul><li><a href=#filechannel>FileChannel</a></li><li><a href=#asynchronousfilechannel-异步文件通道>AsynchronousFileChannel 异步文件通道</a></li><li><a href=#socketchannel>SocketChannel</a></li><li><a href=#serversocketchannel>ServerSocketChannel</a></li><li><a href=#datagramchannel>DataGramChannel</a></li><li><a href=#pipe-管道>Pipe 管道</a></li></ul></li><li><a href=#提供其他相关功能的类>提供其他相关功能的类</a><ul><li><a href=#javaniofilepath>java.nio.file.Path</a></li><li><a href=#javaniofilefiles>java.nio.file.Files</a><ul><li><a href=#对文件的操作>对文件的操作</a></li><li><a href=#filevisitor-遍历目录结构>FileVisitor 遍历目录结构</a></li><li><a href=#files-与-stream>Files 与 Stream</a></li></ul></li><li><a href=#文件锁>文件锁</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java-nio-原理>Java NIO: 原理
<a class=anchor href=#java-nio-%e5%8e%9f%e7%90%86>#</a></h1><h2 id=buffer-内部实现与包装>Buffer 内部实现与包装
<a class=anchor href=#buffer-%e5%86%85%e9%83%a8%e5%ae%9e%e7%8e%b0%e4%b8%8e%e5%8c%85%e8%a3%85>#</a></h2><h3 id=更多形式的-get-与-put>更多形式的 get 与 put
<a class=anchor href=#%e6%9b%b4%e5%a4%9a%e5%bd%a2%e5%bc%8f%e7%9a%84-get-%e4%b8%8e-put>#</a></h3><p>也存在一些其他形式的 <code>get()</code> 和 <code>put()</code> 方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>byte</span><span style=color:#bbb> </span><span style=color:#00f>get</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>get</span>(<span style=color:#b00040>byte</span><span style=color:#bbb> </span>dst<span style=color:#666>[]</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>get</span>(<span style=color:#b00040>byte</span><span style=color:#bbb> </span>dst<span style=color:#666>[]</span>,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>offset,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>length);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>byte</span><span style=color:#bbb> </span><span style=color:#00f>get</span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>index);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>put</span>(<span style=color:#b00040>byte</span><span style=color:#bbb> </span>b<span style=color:#bbb> </span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>put</span>(<span style=color:#b00040>byte</span><span style=color:#bbb> </span>src<span style=color:#666>[]</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>put</span>(<span style=color:#b00040>byte</span><span style=color:#bbb> </span>src<span style=color:#666>[]</span>,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>offset,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>length);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>put</span>(ByteBuffer<span style=color:#bbb> </span>src);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span><span style=color:#00f>put</span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>index,<span style=color:#bbb> </span><span style=color:#b00040>byte</span><span style=color:#bbb> </span>b);<span style=color:#bbb>
</span></span></span></code></pre></div><p>可以认为，这里接收 <code>index</code> 参数的方法是"绝对的"，它们直接对 buffer 中某个位置进行操作，而不受 buffer 目前状态的影响，绕过了下面我们将提到的 buffer 的统计方法。</p><h3 id=buffer-的统计方式>Buffer 的统计方式
<a class=anchor href=#buffer-%e7%9a%84%e7%bb%9f%e8%ae%a1%e6%96%b9%e5%bc%8f>#</a></h3><p>Buffer 的行为相当于一个简单的数组，它有三个重要的属性：</p><ul><li><p>capacity 数组的大小。</p></li><li><p>limit 在写入时，就是 capacity。在读取时，就是最多能够读取的字节数。</p></li><li><p>position 当前的指针位置。</p></li></ul><p>当 position 到达 limit 时，继续 <code>get</code> 会抛出异常。这时，可以使用 <code>rewind()</code> 将 position 重新指回开头，使用 <code>clear()</code> 将 limit 和 position 一起重置，或者使用 <code>compact()</code> 保留未读的数据。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buf<span style=color:#bbb>            </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=4 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf.<span style=color:#7d9029>rewind</span>()<span style=color:#bbb>   </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=0 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf.<span style=color:#7d9029>clear</span>()<span style=color:#bbb>    </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=0 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// some operation</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf<span style=color:#bbb>            </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=1 lim=2 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf.<span style=color:#7d9029>compact</span>()<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=1 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>可以看到，<code>clear()</code> 同时也将 buffer 设置回了写入模式。</p><p>如果我们并不想直接回到 buffer 的最开始位置，也可以通过 <code>mark()</code> 和 <code>reset()</code> 来手动标记。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buf.<span style=color:#7d9029>mark</span>()<span style=color:#bbb>   </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=1 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf.<span style=color:#7d9029>get</span>()<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf<span style=color:#bbb>          </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=2 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buf.<span style=color:#7d9029>reset</span>()<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=1 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>需要注意的是，buffer 的<strong>读取模式和写入模式并没有严格的区分</strong>，而是通过 position 与 limit 的相对位置来控制。例如，在读取模式下调用 <code>get()</code> 将会同样返回当前位置的值（这个值是上一次读写遗留下来的），并将 position 加一。应当避免这类情况。</p><p>总的来看，写入模式下，limit 与 capacity 相等，pos 指向要写入的位置，pos 以下的是"有效数据"。读取模式下，limit 为有效数据的范围，pos 为当前读取的位置。limit 以下的是"有效数据"。在 buffer 的 <code>equals()</code> 方法中，只比较有效数据。当然，如果有效数据的长度不相等，<code>equals()</code> 一定为假。</p><h3 id=类型化包装>类型化、包装
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e5%8c%96%e5%8c%85%e8%a3%85>#</a></h3><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>byte</span><span style=color:#666>[]</span><span style=color:#bbb> </span>array<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span><span style=color:#b00040>byte</span><span style=color:#666>[</span>8<span style=color:#666>]</span><span style=color:#bbb>                  </span><span style=color:#408080;font-style:italic>// { 0, 0, 0, 0, 0, 0, 0, 0 }</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span>buffer<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>ByteBuffer.<span style=color:#7d9029>wrap</span>(array)<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=0 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buffer.<span style=color:#7d9029>putInt</span>(2147004567)<span style=color:#bbb>                   </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=4 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>array<span style=color:#bbb>                                       </span><span style=color:#408080;font-style:italic>// { 127, -8, -80, -105, 0, 0, 0, 0 }</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buffer.<span style=color:#7d9029>flip</span>()<span style=color:#bbb>                               </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=0 lim=4 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buffer.<span style=color:#7d9029>getInt</span>()<span style=color:#bbb>                             </span><span style=color:#408080;font-style:italic>// 2147004567</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>在这里我们做了两件事。首先，我们将一个数组包装成了 buffer。并且可以看到，对 buffer 的操作可以立刻体现在数组里。其次，我们使用了 <code>ByteBuffer</code> 的类型化 getter 和 setter。这类方法可以将 <code>long</code>、<code>double</code> 等类型的变量存入 <code>ByteBuffer</code> 并原样读取出来，对复杂数据的操作，例如 Unicode 文本和图片都有利。</p><p>除了对数组进行包装，也可以将一个 buffer 的一部分包装成另一个 buffer。与上面的情况类似，这两个 buffer 共享同一个底层数组。通过这种方法，可以更好地分离功能，让我们处理数据的代码的耦合度得到降低。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buffer.<span style=color:#7d9029>putLong</span>(465132465415L)<span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=8 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buffer.<span style=color:#7d9029>position</span>(3)<span style=color:#bbb>                   </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=3 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>buffer.<span style=color:#7d9029>limit</span>(7)<span style=color:#bbb>                      </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=3 lim=7 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer<span style=color:#bbb> </span>another<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>buffer.<span style=color:#7d9029>slice</span>()<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// HeapByteBuffer[pos=0 lim=4 cap=4]</span><span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=只读直接缓冲区内存映射>只读、直接缓冲区、内存映射
<a class=anchor href=#%e5%8f%aa%e8%af%bb%e7%9b%b4%e6%8e%a5%e7%bc%93%e5%86%b2%e5%8c%ba%e5%86%85%e5%ad%98%e6%98%a0%e5%b0%84>#</a></h3><p>Java NIO 还提供了只读缓冲区包装和速度更快的直接缓冲区。对于直接缓冲区，JVM 会尽量从系统 IO 调用中直接读取或写入系统调用，避免中间更多的缓冲区开销。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>buffer.<span style=color:#7d9029>asReadOnlyBuffer</span>()<span style=color:#bbb>     </span><span style=color:#408080;font-style:italic>// HeapByteBufferR[pos=3 lim=7 cap=8]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>ByteBuffer.<span style=color:#7d9029>allocateDirect</span>(8)<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// DirectByteBuffer[pos=0 lim=8 cap=8]</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>最后，Java 还提供了将文件直接映射到内存里的方式。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>MappedByteBuffer<span style=color:#bbb> </span>mbb<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>fc.<span style=color:#7d9029>map</span>(FileChannel.<span style=color:#7d9029>MapMode</span>.<span style=color:#7d9029>READ_WRITE</span>,<span style=color:#bbb> </span>start,<span style=color:#bbb> </span>size);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>mbb.<span style=color:#7d9029>put</span>(0,<span style=color:#bbb> </span>(<span style=color:#b00040>byte</span>)97);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>mbb.<span style=color:#7d9029>put</span>(1023,<span style=color:#bbb> </span>(<span style=color:#b00040>byte</span>)122);<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=nio-中的各种-channel>NIO 中的各种 Channel
<a class=anchor href=#nio-%e4%b8%ad%e7%9a%84%e5%90%84%e7%a7%8d-channel>#</a></h2><h3 id=filechannel>FileChannel
<a class=anchor href=#filechannel>#</a></h3><p>前面我们已经见到 <code>FileChannel</code> 的使用，它是一种只有阻塞模式的 Channel。<code>FileChannel</code> 操作的是随机读写的文件。因此，还有一些相应的属性和方法。<code>truncate</code> 代表从当前位置截取一定长度的文件，<code>force</code> 代表强制将系统缓存写入到磁盘。接收的参数代表是否写入元数据。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>long</span><span style=color:#bbb> </span>pos<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>channel.<span style=color:#7d9029>position</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>position</span>(pos<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>123);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>fileSize<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>channel.<span style=color:#7d9029>size</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>truncate</span>(1024);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>force</span>(<span style=color:green;font-weight:700>true</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>出于网络数据与本地文件之间的转换非常常见，NIO 提供了一些便利的转换方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>RandomAccessFile<span style=color:#bbb> </span>toFile<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>RandomAccessFile(<span style=color:#ba2121>&#34;toFile.txt&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;rw&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>FileChannel<span style=color:#bbb>      </span>toChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>toFile.<span style=color:#7d9029>getChannel</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>position<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>0;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>count<span style=color:#bbb>    </span><span style=color:#666>=</span><span style=color:#bbb> </span>fromChannel.<span style=color:#7d9029>size</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>toChannel.<span style=color:#7d9029>transferFrom</span>(fromChannel,<span style=color:#bbb> </span>position,<span style=color:#bbb> </span>count);<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>count</code> 只能代表传输量的最大值，如果通道的数据量小于 <code>count</code>，就只传递通道内实际有的数据。类似地，也可以使用 <code>FileChannel.transferTo(position, count, channel)</code> 来将文件内容传输到其他位置。</p><h3 id=asynchronousfilechannel-异步文件通道>AsynchronousFileChannel 异步文件通道
<a class=anchor href=#asynchronousfilechannel-%e5%bc%82%e6%ad%a5%e6%96%87%e4%bb%b6%e9%80%9a%e9%81%93>#</a></h3><p>异步文件通道的读写返回的是一系列的 <code>Future</code> 包装的对象，并且不会阻塞，可以立即返回。其创建和其他的通道类似：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>AsynchromousFileChannel<span style=color:#bbb> </span>fileChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>AsynchronousFileChannel.<span style=color:#7d9029>open</span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Paths.<span style=color:#7d9029>get</span>(<span style=color:#ba2121>&#34;data/test.xml&#34;</span>),<span style=color:#bbb> </span>StandardOpenOption.<span style=color:#7d9029>READ</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Future<span style=color:#666>&lt;</span>Integer<span style=color:#666>&gt;</span><span style=color:#bbb> </span>operation<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>fileChannel.<span style=color:#7d9029>read</span>(buffer,<span style=color:#bbb> </span>0);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>while</span>(<span style=color:#666>!</span>operation.<span style=color:#7d9029>isDone</span>());<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里 <code>read()</code> 的第二个参数是读取文件的起始位置。然后，我们可以通过 <code>isDone()</code> 来判断读取的完成。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>fileChannel.<span style=color:#7d9029>read</span>(buffer,<span style=color:#bbb> </span>position,<span style=color:#bbb> </span>attachment,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>CompletionHandler<span style=color:#666>&lt;</span>Integer,<span style=color:#bbb> </span>ByteBuffer<span style=color:#666>&gt;</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>completed</span>(Integer<span style=color:#bbb> </span>result,<span style=color:#bbb> </span>Attatchment<span style=color:#bbb> </span>attachment)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>failed</span>(Throwable<span style=color:#bbb> </span>exc,<span style=color:#bbb> </span>Attachment<span style=color:#bbb> </span>attachment)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>});<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里的第三个参数是 IO 操作的 Attachment，和前面 <code>SelectionKey</code> 的 Attachment 类似，可以为 null。然后，我们继承一个 <code>CompletionHandler</code> , 其第二个泛型类型变量是 Attachment 的类型。如果 <code>read</code> 成功，随即就会调用 <code>completed</code> 方法。通常，对于一般的网络应用，我们可以把同一个 buffer 作为 Attachment 传入，并在 <code>completed</code> 方法中使用 buffer 回应。相应地，如果读取失败，会将对应的 <code>Throwable</code> 传到 <code>failed</code> 方法。</p><p>写数据的方法和读取相似：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>AsynchromousFileChannel<span style=color:#bbb> </span>fileChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>AsynchronousFileChannel.<span style=color:#7d9029>open</span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Paths.<span style=color:#7d9029>get</span>(<span style=color:#ba2121>&#34;data/test.xml&#34;</span>),<span style=color:#bbb> </span>StandardOpenOption.<span style=color:#7d9029>WRITE</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// possible throws java.nio.file.NoSuchFileException</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Future<span style=color:#666>&lt;</span>Integer<span style=color:#666>&gt;</span><span style=color:#bbb> </span>operation<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>fileChannel.<span style=color:#7d9029>write</span>(buffer,<span style=color:#bbb> </span>position);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>while</span>(<span style=color:#666>!</span>operation.<span style=color:#7d9029>isDone</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>fileChannel.<span style=color:#7d9029>write</span>(buffer,<span style=color:#bbb> </span>position,<span style=color:#bbb> </span>buffer,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>CompletionHandler<span style=color:#666>&lt;</span>Integer,<span style=color:#bbb> </span>ByteBuffer<span style=color:#666>&gt;</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>completed</span>(Integer<span style=color:#bbb> </span>result,<span style=color:#bbb> </span>ByteBuffer<span style=color:#bbb> </span>attachment)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>failed</span>(Throwable<span style=color:#bbb> </span>exc,<span style=color:#bbb> </span>ByteBuffer<span style=color:#bbb> </span>attachment)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#7d9029>out</span>.<span style=color:#7d9029>println</span>(<span style=color:#ba2121>&#34;Write failed&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>exc.<span style=color:#7d9029>printStackTrace</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>});<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=socketchannel>SocketChannel
<a class=anchor href=#socketchannel>#</a></h3><p>前面见到了服务端开启 <code>SocketChannel</code> 的方法，并将其和传统方式比较了一下。客户端的情况还要更简单一些：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>SocketChannel<span style=color:#bbb> </span>socketChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>SocketChannel.<span style=color:#7d9029>open</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>socketChannel.<span style=color:#7d9029>connect</span>(<span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>InetSocketAddress(<span style=color:#ba2121>&#34;http://jenkov.com&#34;</span>,<span style=color:#bbb> </span>80));<span style=color:#bbb>
</span></span></span></code></pre></div><p>阻塞模式下的操作我们已经比较熟悉，和传统 IO 基本相同。在非阻塞模式下，就要使用更多的方法来检查 Channel 的情况：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>socketChannel.<span style=color:#7d9029>configureBlocking</span>(<span style=color:green;font-weight:700>false</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>socketChannel.<span style=color:#7d9029>connect</span>(<span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>InetSocketAddress(<span style=color:#ba2121>&#34;http://jenkov.com&#34;</span>,<span style=color:#bbb> </span>80));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>while</span>(<span style=color:#666>!</span>socketChannel.<span style=color:#7d9029>finishConnect</span>()){<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#408080;font-style:italic>// wait</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>类似地，在非阻塞模式下的 <code>read</code> 方法总是能被调用，同时也意味着它有可能并不读出任何数据。因此，必须要检查方法的返回值，即读入的字节数。非阻塞模式和 Selector 的运行方式也更加吻合。</p><h3 id=serversocketchannel>ServerSocketChannel
<a class=anchor href=#serversocketchannel>#</a></h3><p>阻塞模式的运行方式我们同样已经比较熟悉。在非阻塞模式下，调用 <code>accept()</code> 方法可能会返回 null，代表没有连接建立。</p><h3 id=datagramchannel>DataGramChannel
<a class=anchor href=#datagramchannel>#</a></h3><p>UDP 本身就是无连接的，因此数据包通道的操作和传统 IO 没有太大的区别：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>DatagramChannel<span style=color:#bbb> </span>channel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>DatagramChannel.<span style=color:#7d9029>open</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>socket</span>().<span style=color:#7d9029>bind</span>(<span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>InetSocketAddress(9999));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>receive</span>(buf);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#bbb> </span>byteSent<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>channel.<span style=color:#7d9029>send</span>(buf,<span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>InetSocketAddress(<span style=color:#ba2121>&#34;example.com&#34;</span>,<span style=color:#bbb> </span>80));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// connecting to a specific address</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>channel.<span style=color:#7d9029>connect</span>(<span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>InetSocketAddress(<span style=color:#ba2121>&#34;example.com&#34;</span>),<span style=color:#bbb> </span>80));<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果在 <code>recieve</code> 时实际数据量超过了 buffer 的大小，多出的数据会被直接抛弃。</p><p>在调用了 <code>connect</code> 方法之后，就可以像 TCP 一样调用 <code>read</code> 和 <code>write</code> 方法。只不过，背后实际调用的仍然是 TCP 模式，数据的读写也无法得到保证。</p><h3 id=pipe-管道>Pipe 管道
<a class=anchor href=#pipe-%e7%ae%a1%e9%81%93>#</a></h3><p>管道能够提供将一个通道的数据发送到另一个的功能。也可以通过方法将数据取出来。这是一个抽象类，具体的实现需要继承编写。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Pipe<span style=color:#bbb> </span>pipe<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Pipe.<span style=color:#7d9029>open</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Pipe.<span style=color:#7d9029>SinkChannel</span><span style=color:#bbb> </span>sinkChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>pipe.<span style=color:#7d9029>sink</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Pipe.<span style=color:#7d9029>SourceChannel</span><span style=color:#bbb> </span>sourceChannel<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>pipe.<span style=color:#7d9029>source</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=提供其他相关功能的类>提供其他相关功能的类
<a class=anchor href=#%e6%8f%90%e4%be%9b%e5%85%b6%e4%bb%96%e7%9b%b8%e5%85%b3%e5%8a%9f%e8%83%bd%e7%9a%84%e7%b1%bb>#</a></h2><h3 id=javaniofilepath>java.nio.file.Path
<a class=anchor href=#javaniofilepath>#</a></h3><p><code>Path</code> 是在 Java 7 的 NIO 2 中引入的，其伴随类 <code>Paths</code> 同样位于 <code>java.nio.file</code> 包。这个类和原来的 <code>java.io.File</code> 类的功能类似，在 NIO 中，专用来处理路径。而关于具体文件的操作大多交给 <code>Files</code>，以 <code>Path</code> 作为其参数。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Path<span style=color:#bbb> </span>path<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Paths.<span style=color:#7d9029>get</span>(<span style=color:#ba2121>&#34;/home/user/a.txt&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// use base path and relativepath to create absolute path</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Path<span style=color:#bbb> </span>file<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Paths.<span style=color:#7d9029>get</span>(<span style=color:#ba2121>&#34;/home/user&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;a.txt&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Paths.<span style=color:#7d9029>get</span>(<span style=color:#ba2121>&#34;/home/./../opt&#34;</span>).<span style=color:#7d9029>normalize</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// equals /opt</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>如果将 UNIX 绝对路径用在 Windows 上，得到的将会是相对于当前磁盘的路径。</p><h3 id=javaniofilefiles>java.nio.file.Files
<a class=anchor href=#javaniofilefiles>#</a></h3><p><code>Files</code> 用来和 <code>Path</code> 类共同操作文件，将其和传统的 <code>java.io.File</code> 类区分开。</p><h4 id=对文件的操作>对文件的操作
<a class=anchor href=#%e5%af%b9%e6%96%87%e4%bb%b6%e7%9a%84%e6%93%8d%e4%bd%9c>#</a></h4><p>在操作文件时，需要注意，并不支持递归创建。也就是说，在创建一个文件之前，必须首先创建其父文件夹。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// check if exist</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(<span style=color:#666>!</span>Files.<span style=color:#7d9029>exists</span>(path))<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Files.<span style=color:#7d9029>createFile</span>(path);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(<span style=color:#666>!</span>Files.<span style=color:#7d9029>exist</span>(path,<span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>LinkOption<span style=color:#666>[]</span>{LinkOption.<span style=color:#7d9029>NOFOLLOW_LINKS</span>}))<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// create, copy, throws FileAlreadyExistsException, IOException</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Path<span style=color:#bbb> </span>newdir<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Files.<span style=color:#7d9029>createDirectory</span>(path);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Files.<span style=color:#7d9029>copy</span>(sourcePath,<span style=color:#bbb> </span>destinationPath);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Files.<span style=color:#7d9029>copy</span>(sourcePath,<span style=color:#bbb> </span>destinationPath,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>StandardCopyOption.<span style=color:#7d9029>REPLACE_EXISTING</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// move, delete, throws IOException</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Files.<span style=color:#7d9029>move</span>(sourcePath,<span style=color:#bbb> </span>destinationPath,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>StandardCopyOption.<span style=color:#7d9029>REPLACE_EXISTING</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Files.<span style=color:#7d9029>delete</span>(path);<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=filevisitor-遍历目录结构>FileVisitor 遍历目录结构
<a class=anchor href=#filevisitor-%e9%81%8d%e5%8e%86%e7%9b%ae%e5%bd%95%e7%bb%93%e6%9e%84>#</a></h4><p><code>walkFileTree()</code> 方法可以查看目录结构。这个方法需要接受一个自己实现的 <code>FileVisitor</code> 对象。Java 只提供了一个全空实现的 <code>SimpleFileVisitor</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>enum</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>CONTINUE,<span style=color:#bbb> </span>TERMINATE,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>SKIP_SIBLINGS,<span style=color:#bbb> </span><span style=color:#408080;font-style:italic>// dont visit brother files;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>SKIP_SUBTREE;<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// dont visit subdir and subfile</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:#408080;font-style:italic>// only effective in preVisitDirectory,</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                   </span><span style=color:#408080;font-style:italic>// or continue;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Files.<span style=color:#7d9029>walkFileTree</span>(path,<span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>FileVisitor<span style=color:#666>&lt;</span>Path<span style=color:#666>&gt;</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>preVisitDirectory</span>(Path<span style=color:#bbb> </span>dir,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>BasicFileAttributes<span style=color:#bbb> </span>attrs)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>//...;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>visitFile</span>(Path<span style=color:#bbb> </span>file,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>BasicFileAttributes<span style=color:#bbb> </span>attrs)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>//...;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>visitFileFailed</span>(Path<span style=color:#bbb> </span>file,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>IOException<span style=color:#bbb> </span>exc)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>//...;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>postVisitDirectory</span>(Path<span style=color:#bbb> </span>dir,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>IOException<span style=color:#bbb> </span>exc)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>//...;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>});<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>FileVisitor</code> 的这种定义是为了解决递归问题。例如，我们要删除一个目录，必须先删除其所有的子目录和文件。我们不继承 <code>FileVisitor</code>，而是继承 <code>SimpleFileVisitor</code>，以继承类内的空方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Files.<span style=color:#7d9029>walkFileTree</span>(rootPath,<span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>SimpleFileVisitor<span style=color:#666>&lt;</span>Path<span style=color:#666>&gt;</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>visitFile</span>(Path<span style=color:#bbb> </span>file,<span style=color:#bbb> </span>BasicFileAttributes<span style=color:#bbb> </span>attrs)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#7d9029>out</span>.<span style=color:#7d9029>println</span>(<span style=color:#ba2121>&#34;delete file: &#34;</span><span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>file.<span style=color:#7d9029>toString</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>Files.<span style=color:#7d9029>delete</span>(file);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>FileVisitResult<span style=color:#bbb> </span><span style=color:#00f>postVisitDirectory</span>(Path<span style=color:#bbb> </span>dir,<span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>exc)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>Files.<span style=color:#7d9029>delete</span>(dir);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#7d9029>out</span>.<span style=color:#7d9029>println</span>(<span style=color:#ba2121>&#34;delete dir: &#34;</span><span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>dir.<span style=color:#7d9029>toString</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>FileVisitResult.<span style=color:#7d9029>CONTINUE</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>});<span style=color:#bbb>
</span></span></span></code></pre></div><h4 id=files-与-stream>Files 与 Stream
<a class=anchor href=#files-%e4%b8%8e-stream>#</a></h4><p>在 Java 8 中，<code>Files</code> 增加了新的便于逐行处理文本文件的方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span>Stream<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#00f>lines</span>(Path<span style=color:#bbb> </span>path,Charset<span style=color:#bbb> </span>cs)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span>Stream<span style=color:#666>&lt;</span>Path<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#00f>walk</span>(Path<span style=color:#bbb> </span>start,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>maxDepth,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>FileVisitOption...<span style=color:#bbb> </span>options)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span>Stream<span style=color:#666>&lt;</span>Path<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#00f>find</span>(Path<span style=color:#bbb> </span>start,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>maxDepth,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>BiPredicate<span style=color:#666>&lt;</span>PathBasicFileAttributes<span style=color:#666>&gt;</span><span style=color:#bbb> </span>matcher,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>FileVisitOption...<span style=color:#bbb> </span>options)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>IOException<span style=color:#bbb> </span>{}<span style=color:#bbb>
</span></span></span></code></pre></div><p>在 <code>BufferedReader</code> 中也有类似的方法。</p><h3 id=文件锁>文件锁
<a class=anchor href=#%e6%96%87%e4%bb%b6%e9%94%81>#</a></h3><p>Linux 的文件锁可以从两个维度来区分：<strong>共享锁-排他锁</strong>，和<strong>劝告锁-强制锁</strong>。通常，读锁是共享的，写锁是排他的。Java 在这里使用的是劝告锁，这意味着内核并不真正禁止对文件的访问，而只是为应用程序提供一个已经上锁的状态指示。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// open with write mode, gets exclusive lock</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>RandomAccessFile<span style=color:#bbb> </span>raf<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>RandomAccessFile(<span style=color:#ba2121>&#34;usefilelocks.txt&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;rw&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>FileChannel<span style=color:#bbb> </span>fc<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>raf.<span style=color:#7d9029>getChannel</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>FileLock<span style=color:#bbb> </span>lock<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>fc.<span style=color:#7d9029>lock</span>(start,<span style=color:#bbb> </span>end,<span style=color:#bbb> </span><span style=color:green;font-weight:700>false</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>lock.<span style=color:#7d9029>release</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p>考虑到不同的 OS 可能提供不同种类的锁，为了保证安全，最好的办法是将所有锁都视为排他、劝告式的。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-nio-原理>Java NIO: 原理</a><ul><li><a href=#buffer-内部实现与包装>Buffer 内部实现与包装</a><ul><li><a href=#更多形式的-get-与-put>更多形式的 get 与 put</a></li><li><a href=#buffer-的统计方式>Buffer 的统计方式</a></li><li><a href=#类型化包装>类型化、包装</a></li><li><a href=#只读直接缓冲区内存映射>只读、直接缓冲区、内存映射</a></li></ul></li><li><a href=#nio-中的各种-channel>NIO 中的各种 Channel</a><ul><li><a href=#filechannel>FileChannel</a></li><li><a href=#asynchronousfilechannel-异步文件通道>AsynchronousFileChannel 异步文件通道</a></li><li><a href=#socketchannel>SocketChannel</a></li><li><a href=#serversocketchannel>ServerSocketChannel</a></li><li><a href=#datagramchannel>DataGramChannel</a></li><li><a href=#pipe-管道>Pipe 管道</a></li></ul></li><li><a href=#提供其他相关功能的类>提供其他相关功能的类</a><ul><li><a href=#javaniofilepath>java.nio.file.Path</a></li><li><a href=#javaniofilefiles>java.nio.file.Files</a><ul><li><a href=#对文件的操作>对文件的操作</a></li><li><a href=#filevisitor-遍历目录结构>FileVisitor 遍历目录结构</a></li><li><a href=#files-与-stream>Files 与 Stream</a></li></ul></li><li><a href=#文件锁>文件锁</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>