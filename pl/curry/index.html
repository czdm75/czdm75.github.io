<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Scala 中的柯里化、偏函数与部分应用函数 #  柯里化（Currying）、部分应用函数（Partially Applied Function）和偏函数（Partial Function）是 Scala 中三个非常容易混淆的元素。在 Groovy 中，部分应用函数也被称作了柯里化。实际上，二者的作用十分相似，思维上却有微妙的差异。
在传统面向对象方法中涉及到工厂或模板的场合，通常正是柯里化和部分应用函数发挥作用的地方。另一种常见的场合是，在一系列代码中需要为一个函数绑定某一个固定的参数。在传统方式中，我们可能会抽象一个函数出来。但在函数式范式中，我们可以直接将这个&#34;临时函数&#34;绑定在一个变量中。
概念上的区别 #  简单来说，柯里化的结果是&#34;一串函数中的下一个&#34;，而部分应用函数的结果是一个&#34;减少了参数的函数&#34;。对于函数 f(x, y, z)，其完全柯里化的结果是 f(x)(y)(z)。然后，我们将参数应用进去，例如规定 x 的值，得到的结果将是 g(y)(z)。反过来，对于部分应用函数，其结果将是 g(y, z)。
偏函数之所以会被混淆则是因为名字过于相似。偏函数的&#34;Partial&#34;意味着其只能处理其所接受的参数的一部分。这种情况常见于模式匹配。偏函数可以被连接起来，上一个函数无法处理的参数被传递至下一个函数去处理。
Groovy & Clojure #  def volume = {h, w, l -> h * w * l} def area = volume.curry(1) def lengthPartialApplied = volume.curry(1, 1) def lengthCurried = volume.curry(1).curry(1) Groovy 的这些操作实际上是部分应用而不是柯里化。不过，这两种操作毕竟是十分相似的。而且，Groovy 也允许我们返回一个函数，以进行函数的复合。
def composite = { f, g, x -> return f(g(x)) } def func = composite."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Scala: Currying, Partially Applied, Partial"><meta property="og:description" content="Scala 中的柯里化、偏函数与部分应用函数 #  柯里化（Currying）、部分应用函数（Partially Applied Function）和偏函数（Partial Function）是 Scala 中三个非常容易混淆的元素。在 Groovy 中，部分应用函数也被称作了柯里化。实际上，二者的作用十分相似，思维上却有微妙的差异。
在传统面向对象方法中涉及到工厂或模板的场合，通常正是柯里化和部分应用函数发挥作用的地方。另一种常见的场合是，在一系列代码中需要为一个函数绑定某一个固定的参数。在传统方式中，我们可能会抽象一个函数出来。但在函数式范式中，我们可以直接将这个&#34;临时函数&#34;绑定在一个变量中。
概念上的区别 #  简单来说，柯里化的结果是&#34;一串函数中的下一个&#34;，而部分应用函数的结果是一个&#34;减少了参数的函数&#34;。对于函数 f(x, y, z)，其完全柯里化的结果是 f(x)(y)(z)。然后，我们将参数应用进去，例如规定 x 的值，得到的结果将是 g(y)(z)。反过来，对于部分应用函数，其结果将是 g(y, z)。
偏函数之所以会被混淆则是因为名字过于相似。偏函数的&#34;Partial&#34;意味着其只能处理其所接受的参数的一部分。这种情况常见于模式匹配。偏函数可以被连接起来，上一个函数无法处理的参数被传递至下一个函数去处理。
Groovy & Clojure #  def volume = {h, w, l -> h * w * l} def area = volume.curry(1) def lengthPartialApplied = volume.curry(1, 1) def lengthCurried = volume.curry(1).curry(1) Groovy 的这些操作实际上是部分应用而不是柯里化。不过，这两种操作毕竟是十分相似的。而且，Groovy 也允许我们返回一个函数，以进行函数的复合。
def composite = { f, g, x -> return f(g(x)) } def func = composite."><meta property="og:type" content="article"><meta property="og:url" content="/pl/curry/"><meta property="article:section" content="pl"><title>Scala: Currying, Partially Applied, Partial | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle checked>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/ class=active>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Scala: Currying, Partially Applied, Partial</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#scala-中的柯里化偏函数与部分应用函数>Scala 中的柯里化、偏函数与部分应用函数</a><ul><li><a href=#概念上的区别>概念上的区别</a></li><li><a href=#groovy--clojure>Groovy & Clojure</a></li><li><a href=#scala>Scala</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=scala-中的柯里化偏函数与部分应用函数>Scala 中的柯里化、偏函数与部分应用函数
<a class=anchor href=#scala-%e4%b8%ad%e7%9a%84%e6%9f%af%e9%87%8c%e5%8c%96%e5%81%8f%e5%87%bd%e6%95%b0%e4%b8%8e%e9%83%a8%e5%88%86%e5%ba%94%e7%94%a8%e5%87%bd%e6%95%b0>#</a></h1><p>柯里化（Currying）、部分应用函数（Partially Applied Function）和偏函数（Partial Function）是 Scala 中三个非常容易混淆的元素。在 Groovy 中，部分应用函数也被称作了柯里化。实际上，二者的作用十分相似，思维上却有微妙的差异。</p><p>在传统面向对象方法中涉及到工厂或模板的场合，通常正是柯里化和部分应用函数发挥作用的地方。另一种常见的场合是，在一系列代码中需要为一个函数绑定某一个固定的参数。在传统方式中，我们可能会抽象一个函数出来。但在函数式范式中，我们可以直接将这个"临时函数"绑定在一个变量中。</p><h2 id=概念上的区别>概念上的区别
<a class=anchor href=#%e6%a6%82%e5%bf%b5%e4%b8%8a%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h2><p>简单来说，柯里化的结果是"一串函数中的下一个"，而部分应用函数的结果是一个"减少了参数的函数"。对于函数 <code>f(x, y, z)</code>，其完全柯里化的结果是 <code>f(x)(y)(z)</code>。然后，我们将参数应用进去，例如规定 <code>x</code> 的值，得到的结果将是 <code>g(y)(z)</code>。反过来，对于部分应用函数，其结果将是 <code>g(y, z)</code>。</p><p>偏函数之所以会被混淆则是因为名字过于相似。偏函数的"Partial"意味着其只能处理其所接受的参数的一部分。这种情况常见于模式匹配。偏函数可以被连接起来，上一个函数无法处理的参数被传递至下一个函数去处理。</p><h2 id=groovy--clojure>Groovy & Clojure
<a class=anchor href=#groovy--clojure>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=display:flex><span><span style=color:#b00040>def</span> volume <span style=color:#666>=</span> <span style=color:#666>{</span>h<span style=color:#666>,</span> w<span style=color:#666>,</span> l <span style=color:#666>-&gt;</span> h <span style=color:#666>*</span> w <span style=color:#666>*</span> l<span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#b00040>def</span> area <span style=color:#666>=</span> volume<span style=color:#666>.</span><span style=color:#7d9029>curry</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#b00040>def</span> lengthPartialApplied <span style=color:#666>=</span> volume<span style=color:#666>.</span><span style=color:#7d9029>curry</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#b00040>def</span> lengthCurried <span style=color:#666>=</span> volume<span style=color:#666>.</span><span style=color:#7d9029>curry</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>).</span><span style=color:#7d9029>curry</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>Groovy 的这些操作实际上是部分应用而不是柯里化。不过，这两种操作毕竟是十分相似的。而且，Groovy 也允许我们返回一个函数，以进行函数的复合。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-groovy data-lang=groovy><span style=display:flex><span><span style=color:#b00040>def</span> composite <span style=color:#666>=</span> <span style=color:#666>{</span> f<span style=color:#666>,</span> g<span style=color:#666>,</span> x <span style=color:#666>-&gt;</span> <span style=color:green;font-weight:700>return</span> f<span style=color:#666>(</span>g<span style=color:#666>(</span>x<span style=color:#666>))</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#b00040>def</span> func <span style=color:#666>=</span> composite<span style=color:#666>.</span><span style=color:#7d9029>curry</span><span style=color:#666>(</span>func1<span style=color:#666>,</span> func2<span style=color:#666>)</span>
</span></span></code></pre></div><p>Clojure 中的情况略微类似：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:green;font-weight:700>def </span><span style=color:#19177c>substract-from-hundred</span> (<span style=color:green>partial - </span><span style=color:#666>100</span>))
</span></span><span style=display:flex><span>(<span style=color:#00f>substract-from-hundred</span> <span style=color:#666>10</span>)     <span style=color:#408080;font-style:italic>; same as (- 100 10)    results 90</span>
</span></span><span style=display:flex><span>(<span style=color:#00f>substract-from-hundred</span> <span style=color:#666>10</span> <span style=color:#666>20</span>)  <span style=color:#408080;font-style:italic>; same as (- 100 10 20) results 70</span>
</span></span></code></pre></div><p>Clojure 原生同样只提供了部分应用。同样地，用它来实现柯里化也很容易。</p><h2 id=scala>Scala
<a class=anchor href=#scala>#</a></h2><p>Scala 通过对多个参数列表的支持提供了良好的柯里化功能：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> modN<span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> x <span style=color:#666>%</span> n <span style=color:#666>==</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>modN<span style=color:#666>(</span><span style=color:#666>5</span><span style=color:#666>)(</span><span style=color:#666>25</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// true
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#666>(</span><span style=color:#666>1</span> to <span style=color:#666>10</span><span style=color:#666>).</span>toList<span style=color:#666>.</span>filter<span style=color:#666>(</span>modN<span style=color:#666>(</span><span style=color:#666>5</span><span style=color:#666>))</span>  <span style=color:#408080;font-style:italic>// List(5, 10)
</span></span></span></code></pre></div><p>同时，Scala 也提供对部分应用的支持。针对同样的场景，可以有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> modN<span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> x <span style=color:#666>%</span> n <span style=color:#666>==</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#666>(</span><span style=color:#666>1</span> to <span style=color:#666>10</span><span style=color:#666>).</span>toList<span style=color:#666>.</span>filter<span style=color:#666>(</span>modN<span style=color:#666>(</span><span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>))</span>  <span style=color:#408080;font-style:italic>// List(5, 10)
</span></span></span></code></pre></div><p>Scala 中的偏函数实际上和另外二者关系不大，但名字使其很容易混淆。偏函数通常随着不完全的模式匹配出现。例如，集合的 <code>map</code> 和 <code>collect</code> 方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span> map <span style=color:#666>{</span><span style=color:green;font-weight:700>case</span> i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> i <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// scala.MatchError: a (of class java.lang.String)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at .$anonfun$res17$1(&lt;console&gt;:12)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at scala.collection.immutable.List.map(List.scala:286)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ... 28 elided
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span> collect <span style=color:#666>{</span><span style=color:green;font-weight:700>case</span> i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> i <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// List(2, 3)
</span></span></span></code></pre></div><p>抛出的 <code>MatchError</code> 意味着这个模式匹配无法处理 <code>String</code> 类型的对象。而在 <code>collect</code> 方法中，我们选择了将偏函数无法处理的部分直接抛弃。设计上来说，<code>map</code> 接收的参数类型为 <code>A => B</code>，<code>collect</code> 接收的参数类型为 <code>PartialFunction[A, B]</code>。<code>PartialFunction</code> Trait 提供了 <code>isDefinedAt</code> 方法来判断是否能够处理。Scala 还提供了 <code>andThen</code> <code>orElse</code> 这样的方法来将偏函数连接起来。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PartialFunction</span><span style=color:#666>[</span><span style=color:#b00040>Any</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> i <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#666>0</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> func<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PartialFunction</span><span style=color:#666>[</span><span style=color:#b00040>Int</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> i <span style=color:green;font-weight:700>if</span> i <span style=color:#666>&gt;</span> <span style=color:#666>0</span> <span style=color:green;font-weight:700>=&gt;</span> i <span style=color:#666>+</span> <span style=color:#666>1</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(-</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>1</span><span style=color:#666>)</span> map <span style=color:#666>(</span>func orElse f<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List(0, 2)
</span></span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#scala-中的柯里化偏函数与部分应用函数>Scala 中的柯里化、偏函数与部分应用函数</a><ul><li><a href=#概念上的区别>概念上的区别</a></li><li><a href=#groovy--clojure>Groovy & Clojure</a></li><li><a href=#scala>Scala</a></li></ul></li></ul></nav></div></aside></main></body></html>