<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="JVM 内存分区 #  JVM 规范中定义了五个分区：PC，栈，本地栈，堆和方法区。在这里我们还加入了方法区中的运行时常量池和不属于 JVM 管理的直接内存。
程序计数器 PC Program Counter #   线程私有 正常情况下指向运行的字节码，native 方法时为 0 JVM 规范中唯一一个未规定 OOM 的内存区域  栈 Java VM Stack #  大部分 JVM 将栈实现为可扩展的。当栈深度达到限制的最大值时，报 StackOverflowError。当已经没有内存来扩展时，报 OOM。
栈帧 #  一个栈帧代表栈中的一个方法的信息。内容包括：
 局部变量表 操作数 动态链接 方法出口  其生命周期为一个方法从调用到返回的全过程。
局部变量表 #  局部变量表保存八种基本类型的数据和对象的引用。以 slot 为单位，每个 slot 为 4 Byte。因此 double 类型占用两个 slot。
本地方法栈 Native Method Stack #  与 Java 栈类似，本地方法栈是 native 方法的栈。JVM 规范中未做强制规定，HotSpot 虚拟机将 Java 栈和本地方法栈合二为一一同进行管理。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="JVM Memory Regions"><meta property="og:description" content="JVM 内存分区 #  JVM 规范中定义了五个分区：PC，栈，本地栈，堆和方法区。在这里我们还加入了方法区中的运行时常量池和不属于 JVM 管理的直接内存。
程序计数器 PC Program Counter #   线程私有 正常情况下指向运行的字节码，native 方法时为 0 JVM 规范中唯一一个未规定 OOM 的内存区域  栈 Java VM Stack #  大部分 JVM 将栈实现为可扩展的。当栈深度达到限制的最大值时，报 StackOverflowError。当已经没有内存来扩展时，报 OOM。
栈帧 #  一个栈帧代表栈中的一个方法的信息。内容包括：
 局部变量表 操作数 动态链接 方法出口  其生命周期为一个方法从调用到返回的全过程。
局部变量表 #  局部变量表保存八种基本类型的数据和对象的引用。以 slot 为单位，每个 slot 为 4 Byte。因此 double 类型占用两个 slot。
本地方法栈 Native Method Stack #  与 Java 栈类似，本地方法栈是 native 方法的栈。JVM 规范中未做强制规定，HotSpot 虚拟机将 Java 栈和本地方法栈合二为一一同进行管理。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/in-depth-jvm/memory-region/"><meta property="article:section" content="notes"><title>JVM Memory Regions | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle checked>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/ class=active>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>JVM Memory Regions</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#jvm-内存分区>JVM 内存分区</a><ul><li><a href=#程序计数器-pc-program-counter>程序计数器 PC Program Counter</a></li><li><a href=#栈-java-vm-stack>栈 Java VM Stack</a><ul><li><a href=#栈帧>栈帧</a></li><li><a href=#局部变量表>局部变量表</a></li></ul></li><li><a href=#本地方法栈-native-method-stack>本地方法栈 Native Method Stack</a></li><li><a href=#java-堆-heap>Java 堆 Heap</a></li><li><a href=#方法区-method-area>方法区 Method Area</a></li><li><a href=#运行时常量池-runtime-constant-pool>运行时常量池 Runtime Constant Pool</a></li><li><a href=#直接内存>直接内存</a></li></ul></li><li><a href=#hotspot-的去永久代>HotSpot 的去永久代</a><ul><li><a href=#方法区的变化与永久代>方法区的变化与永久代</a></li><li><a href=#字符串常量-string-interning>字符串常量 String Interning</a><ul><li><a href=#字符串常量池>字符串常量池</a></li><li><a href=#更多实现细节>更多实现细节</a></li></ul></li></ul></li><li><a href=#对象的创建>对象的创建</a><ul><li><a href=#jvm-中对象创建的流程>JVM 中对象创建的流程</a></li><li><a href=#分配内存的细节>分配内存的细节</a><ul><li><a href=#寻找可用内存空间>寻找可用内存空间</a></li><li><a href=#多线程分配和-tlab>多线程分配和 TLAB</a></li></ul></li><li><a href=#对象初始化>对象初始化</a></li></ul></li><li><a href=#对象的内存布局和访问>对象的内存布局和访问</a><ul><li><a href=#对象头>对象头</a></li><li><a href=#实例变量和-padding>实例变量和 Padding</a></li><li><a href=#访问对象的方法>访问对象的方法</a><ul><li><a href=#句柄访问>句柄访问</a></li><li><a href=#直接指针访问>直接指针访问</a></li></ul></li></ul></li><li><a href=#制造-oom>制造 OOM</a><ul><li><a href=#堆溢出>堆溢出</a></li><li><a href=#栈溢出>栈溢出</a></li><li><a href=#方法区溢出>方法区溢出</a></li><li><a href=#直接内存溢出>直接内存溢出</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=jvm-内存分区>JVM 内存分区
<a class=anchor href=#jvm-%e5%86%85%e5%ad%98%e5%88%86%e5%8c%ba>#</a></h1><p>JVM 规范中定义了五个分区：PC，栈，本地栈，堆和方法区。在这里我们还加入了方法区中的运行时常量池和不属于 JVM 管理的直接内存。</p><h2 id=程序计数器-pc-program-counter>程序计数器 PC Program Counter
<a class=anchor href=#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8-pc-program-counter>#</a></h2><ul><li>线程私有</li><li>正常情况下指向运行的字节码，native 方法时为 0</li><li>JVM 规范中唯一一个未规定 OOM 的内存区域</li></ul><h2 id=栈-java-vm-stack>栈 Java VM Stack
<a class=anchor href=#%e6%a0%88-java-vm-stack>#</a></h2><p>大部分 JVM 将栈实现为可扩展的。当栈深度达到限制的最大值时，报 StackOverflowError。当已经没有内存来扩展时，报 OOM。</p><h3 id=栈帧>栈帧
<a class=anchor href=#%e6%a0%88%e5%b8%a7>#</a></h3><p>一个栈帧代表栈中的一个方法的信息。内容包括：</p><ul><li>局部变量表</li><li>操作数</li><li>动态链接</li><li>方法出口</li></ul><p>其生命周期为一个方法从调用到返回的全过程。</p><h3 id=局部变量表>局部变量表
<a class=anchor href=#%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e8%a1%a8>#</a></h3><p>局部变量表保存八种基本类型的数据和对象的引用。以 slot 为单位，每个 slot 为 4 Byte。因此 double 类型占用两个 slot。</p><h2 id=本地方法栈-native-method-stack>本地方法栈 Native Method Stack
<a class=anchor href=#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88-native-method-stack>#</a></h2><p>与 Java 栈类似，本地方法栈是 native 方法的栈。JVM 规范中未做强制规定，HotSpot 虚拟机将 Java 栈和本地方法栈合二为一一同进行管理。</p><h2 id=java-堆-heap>Java 堆 Heap
<a class=anchor href=#java-%e5%a0%86-heap>#</a></h2><p>Java 堆是我们最熟悉的内存区域，这个区域是在各个线程间共享的，将发生 GC 等过程。原则上，所有的对象都会被分配在这里。随着逃逸分析和 JIT 等技术的成熟以及栈上分配和标量替换等技术的广泛应用，有些对象不一定被分配在堆里。</p><p>在堆内部，可以根据 GC 算法分为新生代和老生代，而新生代更加细致地划分为 Eden 空间，From Survivor 空间和 To Survivor 空间等。从内存分配的角度来看，可能划分出多个 Thread Local Allocate Buffer（TLAB）等。当然，这些分区并没有实质上的区别，划分的目的是进行不同策略的 GC。</p><h2 id=方法区-method-area>方法区 Method Area
<a class=anchor href=#%e6%96%b9%e6%b3%95%e5%8c%ba-method-area>#</a></h2><p>各个线程共享的内存区域，用于存储 Class Loader 加载的：</p><ul><li>类信息</li><li>常量</li><li>静态变量</li><li>JIT 编译后的代码</li></ul><p>等内容。也被称为非堆（Non-Heap）。</p><p>在 Hotspot 早先的版本，方法区与字符串常量池（Interned Strings）一起被实现为堆的 &ldquo;永久代&rdquo;。</p><h2 id=运行时常量池-runtime-constant-pool>运行时常量池 Runtime Constant Pool
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0-runtime-constant-pool>#</a></h2><p>运行时常量池是方法区的一部分，用来存储 Class 文件中定义的各种字面量和符号引用等。在旧版本中，字符串常量池就是一个典型的例子，说明我们可以在运行时向这个常量池动态地添加对象。</p><h2 id=直接内存>直接内存
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98>#</a></h2><p>直接内存，顾名思义就是跳过 JVM 直接在系统内存中进行管理的区域。典型的例子是 Java 1.4 中引入的 NIO 中的 Buffer。通过 native 方法实现，将 Buffer 直接实现在系统中，能够避免在系统内存与 JVM 进程内存之间反复进行拷贝。显然，这个区域不会受到 JVM 参数的影响。当然，当整个系统的内存不足时，同样会发生 OOM。</p><h1 id=hotspot-的去永久代>HotSpot 的去永久代
<a class=anchor href=#hotspot-%e7%9a%84%e5%8e%bb%e6%b0%b8%e4%b9%85%e4%bb%a3>#</a></h1><h2 id=方法区的变化与永久代>方法区的变化与永久代
<a class=anchor href=#%e6%96%b9%e6%b3%95%e5%8c%ba%e7%9a%84%e5%8f%98%e5%8c%96%e4%b8%8e%e6%b0%b8%e4%b9%85%e4%bb%a3>#</a></h2><p>永久代事实上是旧版本 Oracle JDK / OpenJDK 对 JVM 规范中<strong>方法区</strong>的一种实现。在 HotSpot 中，如果永久代发生了内存不足，则会触发 Full GC 以回收常量和加载的类，而 Full GC 通常是我们十分不想见到的。而且，对类进行卸载和回收的条件相当苛刻，再加上字符串常量池的大小，也导致这个位置的 OOM 仍然十分常见。</p><ul><li>JDK 6 中，方法区的 JIT 编译后代码被储存在 native 内存的 JVM-codeCache 部分，其余均为永久代</li><li>JDK 7 中，Symbol 的存储移动到了 native 内存，静态变量移动到了 <code>java.lang.Class</code> 对象的末尾，位于堆中。</li><li>JDK 8 中，彻底移除了永久代，将整个方法区转移到元空间 Metaspace。（<code>-XX:MaxMetaspaceSize</code>）这个区域位于 Native Heap 中，因此几乎没有容量的限制，除了 JVM 参数。</li></ul><h2 id=字符串常量-string-interning>字符串常量 String Interning
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f-string-interning>#</a></h2><h3 id=字符串常量池>字符串常量池
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%b8%b8%e9%87%8f%e6%b1%a0>#</a></h3><p>JDK 为八种基本类型和 <code>String</code> 提供了常量池。其中，字符串常量池在 JDK 7 中被从永久代移除。字符串进入常量池的方式有两种：</p><ul><li>使用双引号声明字符串</li><li>使用 <code>String::intern</code> 方法</li></ul><p>其核心思想是，对于可能多次使用的字符串，将它们的引用指向同一个位于常量池中的字符串，以避免重复分配对象。</p><p>在 native 部分，字符串常量池实际上是一个固定长度、使用拉链法的 HashMap。因此，当字符串常量数量超过了 Map 容量之后之后，性能就会开始下降。JDK 7u40 之前，这个值是 1009，之后提高到了 60013，基本上能够满足我们的需求。可以使用 <code>-XX:StringTableSize</code> 参数来调整。与一般的 HashMap 一样，容量达到存入数据的两倍时能够比较好地避免碰撞。</p><h3 id=更多实现细节>更多实现细节
<a class=anchor href=#%e6%9b%b4%e5%a4%9a%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82>#</a></h3><p>在 JDK 6 和 JDK 7 下分别执行同一段代码:</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span> <span style=color:#00f>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    String s <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> String<span style=color:#666>(</span><span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    s<span style=color:#666>.</span><span style=color:#7d9029>intern</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    String s2 <span style=color:#666>=</span> <span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>s <span style=color:#666>==</span> s2<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String s3 <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> String<span style=color:#666>(</span><span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>)</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>new</span> String<span style=color:#666>(</span><span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    s3<span style=color:#666>.</span><span style=color:#7d9029>intern</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    String s4 <span style=color:#666>=</span> <span style=color:#ba2121>&#34;11&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>s3 <span style=color:#666>==</span> s4<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    String s5 <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> String<span style=color:#666>(</span><span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>)</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>new</span> String<span style=color:#666>(</span><span style=color:#ba2121>&#34;1&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    String s6 <span style=color:#666>=</span> <span style=color:#ba2121>&#34;11&#34;</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    s5<span style=color:#666>.</span><span style=color:#7d9029>intern</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>s5 <span style=color:#666>==</span> s6<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>结果分别为 <code>false false false</code> 和 <code>false true false</code>。在这里，我们就能一定程度上看到 JDK6 和 JDK 7 中实现的区别。</p><p>从第一段代码开始。首先，我们知道的是，所有双引号声明的字符串都会在常量池中生成，而 <code>new</code> 操作符得到的对象则被分配在堆中。然后，当我们调用 <code>intern</code> 方法时，字符串将会被放在常量池中。问题是，当前我们使用的这个引用呢？</p><p>实际上，这时我们 <code>new</code> 得到的 <code>String</code> 对象仍然存在，其位置位于一般的 Java 堆中。只是，其内容指向了常量池，即 JDK 6 中的永久代位置，或后来的堆中的常量池部分。相比之下，我们直接使用双引号声明的 <code>s2</code> 则是直接指向常量池中的对象。第三段代码也是同样的情况。</p><p>那么，在第二段代码中，JDK 6 和 7 有什么区别呢？因为我们知道，JDK 7 之后。常量池已经被从永久代移到了一般的堆中，这意味着我们完全可以不再存储一个对象，而是直接在常量池中存储一个引用，这个引用和 <code>s3</code> 指向同一个对象。也就是说，常量池中存储的是一个指向 Java Heap 中某个对象的引用。</p><p>而到了第三段代码，执行顺序的变化也导致了对象引用关系的变化。当然，Java 语言规范并没有规定 <code>==</code> 符号在对象上的关系。使用 <code>equals</code> 仍然是合适的做法。下面的图分别展示了 JDK 6 和 JDK 7 中的情况</p><p><img src=../string-intern.png alt="String Intern"></p><h1 id=对象的创建>对象的创建
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%88%9b%e5%bb%ba>#</a></h1><h2 id=jvm-中对象创建的流程>JVM 中对象创建的流程
<a class=anchor href=#jvm-%e4%b8%ad%e5%af%b9%e8%b1%a1%e5%88%9b%e5%bb%ba%e7%9a%84%e6%b5%81%e7%a8%8b>#</a></h2><ol><li>判断是否需要类加载</li><li>分配内存</li><li>初始化为全 0</li><li>设置对象头</li><li>执行 <code>&lt;init></code></li></ol><h2 id=分配内存的细节>分配内存的细节
<a class=anchor href=#%e5%88%86%e9%85%8d%e5%86%85%e5%ad%98%e7%9a%84%e7%bb%86%e8%8a%82>#</a></h2><h3 id=寻找可用内存空间>寻找可用内存空间
<a class=anchor href=#%e5%af%bb%e6%89%be%e5%8f%af%e7%94%a8%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4>#</a></h3><p>首先要考虑的是对象是否需要使用连续的内存空间。在 HotSpot 中，对象的空间始终是连续的。因此，当内存碎片和大对象的创建同时出现时，就可能需要很多的 GC 来移动对象腾出整块的空间。在 IBM J9 等 JVM 中可以使用不连续的空间，但相应地会提高性能代价。</p><p>当使用带有 Compact 的 GC 器，即已用内存是连续的时，只需要维护一个指向已用与未使用部分分界线的指针并进行移动即可。这种方式叫做 Bump the Pointer。相应地，如果内存不连续，就需要使用 Free List 来寻找。</p><h3 id=多线程分配和-tlab>多线程分配和 TLAB
<a class=anchor href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b%e5%88%86%e9%85%8d%e5%92%8c-tlab>#</a></h3><p>创建对象在虚拟机中是非常频繁的行为，因此线程冲突是十分常见的。有可能一个线程在指针位置创建一个对象时，同时另一个线程又使用了这个指针。解决这个问题的方案有两种，一种是通过 CAS 和失败重试等方式来保证更新操作的原子性，另一种是使用 TLAB（Thread Local Allocation Buffer）。</p><p>TLAB 位于 Java 堆的 Eden 区（复制 GC 算法中允许分配新对象的区域）中，为每个线程分配一个。每个线程在创建对象时，只能在自己的 TLAB 中进行分配。这样，就从根源上避免了线程之间的分配冲突。TLAB 并不需要太大，用尽之后还可以继续分配新的区域。当然，分配新的 TLAB 需要进行线程间的同步，避免多个线程分配到同一个区域。这个特性可以通过 <code>-XX:-UseTLAB</code> 来设置。</p><h2 id=对象初始化>对象初始化
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e5%88%9d%e5%a7%8b%e5%8c%96>#</a></h2><p>首先，JVM 需要将对象的所有位都设置为 0，这也是基本类型的默认值的来源。如果使用 TLAB，这个步骤也可以提前到 TLAB 的分配。</p><p>对象头的主要内容包括对象所属的类、类的部分信息、对象的 HashCode、GC 年龄和锁的信息等。</p><p>然后，JVM 会调用 <code>&lt;init></code> 方法。这个方法会在任何形式的对象创建时被调用，包括 <code>new</code>、反序列化、反射或 <code>clone()</code>，其主要作用是按照类编写者的意愿对对象的实例变量进行初始化。类似的是针对静态变量等进行初始化的 <code>&lt;cinit></code> 方法。</p><p>具体来说，<code>&lt;init></code> 方法是被字节码中的 <code>invokespecial</code> 指令来调用，这个指令也被用在 <code>super</code> 关键字和私有方法的调用中。例如，<code>new StringBuffer</code> ：</p><pre tabindex=0><code class=language-bytecode data-lang=bytecode>new java/lang/StringBuffer         ; create a new StringBuffer
dup                                ; make an extra reference to the new instance
                                   ; now call an instance initialization method
invokespecial java/lang/StringBuffer/&lt;init&gt;()V
                                   ; stack now contains an initialized StringBuffer.
</code></pre><p>在 <code>super</code> 关键字的应用中，例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:#b00040>boolean</span> <span style=color:#00f>equals</span><span style=color:#666>(</span>Object x<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>     <span style=color:green;font-weight:700>return</span> <span style=color:green;font-weight:700>super</span><span style=color:#666>.</span><span style=color:#7d9029>equals</span><span style=color:#666>(</span>x<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>则会得到：</p><pre tabindex=0><code class=language-bytecode data-lang=bytecode>aload_0  ; push &#39;this&#39; onto the stack
aload_1  ; push the first argument (i.e. x) onto the stack
         ; now invoke Object&#39;s equals() method.
invokespecial java/lang/Object/equals(Ljava/lang/Object;)Z
</code></pre><h1 id=对象的内存布局和访问>对象的内存布局和访问
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e7%9a%84%e5%86%85%e5%ad%98%e5%b8%83%e5%b1%80%e5%92%8c%e8%ae%bf%e9%97%ae>#</a></h1><p>对于 HotSpot 这种使用连续内存分配对象的虚拟机，对象的内存布局比较简单，可以分为对象头、实例数据和 Padding 三部分。</p><h2 id=对象头>对象头
<a class=anchor href=#%e5%af%b9%e8%b1%a1%e5%a4%b4>#</a></h2><p>对象头（Object Header）结构：</p><table><thead><tr><th>长度（32bit JVM 中）</th><th>内容</th><th>作用</th></tr></thead><tbody><tr><td>1字宽（32bit）</td><td>Mark Word</td><td>与锁有关</td></tr><tr><td>1字宽</td><td>Class Metadata Address</td><td>对象所属类型的指针</td></tr><tr><td>1字宽（仅数组）</td><td>Array Length</td><td>数组长度</td></tr></tbody></table><p>对象 Mark Word 的内容：</p><table><thead><tr><th>锁状态</th><th>23bit</th><th>2bit</th><th>4bit</th><th>1bit（是否为偏向锁）</th><th>2bit（锁状态）</th></tr></thead><tbody><tr><td>GC 标记</td><td>空</td><td>空</td><td>空</td><td>空</td><td>11</td></tr><tr><td>无锁</td><td>对象hashCode（25bit）</td><td>hashCode</td><td>对象分代年龄</td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程id</td><td>Epoch</td><td>对象分代年龄</td><td>1</td><td>01</td></tr><tr><td>轻量级锁</td><td>指向栈中锁记录的指针（30bit）</td><td>指针</td><td>指针</td><td>指针</td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量的指针（30bit）</td><td>指针</td><td>指针</td><td>指针</td><td>10</td></tr></tbody></table><p>数组类型多出一个数组长度域的原因是，VM 可以从对象的类型直接推断出对象的长度，却无法推断出数组的长度。此外，也不是所有的虚拟机都使用类型指针来指示类的信息。在 64 bit 的 JVM 下，除了字段的长度，还要考虑是否使用了指针压缩等技术。</p><h2 id=实例变量和-padding>实例变量和 Padding
<a class=anchor href=#%e5%ae%9e%e4%be%8b%e5%8f%98%e9%87%8f%e5%92%8c-padding>#</a></h2><p>接下来是实例变量的存储。通常，虚拟机选择将相同长度的数据（如 long 和 double，short 和 char）存放到一起，以避免内存空间的浪费。在这个前提之下，父类的实例变量会被存储在子类变量之前。如果开启了 <code>CompactFields</code>（默认启用）参数，则还可能将较短的变量插入到较长的变量之间的空隙。</p><p>总之，实例变量部分的策略和 Padding 部分的存在都是为了进行内存空间的对齐。JVM 中，对象的起始位置是以 8 Byte 为单位进行对齐的。不足的部分就需要 空白的 Padding 来填充。</p><h2 id=访问对象的方法>访问对象的方法
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h2><p>JVM 规范中只规定了对象指向引用，而没有规定通过引用寻找对象的具体方法。引用寻址的实现主要有两种：</p><h3 id=句柄访问>句柄访问
<a class=anchor href=#%e5%8f%a5%e6%9f%84%e8%ae%bf%e9%97%ae>#</a></h3><p>这种方式在 Java 堆中划分了另外一个部分作为句柄池。句柄池中的每一条记录包括指向堆中对象实例的指针和指向方法区中类型数据的指针。这种方法的优势是，在堆中移动对象的实际位置（GC 时十分常见）时，只需要修改句柄中的指针，而不需要回到栈上修改每一个引用的指针。</p><h3 id=直接指针访问>直接指针访问
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e6%8c%87%e9%92%88%e8%ae%bf%e9%97%ae>#</a></h3><p>直接指针访问时，引用直接指向堆中的对象本身，对象内部包含指向方法区中类型数据的指针。这种方式的显著优势就是节省了一次寻址，鉴于对象访问十分频繁，这个优势也是十分可观的。我们前面在对象头中看到的类型数据指针就是这样的实现。</p><p><img src=../mem-obj-ref.png alt="Memory Object Reference"></p><h1 id=制造-oom>制造 OOM
<a class=anchor href=#%e5%88%b6%e9%80%a0-oom>#</a></h1><h2 id=堆溢出>堆溢出
<a class=anchor href=#%e5%a0%86%e6%ba%a2%e5%87%ba>#</a></h2><p>堆溢出是最容易产生的异常，只要不停地创建"活着"的对象即可。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// VM Args: -XX:MaxHeapSize=8M / -Xmx8m
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// VM Args: -XX:InitialHeapSize=8M / -Xms8m
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// VM Args: -XX:MaxNewSize=4M / -Xmn4m
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// -XX:+HeapDumpOnOutOfMemoryError
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span> <span style=color:#00f>main</span><span style=color:#666>(</span>String args<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    List<span style=color:#666>&lt;</span><span style=color:#b00040>int</span><span style=color:#666>[]&gt;</span> list <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> ArrayList<span style=color:#666>&lt;&gt;();</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span><span style=color:#666>(</span><span style=color:green;font-weight:700>true</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        list<span style=color:#666>.</span><span style=color:#7d9029>add</span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#b00040>int</span><span style=color:#666>[</span>100000<span style=color:#666>]);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>通过 Heap Dump，可以查找对象的 GC Root，以排查内存泄漏的原因。否则，就要通过调整参数来避免。</p><h2 id=栈溢出>栈溢出
<a class=anchor href=#%e6%a0%88%e6%ba%a2%e5%87%ba>#</a></h2><p>在 HotSpot 中并不区分虚拟机栈和本地方法栈。栈部分的溢出有两种形式，<code>StackOverflow</code> 和 <code>OutOfMemory</code>。对于爆栈，只需要进行大量的递归即可。相关的参数为 <code>-Xss128k</code>，等价于 <code>-XX:ThreadStackSize=128k</code>。当每个栈帧的本地变量表较大时，爆栈时栈的深度相应就更小。</p><p>在单线程情况下，无论栈帧太大还是栈内存不足，抛出的都是 <code>StackOverflowError</code>。通常这个深度能够达到 1000 ~ 2000 的级别。OOM 则是出现在创建大量线程的情形，不过这时并不是栈的内存不足，而是无法再分配一个新的栈。</p><h2 id=方法区溢出>方法区溢出
<a class=anchor href=#%e6%96%b9%e6%b3%95%e5%8c%ba%e6%ba%a2%e5%87%ba>#</a></h2><p>前面我们知道，JDK 6 之前的永久代溢出是常见的，只需要通过大量的 <code>String.intern</code>，就能够让字符串常量池产生 OOM。而在 JDK 7 中，常量池转移到了堆中，且只保存一些引用，因此无法再发生这类 OOM。</p><p>另一种方法区 OOM 的可能性是加载大量的类。这种情况除了加载 ClassPath 中的类之外，还可能是加载大量的 JSP、反射机制的 <code>GeneratedConstructorAccessor</code>、动态代理、OSGi 或 CGLib 操作字节码等方式。无论如何，在 Hibernate、Spring 等框架中，这类情况并不少见。</p><p>在 JDK 8 中，随着"去永久代"，与之相关的参数变成了 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>。而在之前的版本中是 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>。其中前一个参数都是初始大小。JDK 8 中，默认将 Metaspace 的最大值设为了系统内存，因此不会发生溢出的情况。不过，默认的初始值比较小，扩展的过程会带来一些额外的 GC。</p><h2 id=直接内存溢出>直接内存溢出
<a class=anchor href=#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98%e6%ba%a2%e5%87%ba>#</a></h2><p>直接内存溢出只有两种可能，使用 Unsafe 方法或使用 NIO 的 <code>DirectByteBuffer</code>。</p><p>不过，JDK 的作者为此进行了一定的保护：<code>DirectByteBuffer</code> 并没有真的向系统申请内存。它只是发现内存不足以分配，于是手动抛出了异常。另一种方式 Unsafe 方法则要求只有 Bootstrap CLassLoader 加载的类的调用才能返回实例&mdash;&mdash;也就是说只希望 JDK 提供的类来访问。我们可以通过反射来绕过这个规定，当然，并不推荐这样做。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span> <span style=color:#00f>main</span><span style=color:#666>(</span>String<span style=color:#666>[]</span> args<span style=color:#666>)</span> <span style=color:green;font-weight:700>throws</span> Excecption <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    Field unsafeField <span style=color:#666>=</span> Unsafe<span style=color:#666>.</span><span style=color:#7d9029>class</span><span style=color:#666>.</span><span style=color:#7d9029>getDeclaredFields</span><span style=color:#666>()[</span>0<span style=color:#666>];</span>
</span></span><span style=display:flex><span>    unsafeField<span style=color:#666>.</span><span style=color:#7d9029>setAccessible</span><span style=color:#666>(</span><span style=color:green;font-weight:700>true</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    Unsafe unsafe <span style=color:#666>=</span> <span style=color:#666>(</span>Unsafe<span style=color:#666>)</span> unsafeField<span style=color:#666>.</span><span style=color:#7d9029>get</span><span style=color:#666>(</span><span style=color:green;font-weight:700>null</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span><span style=color:#666>(</span><span style=color:green;font-weight:700>true</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        unsafe<span style=color:#666>.</span><span style=color:#7d9029>allocateMemory</span><span style=color:#666>(</span>1024 <span style=color:#666>*</span> 1024<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>直接内存的 OOM 的特征是，不会在堆 Dump 中发现异常，因此，如果使用了 NIO，就要把这个因素考虑在内。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#jvm-内存分区>JVM 内存分区</a><ul><li><a href=#程序计数器-pc-program-counter>程序计数器 PC Program Counter</a></li><li><a href=#栈-java-vm-stack>栈 Java VM Stack</a><ul><li><a href=#栈帧>栈帧</a></li><li><a href=#局部变量表>局部变量表</a></li></ul></li><li><a href=#本地方法栈-native-method-stack>本地方法栈 Native Method Stack</a></li><li><a href=#java-堆-heap>Java 堆 Heap</a></li><li><a href=#方法区-method-area>方法区 Method Area</a></li><li><a href=#运行时常量池-runtime-constant-pool>运行时常量池 Runtime Constant Pool</a></li><li><a href=#直接内存>直接内存</a></li></ul></li><li><a href=#hotspot-的去永久代>HotSpot 的去永久代</a><ul><li><a href=#方法区的变化与永久代>方法区的变化与永久代</a></li><li><a href=#字符串常量-string-interning>字符串常量 String Interning</a><ul><li><a href=#字符串常量池>字符串常量池</a></li><li><a href=#更多实现细节>更多实现细节</a></li></ul></li></ul></li><li><a href=#对象的创建>对象的创建</a><ul><li><a href=#jvm-中对象创建的流程>JVM 中对象创建的流程</a></li><li><a href=#分配内存的细节>分配内存的细节</a><ul><li><a href=#寻找可用内存空间>寻找可用内存空间</a></li><li><a href=#多线程分配和-tlab>多线程分配和 TLAB</a></li></ul></li><li><a href=#对象初始化>对象初始化</a></li></ul></li><li><a href=#对象的内存布局和访问>对象的内存布局和访问</a><ul><li><a href=#对象头>对象头</a></li><li><a href=#实例变量和-padding>实例变量和 Padding</a></li><li><a href=#访问对象的方法>访问对象的方法</a><ul><li><a href=#句柄访问>句柄访问</a></li><li><a href=#直接指针访问>直接指针访问</a></li></ul></li></ul></li><li><a href=#制造-oom>制造 OOM</a><ul><li><a href=#堆溢出>堆溢出</a></li><li><a href=#栈溢出>栈溢出</a></li><li><a href=#方法区溢出>方法区溢出</a></li><li><a href=#直接内存溢出>直接内存溢出</a></li></ul></li></ul></nav></div></aside></main></body></html>