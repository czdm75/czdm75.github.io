<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Java 中的线程同步 #  Java 中的 synchronized 关键字 #  对函数使用 synchronized 关键字时，如果是静态函数，相当于 synchronized(this.class) 代码块。反之，则相当于 synchronized(this) 代码块。
synchronized 代码块只能锁住对象。最经济的锁对象是 byte[0]，只需要三条字节码，比 new Object() 更少。锁住一个 static 变量，实际上相当于锁住一个类。锁住的对象必须是 private 的。否则，引用所指向的对象将能够被外部修改，破坏同步。
public class Synchronize {  private String name;  private static final byte[] sb = new byte[0];  private final byte[] b = new byte[0];  private Synchronize(String name) {  this.name = name;  }  public static void print(String s) {  System."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Java Synchronization"><meta property="og:description" content="Java 中的线程同步 #  Java 中的 synchronized 关键字 #  对函数使用 synchronized 关键字时，如果是静态函数，相当于 synchronized(this.class) 代码块。反之，则相当于 synchronized(this) 代码块。
synchronized 代码块只能锁住对象。最经济的锁对象是 byte[0]，只需要三条字节码，比 new Object() 更少。锁住一个 static 变量，实际上相当于锁住一个类。锁住的对象必须是 private 的。否则，引用所指向的对象将能够被外部修改，破坏同步。
public class Synchronize {  private String name;  private static final byte[] sb = new byte[0];  private final byte[] b = new byte[0];  private Synchronize(String name) {  this.name = name;  }  public static void print(String s) {  System."><meta property="og:type" content="article"><meta property="og:url" content="/notes/in-depth-jvm/synchronization/"><meta property="article:section" content="notes"><title>Java Synchronization | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle checked>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/ class=active>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Java Synchronization</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#java-中的线程同步>Java 中的线程同步</a><ul><li><a href=#java-中的-synchronized-关键字>Java 中的 synchronized 关键字</a></li><li><a href=#轻量级锁和偏向锁>轻量级锁和偏向锁</a></li><li><a href=#轻量级锁>轻量级锁</a><ul><li><a href=#加锁>加锁</a></li><li><a href=#解锁>解锁</a></li></ul></li><li><a href=#偏向锁>偏向锁</a><ul><li><a href=#获取>获取</a></li><li><a href=#撤销>撤销</a></li></ul></li><li><a href=#其他优化>其他优化</a><ul><li><a href=#适应性自旋adaptive-spinning>适应性自旋（Adaptive Spinning）</a></li><li><a href=#锁粗化lock-coarsening>锁粗化（Lock Coarsening）</a></li><li><a href=#锁消除lock-elimination>锁消除（Lock Elimination）</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=java-中的线程同步>Java 中的线程同步
<a class=anchor href=#java-%e4%b8%ad%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%90%8c%e6%ad%a5>#</a></h1><h2 id=java-中的-synchronized-关键字>Java 中的 synchronized 关键字
<a class=anchor href=#java-%e4%b8%ad%e7%9a%84-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97>#</a></h2><p>对函数使用 <code>synchronized</code> 关键字时，如果是静态函数，相当于 <code>synchronized(this.class)</code> 代码块。反之，则相当于 <code>synchronized(this)</code> 代码块。</p><p><code>synchronized</code> 代码块只能锁住对象。最经济的锁对象是 <code>byte[0]</code>，只需要三条字节码，比 <code>new Object()</code> 更少。锁住一个 static 变量，实际上相当于锁住一个类。锁住的对象必须是 private 的。否则，引用所指向的对象将能够被外部修改，破坏同步。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Synchronize</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> String name<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>static</span> <span style=color:green;font-weight:700>final</span> <span style=color:#b00040>byte</span><span style=color:#666>[]</span> sb <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#b00040>byte</span><span style=color:#666>[</span>0<span style=color:#666>];</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>final</span> <span style=color:#b00040>byte</span><span style=color:#666>[]</span> b <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#b00040>byte</span><span style=color:#666>[</span>0<span style=color:#666>];</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> <span style=color:#00f>Synchronize</span><span style=color:#666>(</span>String name<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>this</span><span style=color:#666>.</span><span style=color:#7d9029>name</span> <span style=color:#666>=</span> name<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span> <span style=color:#00f>print</span><span style=color:#666>(</span>String s<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;start&#34;</span> <span style=color:#666>+</span> s<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            Thread<span style=color:#666>.</span><span style=color:#7d9029>sleep</span><span style=color:#666>(</span>1000<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span> <span style=color:green;font-weight:700>catch</span> <span style=color:#666>(</span>InterruptedException e<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>        System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;stop&#34;</span> <span style=color:#666>+</span> s<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>void</span> <span style=color:#00f>syncStatic</span><span style=color:#666>()</span> <span style=color:#666>{</span><span style=color:#408080;font-style:italic>//锁住一个静态变量
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        <span style=color:green;font-weight:700>synchronized</span> <span style=color:#666>(</span>sb<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            print<span style=color:#666>(</span>name<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>void</span> <span style=color:#00f>syncMember</span><span style=color:#666>()</span> <span style=color:#666>{</span><span style=color:#408080;font-style:italic>//锁住一个实例变量
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        <span style=color:green;font-weight:700>synchronized</span> <span style=color:#666>(</span>b<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            print<span style=color:#666>(</span>name<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:green;font-weight:700>synchronized</span> <span style=color:#b00040>void</span> <span style=color:#00f>syncClass</span><span style=color:#666>()</span> <span style=color:#666>{</span><span style=color:#408080;font-style:italic>//锁住整个类
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        print<span style=color:#666>(</span><span style=color:#ba2121>&#34;static&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>synchronized</span> <span style=color:#b00040>void</span> <span style=color:#00f>syncObject</span><span style=color:#666>()</span> <span style=color:#666>{</span><span style=color:#408080;font-style:italic>//锁住对象
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        print<span style=color:#666>(</span>name<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>在字节码的实现中，方法的同步和代码块的同步采用了不同的两种方式：</p><pre tabindex=0><code class=language-bytecode data-lang=bytecode>  public void syncMember();
    descriptor: ()V
    flags: (0x0001) ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         5: astore_1
         6: monitorenter                      //!!!获得对象b的monitor锁
         7: aload_0
        14: aload_1
        15: monitorexit                       //!!!释放对象b的monitor锁
        16: goto          24

  public static synchronized void syncClass();
    descriptor: ()V
    flags: (0x0029) ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED
    //!!!常量池中增加了ACC__SYNCHRONIZED常量，同步工作由JVM完成
    Code:
      stack=1, locals=0, args_size=0
         0: ldc           #6                  // String static
         2: invokestatic  #5                  // Method print:(Ljava/lang/String;)V
         5: return
      LineNumberTable:
        line 21: 0
        line 22: 5
</code></pre><h2 id=轻量级锁和偏向锁>轻量级锁和偏向锁
<a class=anchor href=#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81%e5%92%8c%e5%81%8f%e5%90%91%e9%94%81>#</a></h2><p><code>synchronized</code> 关键字实现的锁通过对象的 monitor 锁调用<strong>操作系统的 mutex 锁</strong>，执行过程中需要在内核态与用户态之间切换，因此这种方式的开销比较大，被称为重量级锁。JDK1.6 之后，引入了轻量级锁和偏向锁。</p><p>锁可以从低级向高级膨胀，不能反向转化。轻量级锁适用于<strong>两个线程交替执行而不冲突</strong>的情况，此时轻量级锁可以节省性能损耗。当两个线程同时访问锁（两个线程"相撞"时），轻量级锁膨胀为重量级锁，以处理同步过程。此后锁不能再变回来。</p><p>偏向锁适合<strong>只有一个线程正在运行</strong>的情况，可以进一步减少同步成本的消耗。偏向锁认为只有自己一个线程正在执行，因此直到竞争出现或者执行完成才释放锁。偏向锁可以膨胀为轻量级锁。</p><p>这种处理锁的方式方式被称为乐观锁：发生碰撞后再进行处理。相应的，重量级锁属于悲观锁：无论如何，都要进行同步处理。</p><h2 id=轻量级锁>轻量级锁
<a class=anchor href=#%e8%bd%bb%e9%87%8f%e7%ba%a7%e9%94%81>#</a></h2><h3 id=加锁>加锁
<a class=anchor href=#%e5%8a%a0%e9%94%81>#</a></h3><ol><li><p>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为"01"状态，是否为偏向锁为"0"），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间。</p></li><li><p>拷贝对象头中的 Mark Word 复制到锁记录中。</p></li><li><p>拷贝成功后，虚拟机将使用 CAS 操作（Compare And Swap）尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock record 里的 owner 指针指向对象 Mark Word。</p></li><li><p>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为"00"，即表示此对象处于轻量级锁定状态。</p><p>即：此时栈中有一个 Lock Record 段，其由两个部分组成：</p><ul><li>owner 指针，指向被锁的对象</li><li>从对象拷贝而来的 Mark Word，即内容为hashcode-age-01的段。与此同时，对象头部的 Mark Word 内容为一个 30bit 的指向此位置的指针，及锁标记位00.</li></ul></li><li><p>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧：</p><p>如果是，就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。</p><p>否则，说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为"10"，Mark Word中存储的变成指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。而当前线程便尝试使用自旋来获取锁。</p></li></ol><h3 id=解锁>解锁
<a class=anchor href=#%e8%a7%a3%e9%94%81>#</a></h3><p>再次使用 CAS 操作将 Displaced Mark Word 换回，如果失败，则说明锁已经膨胀为重量级锁。</p><h2 id=偏向锁>偏向锁
<a class=anchor href=#%e5%81%8f%e5%90%91%e9%94%81>#</a></h2><p>JVM 用一个 epoch 表示一个偏向锁的时间戳。</p><h3 id=获取>获取
<a class=anchor href=#%e8%8e%b7%e5%8f%96>#</a></h3><p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要花费CAS操作来加锁和解锁，而只需简单的测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁，如果测试成功，表示线程已经获得了锁，如果测试失败，则需要再测试下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁），如果没有设置，则使用CAS竞争锁，如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><h3 id=撤销>撤销
<a class=anchor href=#%e6%92%a4%e9%94%80>#</a></h3><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态，如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word，要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</p><h2 id=其他优化>其他优化
<a class=anchor href=#%e5%85%b6%e4%bb%96%e4%bc%98%e5%8c%96>#</a></h2><h3 id=适应性自旋adaptive-spinning>适应性自旋（Adaptive Spinning）
<a class=anchor href=#%e9%80%82%e5%ba%94%e6%80%a7%e8%87%aa%e6%97%8badaptive-spinning>#</a></h3><p>当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。为了减少CPU资源的浪费，指定自旋的次数，如果还没获取到锁就进入阻塞状态。可以使用 JVM 参数 <code>-XX:PreBlockSpin</code> 来调整，默认是 10。JDK 1.6 以后使用了适应性自旋，如果自旋成功了，那么这个锁的平均时间可能并不长，使用自选获得锁的几率比较大，更加经济，下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><h3 id=锁粗化lock-coarsening>锁粗化（Lock Coarsening）
<a class=anchor href=#%e9%94%81%e7%b2%97%e5%8c%96lock-coarsening>#</a></h3><p>将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁，避免在无冲突情况下反复加锁解锁的代价。不过，在代码编写时，还是应当把同步块限制的尽量小。</p><h3 id=锁消除lock-elimination>锁消除（Lock Elimination）
<a class=anchor href=#%e9%94%81%e6%b6%88%e9%99%a4lock-elimination>#</a></h3><p>锁消除即删除不必要的加锁操作。利用代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。对于通常的代码，编写者应当已经明白数据是否进行逃逸。但作为库被使用的代码中可能有许多不必使用的同步块，如已经被废弃的 <code>StringBuffer</code>。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#java-中的线程同步>Java 中的线程同步</a><ul><li><a href=#java-中的-synchronized-关键字>Java 中的 synchronized 关键字</a></li><li><a href=#轻量级锁和偏向锁>轻量级锁和偏向锁</a></li><li><a href=#轻量级锁>轻量级锁</a><ul><li><a href=#加锁>加锁</a></li><li><a href=#解锁>解锁</a></li></ul></li><li><a href=#偏向锁>偏向锁</a><ul><li><a href=#获取>获取</a></li><li><a href=#撤销>撤销</a></li></ul></li><li><a href=#其他优化>其他优化</a><ul><li><a href=#适应性自旋adaptive-spinning>适应性自旋（Adaptive Spinning）</a></li><li><a href=#锁粗化lock-coarsening>锁粗化（Lock Coarsening）</a></li><li><a href=#锁消除lock-elimination>锁消除（Lock Elimination）</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>