<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>In-depth Understanding JVM on czdm75 Blog</title><link>/notes/in-depth-jvm/</link><description>Recent content in In-depth Understanding JVM on czdm75 Blog</description><generator>Hugo</generator><language>en</language><atom:link href="/notes/in-depth-jvm/index.xml" rel="self" type="application/rss+xml"/><item><title>Garbage Collection</title><link>/notes/in-depth-jvm/gc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/in-depth-jvm/gc/</guid><description>垃圾回收 # GC 算法 # 判断对象是否存活 # 判断对象存活的算法主要有两个：引用计数算法与可达性算法。其中，引用计数的实现十分简单，但这个算法对于循环引用不能很好地解决。因此，包括 C#、JAVA、Lisp 在内的主流实现使用的都是可达性分析算法。
可达性分析算法 # 可达性分析算法的首要问题是 GC Roots 的选择。GC Root 可以理解为我们&amp;quot;希望存活&amp;quot;的引用。JVM 中可以作为 GC Root 的包括:
VM 栈帧中的引用
方法区中的静态属性
方法区中的常量属性
本地栈中的本地方法中的引用
此外，在进行部分 GC 时，还可能把不收集部分指向收集部分的引用包括在内。例如，对新生代的 GC，老年代的对象中的引用也应该成为 GC Roots。此外，弱引用在新生代 GC 不被回收，因此属于 GC Root。到了 Full GC，弱引用需要被回收，就不属于 Root。当然，这些优化同时也会带来一定的代价，不同的 GC 器可能有不同的实现和权衡。无论如何，上面列出的四种一定会作为 GC Root 出现。
JDK 1.2 之后，为了进行更加细致的 GC 处理，Java 引入了四种不同强度的引用。
Finalize() 方法 # finalize() 方法的规范比较奇怪，这和 Java 的历史沿革有一定的关系。这个方法不应该在正常的开发中被使用。
在 GC 过程中，对象要首先被标记，然后再进行真正的 GC。在标记之后，JVM 会对对象进行判断。如果：
对象所在的类覆盖了 finalize() 方法 对象的 finalize() 方法没有被调用过 那么这个对象将会被放进队列，并执行 finalize() 方法。如果在 finalize() 方法中，对象重新建立了自己与存活对象的引用关系，例如将自己放进了一个集合中，那么这个对象就不会被回收。不过，finalize() 方法只能被调用一次。在下一次回收中，如果这个对象再次被标记，就没有机会再次&amp;quot;拯救自己&amp;quot;。而且，这个方法的优先级相当低。</description></item><item><title>Java Synchronization</title><link>/notes/in-depth-jvm/synchronization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/in-depth-jvm/synchronization/</guid><description>Java 中的线程同步 # Java 中的 synchronized 关键字 # 对函数使用 synchronized 关键字时，如果是静态函数，相当于 synchronized(this.class) 代码块。反之，则相当于 synchronized(this) 代码块。
synchronized 代码块只能锁住对象。最经济的锁对象是 byte[0]，只需要三条字节码，比 new Object() 更少。锁住一个 static 变量，实际上相当于锁住一个类。锁住的对象必须是 private 的。否则，引用所指向的对象将能够被外部修改，破坏同步。
public class Synchronize { private String name; private static final byte[] sb = new byte[0]; private final byte[] b = new byte[0]; private Synchronize(String name) { this.name = name; } public static void print(String s) { System.out.println(&amp;#34;start&amp;#34; + s); try { Thread.sleep(1000); } catch (InterruptedException e) { } System.</description></item><item><title>JVM Memory Model</title><link>/notes/in-depth-jvm/memory-model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/in-depth-jvm/memory-model/</guid><description>Java 内存模型 # 这里的 Java 内存模型（Java Memory Model, JMM）是 JVM 规范试图提出的一种平台无关的内存模型，目的是既能够达到平台无关的效果，同时能够发挥缓存、多核等硬件模型的性能。
在这个模型中，每个线程都有自己的工作内存，与用于存储所有变量的主内存区分。二者之间的关系大致相当于 CPU Cache 与主存的关系，工作内存中存储的是主内存中存储的变量的一份拷贝。线程所有的对变量的修改都必须在工作内存中进行。需要注意的是，这里的变量指的是一个引用（Reference），而其指向的对象位于 JVM 堆中，也就是位于主内存区域。
如果和 JVM 内存布局相关联的话，工作内存大致上相当于虚拟机栈的一部分，主内存主要对应于 JVM 堆中的对象实例。
Java 内存模型的经典描述 # lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。 unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用 load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。 use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。 write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 相应地，对这些操作进行了顺序的规定：
不允许read和load、store和write操作之一单独出现 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。 Volatile 规则 # JMM 为 volatile 提供了一系列特殊的规则。这些规则主要包含两个语义：
首先，任何一条线程对 volatile 变量的修改都会被其他线程立刻得知。也就是说，变量的值在各个线程之间是一致的。即使实际上某一瞬间是不一致的，在下一次使用之前，线程都会从主内存重新刷新变量的值。
然而，这并不意味着这个变量是线程安全的，因为作用在变量上的操作仍然不是原子的。所以，即使变量值的变化能够立刻反映到其他线程，也可能出现操作的冲突。因此，对于全局计数器这一类变量，使用 synchronized 才是正确的选择。volatile 变量更适合全局开关的角色：
volatile boolea shutdownRequested; void shutdown() { shutdownRequested = true; } void doWork() { while (!</description></item><item><title>JVM Memory Regions</title><link>/notes/in-depth-jvm/memory-region/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/in-depth-jvm/memory-region/</guid><description>JVM 内存分区 # JVM 规范中定义了五个分区：PC，栈，本地栈，堆和方法区。在这里我们还加入了方法区中的运行时常量池和不属于 JVM 管理的直接内存。
程序计数器 PC Program Counter # 线程私有 正常情况下指向运行的字节码，native 方法时为 0 JVM 规范中唯一一个未规定 OOM 的内存区域 栈 Java VM Stack # 大部分 JVM 将栈实现为可扩展的。当栈深度达到限制的最大值时，报 StackOverflowError。当已经没有内存来扩展时，报 OOM。
栈帧 # 一个栈帧代表栈中的一个方法的信息。内容包括：
局部变量表 操作数 动态链接 方法出口 其生命周期为一个方法从调用到返回的全过程。
局部变量表 # 局部变量表保存八种基本类型的数据和对象的引用。以 slot 为单位，每个 slot 为 4 Byte。因此 double 类型占用两个 slot。
本地方法栈 Native Method Stack # 与 Java 栈类似，本地方法栈是 native 方法的栈。JVM 规范中未做强制规定，HotSpot 虚拟机将 Java 栈和本地方法栈合二为一一同进行管理。
Java 堆 Heap # Java 堆是我们最熟悉的内存区域，这个区域是在各个线程间共享的，将发生 GC 等过程。原则上，所有的对象都会被分配在这里。随着逃逸分析和 JIT 等技术的成熟以及栈上分配和标量替换等技术的广泛应用，有些对象不一定被分配在堆里。</description></item><item><title>ThreadLocal and Reference</title><link>/notes/in-depth-jvm/threadlocal-reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/in-depth-jvm/threadlocal-reference/</guid><description>ThreadLocal 与 Java 中的引用 # ThreadLocal 类 # ThreadLocal&amp;lt;T&amp;gt; 类可以被赋值，并会将自身作为 key，值作为 value 存入 Thread 对象中的 ThreadLocalMap 中。这样，就能够保证使用这个类包装的变量仅存在于当前线程。而且，即使两个线程分别访问同一个 ThreadLocal 对象，从 get() 方法获取到的值也都是各自线程中的值。
void func() { tl.set(Thread.currentThread().getName()); System.out.println(tl.get()); } ThreadLocal&amp;lt;String&amp;gt; tl = new ThreadLocal&amp;lt;&amp;gt;(); new Thread(() -&amp;gt; {this::func}).start(); // Thread-0 new Thread(() -&amp;gt; {this::func}).start(); // Thread-1 构造 # ThreadLocal&amp;lt;T&amp;gt; 类的构造方法没有任何内容和参数。
每个对象有一个 final int threadLocalHashCode。这个变量的值由静态构造，来自一个 AtomicInteger 累加上一个魔法值。这个魔法值以尽量避免碰撞为依据。这个变量最终会被用在 ThreadLocalMap 的 hash 过程中。
set 方法 # set(T value) 方法接收要传入的值，使用 getMap(Thread t) 方法得到当前所在线程的 ThreadLocalMap。如果结果为 null，就调用 createMap(Thread t, Object value)。否则，直接将参数值存入到 map 中：map.</description></item></channel></rss>