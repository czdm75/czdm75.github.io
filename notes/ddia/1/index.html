<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="可扩展与可维护的与应用系统 # 数据密集型应用系统的典型例子包括：
数据库 高速缓存 索引 流式处理 批处理 可靠性 Reliability # 对数据密集型系统可靠性典型的基本期望：
执行期望的功能 可以容忍错误的使用方法 性能可以应对典型场景 可以防止未授权的访问 fault 指部分的功能不符合预期，反之即为 fault-tolerence 或 resilient；failure 指整个系统的完全不可用。可靠性意味着，我们希望部分的 fault 不会造成整个系统的 failure。
系统的可靠性需要涵盖的方面：
硬件故障 软件错误 人为失误 以最小出错的方式来设计系统界面 将容易出错的地方分离，如上线的测试环境 充分测试 快速回滚 监控子系统 管理流程 可扩展性 Scalability # 在评价可扩展性之前，需要先能够描述系统的负载和性能。
描述负载的指标通常包括 QPS、写入数据比例、同时活动用户数、缓存命中率、扇出数等，这些指标可以是均值、峰值、分位数。
描述性能的指标包括延迟、响应时间、吞吐量等。其中，响应时间是端到端的全链路延迟，而 latency 一般只指用在处理请求上的时间。同样地，经常观测其中位数或高分位数。
数据密集型系统的挑战通常来自于负载增加。需要考虑的问题：
维持性能，负载增加，需要增加多少资源 维持资源，负载增加，性能会如何变化 通常使用的解决方案可以大致分为两类：
Scale up 垂直扩展 Scale out 水平扩展 可维护性 Maintainability # 可维护性通常包括：
可运维性 简单性，即系统本身理解的复杂程度 可演化性，即系统迭代、改变设计的难度 运维团队的职责：
监视系统健康状况，进行快速恢复 追踪异常的原因（如系统故障或性能下降） 保持更新（如安全补丁） 了解不同系统之间的相互有影响，避免破坏性操作 预测可能的问题并解决（如扩容规划） 建立部署和配置的良好实践和 util 执行复杂的运维任务，如集群迁移 修改配置时维护系统正常 制定规范操作流程，保持生产环境稳定 保持相关知识的传承 数据模型与查询语言 # 关系模型与文档模型 # NoSQL # 从发展历史来看，最早的数据库是层次模型，所有数据都在一棵树上，可以良好地支持一对多关系，但不能支持多对多，且不支持 JOIN。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/notes/ddia/1/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="1. Data System and Data Model"><meta property="og:description" content="可扩展与可维护的与应用系统 # 数据密集型应用系统的典型例子包括：
数据库 高速缓存 索引 流式处理 批处理 可靠性 Reliability # 对数据密集型系统可靠性典型的基本期望：
执行期望的功能 可以容忍错误的使用方法 性能可以应对典型场景 可以防止未授权的访问 fault 指部分的功能不符合预期，反之即为 fault-tolerence 或 resilient；failure 指整个系统的完全不可用。可靠性意味着，我们希望部分的 fault 不会造成整个系统的 failure。
系统的可靠性需要涵盖的方面：
硬件故障 软件错误 人为失误 以最小出错的方式来设计系统界面 将容易出错的地方分离，如上线的测试环境 充分测试 快速回滚 监控子系统 管理流程 可扩展性 Scalability # 在评价可扩展性之前，需要先能够描述系统的负载和性能。
描述负载的指标通常包括 QPS、写入数据比例、同时活动用户数、缓存命中率、扇出数等，这些指标可以是均值、峰值、分位数。
描述性能的指标包括延迟、响应时间、吞吐量等。其中，响应时间是端到端的全链路延迟，而 latency 一般只指用在处理请求上的时间。同样地，经常观测其中位数或高分位数。
数据密集型系统的挑战通常来自于负载增加。需要考虑的问题：
维持性能，负载增加，需要增加多少资源 维持资源，负载增加，性能会如何变化 通常使用的解决方案可以大致分为两类：
Scale up 垂直扩展 Scale out 水平扩展 可维护性 Maintainability # 可维护性通常包括：
可运维性 简单性，即系统本身理解的复杂程度 可演化性，即系统迭代、改变设计的难度 运维团队的职责：
监视系统健康状况，进行快速恢复 追踪异常的原因（如系统故障或性能下降） 保持更新（如安全补丁） 了解不同系统之间的相互有影响，避免破坏性操作 预测可能的问题并解决（如扩容规划） 建立部署和配置的良好实践和 util 执行复杂的运维任务，如集群迁移 修改配置时维护系统正常 制定规范操作流程，保持生产环境稳定 保持相关知识的传承 数据模型与查询语言 # 关系模型与文档模型 # NoSQL # 从发展历史来看，最早的数据库是层次模型，所有数据都在一棵树上，可以良好地支持一对多关系，但不能支持多对多，且不支持 JOIN。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><title>1. Data System and Data Model | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle checked>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/ class=active>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>1. Data System and Data Model</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#可扩展与可维护的与应用系统>可扩展与可维护的与应用系统</a><ul><li><a href=#可靠性-reliability>可靠性 Reliability</a></li><li><a href=#可扩展性-scalability>可扩展性 Scalability</a></li><li><a href=#可维护性-maintainability>可维护性 Maintainability</a></li></ul></li><li><a href=#数据模型与查询语言>数据模型与查询语言</a><ul><li><a href=#关系模型与文档模型>关系模型与文档模型</a><ul><li><a href=#nosql>NoSQL</a></li><li><a href=#对象-关系失配>对象-关系失配</a></li><li><a href=#多对一与多对多关系>多对一与多对多关系</a></li><li><a href=#关系数据库与文档数据库现状>关系数据库与文档数据库现状</a></li></ul></li><li><a href=#数据查询语言>数据查询语言</a></li><li><a href=#图数据模型>图数据模型</a><ul><li><a href=#模型-1属性图>模型 1：属性图</a></li><li><a href=#语言-1cypher>语言 1：CYPHER</a></li><li><a href=#sql-中的图查询>SQL 中的图查询</a></li><li><a href=#模型-2三元存储>模型 2：三元存储</a></li><li><a href=#语言-2sparql>语言 2：SPARQL</a></li><li><a href=#图模型与网络模型的区别>图模型与网络模型的区别</a></li><li><a href=#语言-3datalog>语言 3：Datalog</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=可扩展与可维护的与应用系统>可扩展与可维护的与应用系统
<a class=anchor href=#%e5%8f%af%e6%89%a9%e5%b1%95%e4%b8%8e%e5%8f%af%e7%bb%b4%e6%8a%a4%e7%9a%84%e4%b8%8e%e5%ba%94%e7%94%a8%e7%b3%bb%e7%bb%9f>#</a></h1><p>数据密集型应用系统的典型例子包括：</p><ul><li>数据库</li><li>高速缓存</li><li>索引</li><li>流式处理</li><li>批处理</li></ul><h2 id=可靠性-reliability>可靠性 Reliability
<a class=anchor href=#%e5%8f%af%e9%9d%a0%e6%80%a7-reliability>#</a></h2><p>对数据密集型系统可靠性典型的基本期望：</p><ul><li>执行期望的功能</li><li>可以容忍错误的使用方法</li><li>性能可以应对典型场景</li><li>可以防止未授权的访问</li></ul><p>fault 指部分的功能不符合预期，反之即为 fault-tolerence 或 resilient；failure 指整个系统的完全不可用。可靠性意味着，我们希望部分的 fault 不会造成整个系统的 failure。</p><p>系统的可靠性需要涵盖的方面：</p><ol><li>硬件故障</li><li>软件错误</li><li>人为失误<ol><li>以最小出错的方式来设计系统界面</li><li>将容易出错的地方分离，如上线的测试环境</li><li>充分测试</li><li>快速回滚</li><li>监控子系统</li><li>管理流程</li></ol></li></ol><h2 id=可扩展性-scalability>可扩展性 Scalability
<a class=anchor href=#%e5%8f%af%e6%89%a9%e5%b1%95%e6%80%a7-scalability>#</a></h2><p>在评价可扩展性之前，需要先能够描述系统的负载和性能。</p><p>描述负载的指标通常包括 QPS、写入数据比例、同时活动用户数、缓存命中率、扇出数等，这些指标可以是均值、峰值、分位数。</p><p>描述性能的指标包括延迟、响应时间、吞吐量等。其中，响应时间是端到端的全链路延迟，而 latency 一般只指用在处理请求上的时间。同样地，经常观测其中位数或高分位数。</p><p>数据密集型系统的挑战通常来自于负载增加。需要考虑的问题：</p><ul><li>维持性能，负载增加，需要增加多少资源</li><li>维持资源，负载增加，性能会如何变化</li></ul><p>通常使用的解决方案可以大致分为两类：</p><ul><li>Scale up 垂直扩展</li><li>Scale out 水平扩展</li></ul><h2 id=可维护性-maintainability>可维护性 Maintainability
<a class=anchor href=#%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7-maintainability>#</a></h2><p>可维护性通常包括：</p><ul><li>可运维性</li><li>简单性，即系统本身理解的复杂程度</li><li>可演化性，即系统迭代、改变设计的难度</li></ul><p>运维团队的职责：</p><ul><li>监视系统健康状况，进行快速恢复</li><li>追踪异常的原因（如系统故障或性能下降）</li><li>保持更新（如安全补丁）</li><li>了解不同系统之间的相互有影响，避免破坏性操作</li><li>预测可能的问题并解决（如扩容规划）</li><li>建立部署和配置的良好实践和 util</li><li>执行复杂的运维任务，如集群迁移</li><li>修改配置时维护系统正常</li><li>制定规范操作流程，保持生产环境稳定</li><li>保持相关知识的传承</li></ul><h1 id=数据模型与查询语言>数据模型与查询语言
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80>#</a></h1><h2 id=关系模型与文档模型>关系模型与文档模型
<a class=anchor href=#%e5%85%b3%e7%b3%bb%e6%a8%a1%e5%9e%8b%e4%b8%8e%e6%96%87%e6%a1%a3%e6%a8%a1%e5%9e%8b>#</a></h2><h3 id=nosql>NoSQL
<a class=anchor href=#nosql>#</a></h3><p>从发展历史来看，最早的数据库是层次模型，所有数据都在一棵树上，可以良好地支持一对多关系，但不能支持多对多，且不支持 JOIN。</p><p>网络模型是层次模式的一个改进，相当于一个全部用指针链接的图，可以良好地支持多对多。然而，需要手动编写查询代码（跟随指针，性能较好但比较复杂）。</p><p>关系模型只使用二维表作为数据结构，提供索引和 JOIN ，执行由查询优化器自动生成。</p><p>NoSQL 使用文档模型或图模型。 文档数据库类似层次模型，但可以通过文档引用一定程度上支持 JOIN 。</p><p>文档数据库和图数据库看起来似乎和层次模型、网络模型类似，但它们提供的使用方式并不相同。</p><p>相对于 RDBMS，NoSQL 通常具备：</p><ul><li>更好的可扩展性，主要是超大数据集或超高吞吐</li><li>偏向免费开源而非商业数据库</li><li>关系模型不适应的查询操作</li><li>摆脱关系模型的一些限制</li></ul><h3 id=对象-关系失配>对象-关系失配
<a class=anchor href=#%e5%af%b9%e8%b1%a1-%e5%85%b3%e7%b3%bb%e5%a4%b1%e9%85%8d>#</a></h3><p>RDBMS 使用的是行模型，应用程序通常使用的是面向对象模型，二者存在的不匹配需要用 ORM 来解决。如 LinkedIn 简历的文档结构中，就存在大量一对多关系。可能的方案包括：</p><ul><li>外键连接</li><li>复杂数据结构字段</li><li>JSON 或 XML 编码后直接存在文本字段中，无法索引</li></ul><h3 id=多对一与多对多关系>多对一与多对多关系
<a class=anchor href=#%e5%a4%9a%e5%af%b9%e4%b8%80%e4%b8%8e%e5%a4%9a%e5%af%b9%e5%a4%9a%e5%85%b3%e7%b3%bb>#</a></h3><p>无论文档还是关系，在引用外部对象时，都经常使用 id 引用而非直接存储对象。优势包括：</p><ol><li>保持枚举值一致</li><li>避免歧义</li><li>易于更新（改变 id 对应的值）</li><li>本地化支持（id 对应多值）</li><li>更好的搜索支持（便于利用搜索词之间的关系）</li></ol><h3 id=关系数据库与文档数据库现状>关系数据库与文档数据库现状
<a class=anchor href=#%e5%85%b3%e7%b3%bb%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%8e%e6%96%87%e6%a1%a3%e6%95%b0%e6%8d%ae%e5%ba%93%e7%8e%b0%e7%8a%b6>#</a></h3><p>文档不是完全的无模式，而是读时模式，相对应地关系性数据库是写时模式，类似于动态类型和静态类型的区别。在进行数据结构升级后，关系型数据库需要修改数据库内容执行全库 UPDATE，而文档数据库只要在应用代码中判断即可。当数据的结构不可控地经常改变，或由许多不同的类型组成，文档更适合。</p><p>文档模型把相关的数据放在一起（查询时将整个文档整个读取到内存中），因此当读取一个文档的大部分内容时，比关系性数据库有优势，能够利用数据的局部性。类似的概念包括 Cassandra 和 HBase 中的<strong>列族</strong>，Spanner 和 Oracle 也有把相关数据临近存储的功能。</p><h2 id=数据查询语言>数据查询语言
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e6%9f%a5%e8%af%a2%e8%af%ad%e8%a8%80>#</a></h2><p>声明式查询语言的重要优势是，可以通过查询优化器的改变无感地提升查询性能，且适合并发。CSS Selector、XPath 都可以看做声明式的数据查询语言。</p><p>MongoDB 和 CouchDB 支持有限的 MR 只读查询。</p><h2 id=图数据模型>图数据模型
<a class=anchor href=#%e5%9b%be%e6%95%b0%e6%8d%ae%e6%a8%a1%e5%9e%8b>#</a></h2><h3 id=模型-1属性图>模型 1：属性图
<a class=anchor href=#%e6%a8%a1%e5%9e%8b-1%e5%b1%9e%e6%80%a7%e5%9b%be>#</a></h3><p>可以看做有两个关系表，一个表示顶点，一个表示边。</p><p>顶点表的字段包括 id、出入边 id 集合，加上顶点的属性。</p><p>边表的字段包括 id、头尾顶点 id、描述两个顶点间关系的标签，加上边的其他属性。一般在头尾顶点上建立索引。</p><h3 id=语言-1cypher>语言 1：CYPHER
<a class=anchor href=#%e8%af%ad%e8%a8%80-1cypher>#</a></h3><p>CYPHER 最早为 neo4j 创建，采用声明式的语法。</p><pre tabindex=0><code>CREATE
  (NAmerica:Location {name:&#39;North America&#39;, type:&#39;continent&#39;}),
  (USA:Location      {name:&#39;United States&#39;, type:&#39;country&#39;}),
  (Idaho:Location    {name:&#39;Idaho&#39;,         type:&#39;state&#39;}),
  (Lucy:Person       {name:&#39;Lucy&#39;}),
  (Idaho) -[:WITHIN]-&gt; (USA) -[:WITHIN]-&gt; (NAmerica)
  (Lucy)  -[:BORN_IN]-&gt; (Idaho)
</code></pre><pre tabindex=0><code>MATCH
  (person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (us:Location {name:&#39;United States&#39;}),
  (person) -[:LIVE_IN]-&gt; () -[:WITHIN*0..]-&gt; (eu:Location {name:&#39;Europe&#39;})
RETURN person.name
</code></pre><h3 id=sql-中的图查询>SQL 中的图查询
<a class=anchor href=#sql-%e4%b8%ad%e7%9a%84%e5%9b%be%e6%9f%a5%e8%af%a2>#</a></h3><p>如上，图数据可以用关系模型来表达。但是，图数据查询的主要问题是，因为递归的次数是不一定的，相应 JOIN 的次数也是不一定的 / 无限多的。在上面的 Cypher 查询中，<code>WITHIN*0..</code> 表示可以以 0 次以上的 WITHIN 关系找到后面的节点。也就是说，查询的 Person 的 LIVE_IN 关系可以指向某个街道、城市、国家或欧洲，都能被查询到，只要他们之间有 WITHIN 关系。SQL 引入了 <code>WITH RECURSIVE</code> 语法来表达这个查询，但仍然不太优雅。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>WITH</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>RECURSIVE</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>in_europe(vertex_id)<span style=color:#bbb> </span><span style=color:green;font-weight:700>AS</span><span style=color:#bbb> </span>(<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>vertex_id<span style=color:#bbb> </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>vertices<span style=color:#bbb> </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span>properties<span style=color:#666>-&gt;&gt;</span><span style=color:#ba2121>&#39;name&#39;</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#ba2121>&#39;Europe&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>UNION</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span>edges.tail_vertex<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>FROM</span><span style=color:#bbb> </span>edges<span style=color:#bbb> </span><span style=color:green;font-weight:700>JOIN</span><span style=color:#bbb> </span>in_europe<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>ON</span><span style=color:#bbb> </span>edges.head_vertex<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>in_europe.vertex_id<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span>edges.label<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#ba2121>&#39;within&#39;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>)<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=模型-2三元存储>模型 2：三元存储
<a class=anchor href=#%e6%a8%a1%e5%9e%8b-2%e4%b8%89%e5%85%83%e5%ad%98%e5%82%a8>#</a></h3><p>三元存储可以看做，将上面的属全部改成图的边，只保留边表。得到的关系表只有三个字段：主体，客体，谓词。上面的模型相当于：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>_:namerica<span style=color:#bbb> </span>a<span style=color:#bbb>      </span>:<span style=color:green;font-weight:700>Location</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:namerica<span style=color:#bbb> </span>:name<span style=color:#bbb>  </span><span style=color:#ba2121>&#34;North America&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:namerica<span style=color:#bbb> </span>:<span style=color:green;font-weight:700>type</span><span style=color:#bbb>  </span><span style=color:#ba2121>&#34;continent&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:usa<span style=color:#bbb>      </span>a<span style=color:#bbb>      </span>:<span style=color:green;font-weight:700>Location</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:usa<span style=color:#bbb>      </span>:name<span style=color:#bbb>  </span><span style=color:#ba2121>&#34;United States&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:usa<span style=color:#bbb>      </span>:<span style=color:green;font-weight:700>type</span><span style=color:#bbb>  </span><span style=color:#ba2121>&#34;country&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>_:usa<span style=color:#bbb>      </span>:witin<span style=color:#bbb> </span>:namerica<span style=color:#bbb>
</span></span></span></code></pre></div><p>注意数据库中并不存储第一列的节点名字，这个名字只出现在定义语言中。</p><h3 id=语言-2sparql>语言 2：SPARQL
<a class=anchor href=#%e8%af%ad%e8%a8%80-2sparql>#</a></h3><p>上面的查询改成 SPARQL：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:green;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>?</span>personName<span style=color:#bbb> </span><span style=color:green;font-weight:700>WHERE</span><span style=color:#bbb> </span><span>{</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#666>?</span>person<span style=color:#bbb> </span>:name<span style=color:#bbb> </span><span style=color:#666>?</span>personName.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#666>?</span>person<span style=color:#bbb> </span>:bornIn<span style=color:#bbb> </span><span style=color:#666>/</span><span style=color:#bbb> </span>:within<span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#666>/</span><span style=color:#bbb> </span>:name<span style=color:#bbb> </span><span style=color:#ba2121>&#34;United States&#34;</span>.<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>  </span><span style=color:#666>?</span>person<span style=color:#bbb> </span>:liveIn<span style=color:#bbb> </span><span style=color:#666>/</span><span style=color:#bbb> </span>:within<span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#666>/</span><span style=color:#bbb> </span>:name<span style=color:#bbb> </span><span style=color:#ba2121>&#34;Europe&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span>}</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>可以看出这里的 <code>:within*</code> 类似于 Cypher 中的 <code>-[:WITHIN*0..]-></code> 。</p><h3 id=图模型与网络模型的区别>图模型与网络模型的区别
<a class=anchor href=#%e5%9b%be%e6%a8%a1%e5%9e%8b%e4%b8%8e%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%8c%ba%e5%88%ab>#</a></h3><p>图模型并不同于早期的网络模型。主要区别包括：</p><ol><li>图模型没有模式，而网络模型有一个模式来规定哪些节点之间可以怎样连接</li><li>网络模型需要通过访问路径来找到节点，图模型可以直接用唯一 id</li><li>网络模型中的边是有序的，给存储修改带来困难</li><li>网络模型的查询语言是命令式的</li></ol><h3 id=语言-3datalog>语言 3：Datalog
<a class=anchor href=#%e8%af%ad%e8%a8%80-3datalog>#</a></h3><p>Datalog 的定义部分采用三元组：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>name(namerica,<span style=color:#bbb> </span><span style=color:#ba2121>&#39;North America&#39;</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>(namerica,<span style=color:#bbb> </span><span style=color:#ba2121>&#39;continent&#39;</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>name(usa,<span style=color:#bbb>      </span><span style=color:#ba2121>&#39;United States&#39;</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>type</span>(usa,<span style=color:#bbb>      </span><span style=color:#ba2121>&#39;country&#39;</span>)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>within(usa,<span style=color:#bbb> </span>namerica)<span style=color:#bbb>
</span></span></span></code></pre></div><p>查询部分则是采用规则，Datalog 是 Prolog 的子集，采用逻辑规则编程的方式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span>within_recursive(<span style=color:green;font-weight:700>Location</span>,<span style=color:#bbb> </span>name)<span style=color:#bbb> </span>:<span style=color:#666>-</span><span style=color:#bbb> </span>name(<span style=color:green;font-weight:700>Location</span>,<span style=color:#bbb> </span>name).<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>within_recursive(<span style=color:green;font-weight:700>Location</span>,<span style=color:#bbb> </span>name)<span style=color:#bbb> </span>:<span style=color:#666>-</span><span style=color:#bbb> </span>within(<span style=color:green;font-weight:700>Location</span>,<span style=color:#bbb> </span>Via),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                                    </span>within_recursive(Via,<span style=color:#bbb> </span>Name).<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>in_europe(Name,<span style=color:#bbb> </span>LivingIn)<span style=color:#bbb> </span>:<span style=color:#666>-</span><span style=color:#bbb> </span>name(Person,<span style=color:#bbb> </span>Name),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                             </span>live_in(Person,<span style=color:#bbb> </span>LiveLoc),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>                             </span>within_recursive(LiveLoc,<span style=color:#bbb> </span>LivingIn).<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#666>?-</span><span style=color:#bbb> </span>live_in_europe(Who,<span style=color:#bbb> </span><span style=color:#ba2121>&#39;Europe&#39;</span>)<span style=color:#bbb>
</span></span></span></code></pre></div><p>此时 Who 的值就是所有住在欧洲的人名字。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#可扩展与可维护的与应用系统>可扩展与可维护的与应用系统</a><ul><li><a href=#可靠性-reliability>可靠性 Reliability</a></li><li><a href=#可扩展性-scalability>可扩展性 Scalability</a></li><li><a href=#可维护性-maintainability>可维护性 Maintainability</a></li></ul></li><li><a href=#数据模型与查询语言>数据模型与查询语言</a><ul><li><a href=#关系模型与文档模型>关系模型与文档模型</a><ul><li><a href=#nosql>NoSQL</a></li><li><a href=#对象-关系失配>对象-关系失配</a></li><li><a href=#多对一与多对多关系>多对一与多对多关系</a></li><li><a href=#关系数据库与文档数据库现状>关系数据库与文档数据库现状</a></li></ul></li><li><a href=#数据查询语言>数据查询语言</a></li><li><a href=#图数据模型>图数据模型</a><ul><li><a href=#模型-1属性图>模型 1：属性图</a></li><li><a href=#语言-1cypher>语言 1：CYPHER</a></li><li><a href=#sql-中的图查询>SQL 中的图查询</a></li><li><a href=#模型-2三元存储>模型 2：三元存储</a></li><li><a href=#语言-2sparql>语言 2：SPARQL</a></li><li><a href=#图模型与网络模型的区别>图模型与网络模型的区别</a></li><li><a href=#语言-3datalog>语言 3：Datalog</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>