<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="入门 #  apply 方法 #  对于代码：
val arr = Array(&#34;a&#34;, &#34;b&#34;) arr(0) arr(0) = &#34;c&#34; 实际上是调用了：
val arr = Array.apply(&#34;a&#34;, &#34;b&#34;) arr.apply(0) arr.update(0, &#34;c&#34;) 列表 #  Scala 默认的 List 是 Immutable 的。可以对列表进行拼接：
val l = List(1, 2) 1 :: l // List(1, 1, 2) l ::: l // List(1, 2, 1, 2) l :: l // List(List(1, 2), 1, 2) 首先，由于 List 是 Immutable 的，所以所有的拼接操作都返回一个新的 List。
三冒号的写法比较容易理解：它将两个列表连接起来。对于双冒号，则是将前面的元素与后面的列表连接起来。在第四行代码中，由于双冒号前面的元素被作为一个对象来操作，因此得到的是一个具有嵌套结构的 Any 列表。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="1. Basics"><meta property="og:description" content="入门 #  apply 方法 #  对于代码：
val arr = Array(&#34;a&#34;, &#34;b&#34;) arr(0) arr(0) = &#34;c&#34; 实际上是调用了：
val arr = Array.apply(&#34;a&#34;, &#34;b&#34;) arr.apply(0) arr.update(0, &#34;c&#34;) 列表 #  Scala 默认的 List 是 Immutable 的。可以对列表进行拼接：
val l = List(1, 2) 1 :: l // List(1, 1, 2) l ::: l // List(1, 2, 1, 2) l :: l // List(List(1, 2), 1, 2) 首先，由于 List 是 Immutable 的，所以所有的拼接操作都返回一个新的 List。
三冒号的写法比较容易理解：它将两个列表连接起来。对于双冒号，则是将前面的元素与后面的列表连接起来。在第四行代码中，由于双冒号前面的元素被作为一个对象来操作，因此得到的是一个具有嵌套结构的 Any 列表。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/programming-scala/1/"><meta property="article:section" content="notes"><title>1. Basics | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle checked>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/ class=active>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>1. Basics</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#入门>入门</a><ul><li><a href=#apply-方法>apply 方法</a></li><li><a href=#列表>列表</a></li><li><a href=#元组>元组</a></li><li><a href=#immutable--mutable-set-与-map>Immutable / Mutable, Set 与 Map</a></li></ul></li><li><a href=#基础类型类和对象>基础类型、类和对象</a><ul><li><a href=#单例对象>单例对象</a></li><li><a href=#基础类型>基础类型</a></li><li><a href=#字符串>字符串</a></li><li><a href=#字符串插值器interpolater>字符串插值器（Interpolater）</a></li><li><a href=#符号-symbol>符号 Symbol</a></li><li><a href=#操作符>操作符</a></li><li><a href=#application-特质>Application 特质</a></li></ul></li><li><a href=#构造函数>构造函数</a></li><li><a href=#控制流>控制流</a><ul><li><a href=#for>for</a></li><li><a href=#if>if</a></li><li><a href=#try-catch--try-finally>try-catch / try-finally</a></li><li><a href=#将-break-和-continue-转化为尾递归>将 break 和 continue 转化为尾递归</a></li><li><a href=#作用域>作用域</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=入门>入门
<a class=anchor href=#%e5%85%a5%e9%97%a8>#</a></h1><h2 id=apply-方法>apply 方法
<a class=anchor href=#apply-%e6%96%b9%e6%b3%95>#</a></h2><p>对于代码：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> arr <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Array</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>arr<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>arr<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#ba2121>&#34;c&#34;</span>
</span></span></code></pre></div><p>实际上是调用了：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> arr <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Array</span><span style=color:#666>.</span>apply<span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>arr<span style=color:#666>.</span>apply<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>arr<span style=color:#666>.</span>update<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><h2 id=列表>列表
<a class=anchor href=#%e5%88%97%e8%a1%a8>#</a></h2><p>Scala 默认的 <code>List</code> 是 Immutable 的。可以对列表进行拼接：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> l <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>1</span> <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>l</span>    <span style=color:#408080;font-style:italic>// List(1, 1, 2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l <span style=color:green;font-weight:700>:</span><span style=color:#b00040>::</span> <span style=color:#b00040>l</span>   <span style=color:#408080;font-style:italic>// List(1, 2, 1, 2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>l</span>    <span style=color:#408080;font-style:italic>// List(List(1, 2), 1, 2)
</span></span></span></code></pre></div><p>首先，由于 List 是 Immutable 的，所以所有的拼接操作都返回一个新的 List。</p><p>三冒号的写法比较容易理解：它将两个列表连接起来。对于双冒号，则是将前面的元素与后面的列表连接起来。在第四行代码中，由于双冒号前面的元素被作为<strong>一个</strong>对象来操作，因此得到的是一个具有嵌套结构的 <code>Any</code> 列表。</p><p>而且，理所应当，双冒号应当是右结合的操作符，因为任何一个对象不应该持有这样与其没有太大直接关系的操作，所以 <code>::</code> 方法应该是列表的方法而不是所有对象都具有的方法。但是，通常调用的操作符是左结合的，如 <code>1 + 2</code> 实际为 <code>1.+(2)</code>。Scala 简单地使用冒号来区分，如果操作符的最后一个字符是冒号，那么操作符就是右结合的。</p><p>对于列表，在其前面增加元素是一个高效的 O(1) 的操作，而 append 则是一个 O(n) 的操作，其中 n 是列表的长度。相应地，可变的集合的追加操作就是高效的，例如 <code>ArrayBuffer</code>。这两种相反方向的集合适用于不同的场景。也可以使用 <code>::</code> 来创建列表，再调用 <code>reverse()</code>。列表还提供了其他一些函数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> l <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span> <span style=color:#666>,</span><span style=color:#666>3</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>l<span style=color:#666>.</span>init          <span style=color:#408080;font-style:italic>// List(1, 2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l<span style=color:#666>.</span>tail          <span style=color:#408080;font-style:italic>// List(2, 3)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l<span style=color:#666>.</span>drop<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>)</span>       <span style=color:#408080;font-style:italic>// List(3)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l<span style=color:#666>.</span>dropRight<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List(1)
</span></span></span></code></pre></div><p><code>List()</code> 或 <code>Nil</code> 表示空列表。如果要从头使用双冒号来定义一个列表当然是可行的，但最后一个元素必须是 <code>Nil</code>，因为 <code>::()</code> 是列表上的方法。形如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> list <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span>2</span> <span style=color:#b00040>::</span> <span>3</span> <span style=color:#b00040>::</span> <span style=color:#b00040>Nil</span>
</span></span></code></pre></div><p>最后一个 <code>::</code> 需要在 <code>Nil</code> 上进行调用。</p><h2 id=元组>元组
<a class=anchor href=#%e5%85%83%e7%bb%84>#</a></h2><p>元组实际上是在 <code>scala</code> 包中定义的一系列类。其访问方法是：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> t <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// class: scala.Tuple2[Int, String]
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>t<span style=color:#666>.</span>_1  <span style=color:#408080;font-style:italic>// 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>t<span style=color:#666>.</span>_2  <span style=color:#408080;font-style:italic>// &#34;a&#34;
</span></span></span></code></pre></div><p>元组的序号之所以从 1 开始是继承了其他语言，如 ML 的传统。</p><p>元组与列表的区别是，元组对每个元素保留泛型的类型参数，它能够保留每一个元素的类型信息，而列表不能。它只能保留所有元素的父类型。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// Tuple2[Int, String]
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List[Any]
</span></span></span></code></pre></div><h2 id=immutable--mutable-set-与-map>Immutable / Mutable, Set 与 Map
<a class=anchor href=#immutable--mutable-set-%e4%b8%8e-map>#</a></h2><p>在 Scala 中，<code>List</code> 总是 Immutable 的，<code>Array</code> 总是 Mutable 的。<code>Array</code> 还有长度可变的版本 <code>ArrayBuffer</code>。而对于 Set 和 Map，Scala 分别提供了可变与不可变的两种类型，使用包和 Trait 进行区分：</p><p><img src=../collection-hierarchy.png alt="Inherite Relationship of Set"></p><p>出于函数式的考虑，Scala 默认引入的是不可变的版本，使用可变的版本则需要显式调用。当然，也可以显式地指定要使用的集合的实现版本：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>scala.collection.mutable</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> s <span style=color:green;font-weight:700>=</span> mutable<span style=color:#666>.</span><span style=color:#00f;font-weight:700>Set</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>scala.collection.immutable.HashSet</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> s2 <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>HashSet</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>在对这两种集合进行操作时，就会形成不同的模式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>var</span> m <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Set</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>m <span style=color:#666>+=</span> <span style=color:#ba2121>&#34;c&#34;</span>  <span style=color:#408080;font-style:italic>// m is a new Set now
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> m <span style=color:green;font-weight:700>=</span> mutable<span style=color:#666>.</span><span style=color:#00f;font-weight:700>Set</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>m <span style=color:#666>+=</span> <span style=color:#ba2121>&#34;c&#34;</span>  <span style=color:#408080;font-style:italic>// still the Set before
</span></span></span></code></pre></div><p>对于 Map 来说，主要的区别是其使用二元元组（<code>Tuple2</code>）作为输入元素，这里用到了 Scala 中生成元组的函数 <code>->()</code>：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>Map</span><span style=color:#666>(</span><span style=color:#666>1</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#666>2</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// Map(1 -&gt; a, 2 -&gt; b)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>1</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;a&#34;</span>                 <span style=color:#408080;font-style:italic>// (1,a)
</span></span></span></code></pre></div><h1 id=基础类型类和对象>基础类型、类和对象
<a class=anchor href=#%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1>#</a></h1><h2 id=单例对象>单例对象
<a class=anchor href=#%e5%8d%95%e4%be%8b%e5%af%b9%e8%b1%a1>#</a></h2><p>对于单例对象，<code>scalac</code> 会编译成一个名为 <code>ObjectName$</code> 的 class 文件。如果需要进行大量的编译而不希望每一次调用 <code>scalac</code> 命令都要重新寻找 classpath 等，可以使用 <code>fsc</code> 命令来编译。在调用 <code>fsc</code> 之后，会拉起一个守护进程，再次调用 <code>fsc</code> 就会将源文件发送到这个守护进程的端口上。最后，使用 <code>fsc -shutdown</code> 停止守护进程。</p><p>除了使用 <code>main</code> 函数，Scala 还提供了一个用于创建 App 的 Trait ：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>App</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  args foreach println
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=基础类型>基础类型
<a class=anchor href=#%e5%9f%ba%e7%a1%80%e7%b1%bb%e5%9e%8b>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#666>0x00FF</span>  <span style=color:#408080;font-style:italic>// Int = 255
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>0xCAFEBABE</span>  <span style=color:#408080;font-style:italic>// Int = -889275714
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>0xCAFEBABE</span>L  <span style=color:#408080;font-style:italic>// Long = 3405691582
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>1.23e-2</span>  <span style=color:#408080;font-style:italic>// Double = 0.0123
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>1</span>e2  <span style=color:#408080;font-style:italic>// Double = 100.0
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#ba2121>&#39;\u0041&#39;</span>  <span style=color:#408080;font-style:italic>// Char = A
</span></span></span></code></pre></div><h2 id=字符串>字符串
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2>#</a></h2><p>Raw 字符串</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#ba2121>&#34;&#34;&#34;AB
</span></span></span><span style=display:flex><span><span style=color:#ba2121>  BA&#34;&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &#34;AB\n  BA&#34;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#ba2121>&#34;&#34;&#34;ab
</span></span></span><span style=display:flex><span><span style=color:#ba2121>  |ba&#34;&#34;&#34;</span><span style=color:#666>.</span>stripMargin
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &#34;AB\nBA&#34;
</span></span></span></code></pre></div><p>可以看到，RAW 字符串里保留了空格和换行符，如果在定义中使用管道符并就能通过 <code>stripMargin</code> 避免将缩进用的字符串包括在内。</p><h2 id=字符串插值器interpolater>字符串插值器（Interpolater）
<a class=anchor href=#%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%8f%92%e5%80%bc%e5%99%a8interpolater>#</a></h2><p>Scala 定义了三个字符串插值器。<code>f</code> 允许使用 C 风格的格式化，<code>raw</code> 中的转义符不会生效，<code>s</code> 是通常的插值器。由于 <code>f</code> 被实现为了宏，它可以在编译期进行类型检查，<code>printf</code> 则不能。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>print<span style=color:#666>(</span><span style=color:#ba2121>f&#34;hello, </span><span style=color:#b68;font-weight:700>$name</span><span style=color:#ba2121>, </span><span style=color:#b68;font-weight:700>${</span>age <span style=color:#666>+</span> <span style=color:#666>0.5</span><span style=color:#b68;font-weight:700>}</span><span style=color:#ba2121>%7.2f&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>print<span style=color:#666>(</span><span style=color:#ba2121>s&#34;abd </span><span style=color:#b68;font-weight:700>$name</span><span style=color:#ba2121>&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>print<span style=color:#666>(</span><span style=color:#ba2121>raw&#34;\t\n&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>也可以自己定义插值器。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.time.LocalDate</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>DateInterpolator</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> sc<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>StringContext</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>AnyVal</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> date<span style=color:#666>(</span>args<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Any*</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>LocalDate</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>LocalDate</span><span style=color:#666>.</span>of<span style=color:#666>(</span>
</span></span><span style=display:flex><span>    args<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>).</span>toString<span style=color:#666>.</span>toInt<span style=color:#666>,</span>
</span></span><span style=display:flex><span>    args<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>).</span>toString<span style=color:#666>.</span>toInt<span style=color:#666>,</span>
</span></span><span style=display:flex><span>    args<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>).</span>toString<span style=color:#666>.</span>toInt<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> y <span style=color:green;font-weight:700>=</span> <span style=color:#666>2018</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> m <span style=color:green;font-weight:700>=</span> <span style=color:#666>4</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> d <span style=color:green;font-weight:700>=</span> <span style=color:#666>5</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>date<span style=color:#ba2121>&#34;$y, $m, $d&#34;</span>  <span style=color:#408080;font-style:italic>// java.time.LocalDate = 2018-04-05
</span></span></span></code></pre></div><h2 id=符号-symbol>符号 Symbol
<a class=anchor href=#%e7%ac%a6%e5%8f%b7-symbol>#</a></h2><p>Symbol 对象的作用和 Java 中的 Interned String 类似，通过一个单引号来声明。对于一般的字符串，频繁使用字面量可能造成大量字符串对象的创建，给系统的性能带来压力，解决办法是将其放入常量池，和 JVM 对数字的处理一样。</p><p>对于 Symbol 来说，当符号创建时，实际上调用了 <code>Symbol.apply(name: String)</code> 在常量池中建立了一个对象，之后再次使用时引用的将会时同一个对象。这样，在比较时避免了字符串的重复构造和遍历，而是直接比较地址即可。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>&#39;abc  <span style=color:#408080;font-style:italic>// Symbol = &#39;abc
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>&#39;abc<span style=color:#666>.</span>name  <span style=color:#408080;font-style:italic>// String = abc
</span></span></span></code></pre></div><h2 id=操作符>操作符
<a class=anchor href=#%e6%93%8d%e4%bd%9c%e7%ac%a6>#</a></h2><p>对于超过一个参数的方法，可以将参数用括号包起来使用中缀表达：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> op<span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> j<span style=color:green;font-weight:700>:</span><span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Unit</span> <span style=color:#666>=</span> print<span style=color:#666>(</span>i <span style=color:#666>+</span> j<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>A op <span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>Scala 只允许四个前缀操作符：<code>+ - ! ~</code>，使用 <code>unary_</code> 来定义：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Num</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> unary_-<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Num</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Num</span><span style=color:#666>(-</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>-(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Num</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>)).</span>a
</span></span></code></pre></div><p>后缀操作符的形式是没有参数的方法。通常，当方法有副作用时保留括号来调用，而在方法没有副作用时不适用括号，使其看起来就像对变量成员的访问一样：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#ba2121>&#34;ABC&#34;</span><span style=color:#666>.</span>reverse
</span></span></code></pre></div><p>Scala 的 <code>==</code> 方法调用了 <code>equals</code> 方法，但是 null 安全的。<code>eq</code> 和 <code>ne</code> 方法比较引用。因此，Scala 程序惯用 <code>==</code> 来比较对象，编写 <code>equals</code> 就更加重要。</p><p>因为使用函数作为操作符，操作符的有限集比较复杂。除了正常可以理解的，<code>*</code> 高于 <code>+</code> 这类规则外，对于自己定义的操作符，Scala 使用第一个字符来判断，这样做的目的是，例如我们自己定义了 <code>**()</code> 和 <code>++()</code> 方法，那么 <code>**()</code> 的优先级更高，这符合我们的心理预期。</p><p>另外任何赋值操作符的优先级与正常的赋值操作符 <code>=</code> 相同。也就是说，<code>+=</code> <code>-=</code> 这类以等号结尾的操作符优先级与赋值操作符相等，无论首字母是什么。因此，在 Scala 类的操作符的定义中，遵循公共的常规约定十分重要。</p><p>对于这些特殊字符，Scala 会将其转换为一定的字符串，以和 Java 兼容。例如 <code>:-></code> 需要在 Java 中使用 <code>$colon$minus$greater</code> 来访问。</p><p>对于基本类型的包装类，Scala 实际上将复杂的操作定义在了它们对应的富包装类中，即 <code>RichInt</code> <code>StringOps</code> 等类，并提供隐式转换。</p><h2 id=application-特质>Application 特质
<a class=anchor href=#application-%e7%89%b9%e8%b4%a8>#</a></h2><p>最后简单介绍一下 App 特质。这个特质可以这样使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>MyApp</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>App</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>arg <span style=color:green;font-weight:700>&lt;-</span> args<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  println<span style=color:#666>(</span>arg<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这样编写之后，这个程序就可以正常地被编译和运行。只需要在命令行 <code>scala MyApp</code> 即可，还可以正常地使用命令行参数，方便创建简单的程序。这样做的原理是，这个对象继承了 <code>App</code> 这个 trait，这些代码会被父类的 <code>main</code> 函数中被调用，这里不做过多解释。</p><h1 id=构造函数>构造函数
<a class=anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0>#</a></h1><p>对于 Scala 类：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span><span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  println<span style=color:#666>(</span>i<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>大致上相当于这样一个 Java 类：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>public</span> <span style=color:#00f>A</span><span style=color:#666>(</span><span style=color:#b00040>int</span> i<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>i<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>此外，还可以使用 <code>require</code> 对构造函数的参数进行限制，如果不满足则会自动抛出 <code>IllegalArgumentException</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  require<span style=color:#666>(</span>d <span style=color:#666>!=</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> toString <span style=color:green;font-weight:700>=</span> n <span style=color:#666>+</span> <span style=color:#ba2121>&#34;/&#34;</span> <span style=color:#666>+</span> d
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// java.lang.IllegalArgumentException: requirement failed
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at scala.Predef$.require(Predef.scala:212)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ... 33 elided
</span></span></span></code></pre></div><p>这样声明的 <code>n</code> 和 <code>d</code> 的作用域在类内，相当于两个 <code>private val</code>，因此 <code>toString</code> 可以访问，但无法从对象外使用 <code>obj.n</code> 访问。要在对象外访问，要将其声明为字段。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>val</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> numer <span style=color:green;font-weight:700>=</span> n
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> denom <span style=color:green;font-weight:700>=</span> d
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>要创建其他的构造函数，使用 <code>this</code> ：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>val</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>(</span>n<span style=color:#666>,</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>其他构造函数必须首先调用主构造函数，这样就保证了 Scala 中对象的单入口。</p><p>最后，对于这样一个有理数类，还缺少一个合适的隐式转换，以便其和一般的整数一起工作：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>def</span> intToRational<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span>x<span style=color:#666>)</span>
</span></span></code></pre></div><p>隐式转换遵守作用域的规则。因此，通常需要进行导入。</p><h1 id=控制流>控制流
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e6%b5%81>#</a></h1><h2 id=for>for
<a class=anchor href=#for>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to collection<span style=color:#666>.</span>length <span style=color:#666>-</span> <span style=color:#666>1</span><span style=color:#666>)</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> until collection<span style=color:#666>.</span>length<span style=color:#666>)</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> until <span style=color:#666>4</span> <span style=color:green;font-weight:700>if</span> i <span style=color:#666>/</span> <span style=color:#666>2</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to <span style=color:#666>10</span> <span style=color:green;font-weight:700>if</span> i <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>;</span>                 <span style=color:#408080;font-style:italic>// notice the semicolumn
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>     j <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to <span style=color:#666>10</span> <span style=color:green;font-weight:700>if</span> j <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>!=</span> <span style=color:#666>0</span><span style=color:#666>)</span> print<span style=color:#666>((</span>i<span style=color:#666>,</span> j<span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>{</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to <span style=color:#666>10</span> <span style=color:green;font-weight:700>if</span> i <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>==</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>     j <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to <span style=color:#666>10</span> <span style=color:green;font-weight:700>if</span> j <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>!=</span> <span style=color:#666>0</span><span style=color:#666>}</span> print<span style=color:#666>((</span>i<span style=color:#666>,</span> j<span style=color:#666>))</span>
</span></span></code></pre></div><p>在圆括号内 Scala 不会自动推断分号。for 语句内也可以依赖前一个变量，甚至另外定义变量。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> col <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Seq</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Seq</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>Seq</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>Seq</span><span style=color:#666>(</span><span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:#666>6</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>{</span>i <span style=color:green;font-weight:700>&lt;-</span> col<span style=color:#666>;</span> j <span style=color:green;font-weight:700>&lt;-</span> i<span style=color:#666>}</span> print<span style=color:#666>(</span>j<span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>{</span>i <span style=color:green;font-weight:700>&lt;-</span> col<span style=color:#666>;</span> x <span style=color:green;font-weight:700>=</span> i<span style=color:#666>.</span>length<span style=color:#666>;</span> j <span style=color:green;font-weight:700>&lt;-</span> i<span style=color:#666>}</span> print<span style=color:#666>(</span>x<span style=color:#666>)</span>    <span style=color:#408080;font-style:italic>// 222222
</span></span></span></code></pre></div><h2 id=if>if
<a class=anchor href=#if>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#408080;font-style:italic>// 两个分支的值是相同的类型，那么返回值是这个类型。对于数值类型，可能自动转换
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>else</span> <span style=color:#666>1</span> <span style=color:#666>}</span>    <span style=color:#408080;font-style:italic>// Int =&gt; Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>else</span> <span style=color:#666>1.2</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Double
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>else</span> <span style=color:#ba2121>&#39;a&#39;</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 两个分支的值是不同的类型，那么返回值是它们的公共父类。
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Base</span><span style=color:#666>()</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Sub1</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Base</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Sub2</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Base</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#00f;font-weight:700>Sub1</span> <span style=color:green;font-weight:700>else</span> <span style=color:#00f;font-weight:700>Sub2</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Base
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 对于两个没有太多亲属关系的类型，常常得到的是 Any Object(即AnyRef) AnyVal，取决于值的类型是引用还是值。
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> x <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>}</span>      <span style=color:#408080;font-style:italic>// Int =&gt; AnyVal
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#ba2121>&#34;zero&#34;</span> <span style=color:green;font-weight:700>else</span> <span style=color:#00f;font-weight:700>Sub1</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Object
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#ba2121>&#34;zero&#34;</span> <span style=color:green;font-weight:700>else</span> <span style=color:#666>1</span> <span style=color:#666>}</span>     <span style=color:#408080;font-style:italic>// Int =&gt; Any
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 赋值语句的值是 Unit，属于数值类型，情况类似
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> x <span style=color:green;font-weight:700>else</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span> <span style=color:#666>}</span> <span style=color:#666>}</span>       <span style=color:#408080;font-style:italic>// Int =&gt; AnyVal
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#ba2121>&#34;zero&#34;</span> <span style=color:green;font-weight:700>else</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span> <span style=color:#666>}</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Any
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// throw 语句的类型是 Nothing。与 Unit 不同，不会被算入到寻找公共父类的过程。
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>{</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#ba2121>&#34;zero&#34;</span> <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Exception</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// Int =&gt; String
</span></span></span></code></pre></div><p>在求取父类的过程中，需要了解到 Scala 类型的继承结构。虽然 Scala 把数值类型在语法上包装成了对象，但它们不继承于 Object / AnyRef 而是继承于 AnyVal，在编译后会变成原本的基本类型。Nothing 和 null 的情况类似。</p><h2 id=try-catch--try-finally>try-catch / try-finally
<a class=anchor href=#try-catch--try-finally>#</a></h2><p><code>throw</code> 语句有返回值，但其返回值是 <code>Nothing</code>，不会被算到求取父类的过程中。<code>catch</code> 语句采用模式匹配语法。由于 <code>try</code> 和 <code>finally</code> 都有返回值，在 <code>finally</code> 中返回值会造成一些特殊的结果，最好的方式是绝对避免在 <code>finally</code> 语句中返回值，而只用来进行资源释放一类的工作。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>try</span> <span style=color:green;font-weight:700>return</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>finally</span> <span style=color:green;font-weight:700>return</span> <span style=color:#666>2</span>  <span style=color:#408080;font-style:italic>// Int = 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>try</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>finally</span> <span style=color:#666>2</span>  <span style=color:#408080;font-style:italic>// Int = 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// warning: a pure expression does nothing in statement position; you may be omitting necessary parentheses
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>-</span> <span style=color:#00f;font-weight:700>Language</span><span style=color:#408080;font-style:italic>//   def f(): Int = try 1 finally 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                                ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>try</span> <span style=color:#666>1</span> <span style=color:green;font-weight:700>finally</span> <span style=color:green;font-weight:700>return</span> <span style=color:#666>2</span>  <span style=color:#408080;font-style:italic>// Int = 2
</span></span></span></code></pre></div><h2 id=将-break-和-continue-转化为尾递归>将 break 和 continue 转化为尾递归
<a class=anchor href=#%e5%b0%86-break-%e5%92%8c-continue-%e8%bd%ac%e5%8c%96%e4%b8%ba%e5%b0%be%e9%80%92%e5%bd%92>#</a></h2><p>在没有 <code>break</code> 和 <code>continue</code> 的情况下，一个简单的办法是使用布尔值和 <code>if</code> 来控制流，不过这不够函数式。但实际上，许多类似的问题都可以被转化为尾递归。例如，假设我们在一系列文件名中寻找第一个不以 <code>-</code> 开头的 Scala 源文件的下标：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span> i<span style=color:#666>;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span><span style=color:#b00040>int</span> i <span style=color:#666>=</span> 0<span style=color:#666>;</span> i <span style=color:#666>&lt;</span> args<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>;</span> i<span style=color:#666>++)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>args<span style=color:#666>[</span>i<span style=color:#666>].</span><span style=color:#7d9029>startsWith</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;-&#34;</span><span style=color:#666>))</span> <span style=color:green;font-weight:700>continue</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>args<span style=color:#666>[</span>i<span style=color:#666>].</span><span style=color:#7d9029>endWith</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;.scala&#34;</span><span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    i <span style=color:#666>=</span> 1<span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>break</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>那么，如果使用尾递归，可以变成：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> searchFrom<span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>i <span style=color:#666>&gt;=</span> args<span style=color:#666>.</span>length<span style=color:#666>)</span> <span style=color:#666>-</span><span style=color:#666>1</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>args<span style=color:#666>(</span>i<span style=color:#666>).</span>startsWith<span style=color:#666>(</span><span style=color:#ba2121>&#34;-&#34;</span><span style=color:#666>))</span> searchFrom<span style=color:#666>(</span>i <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>args<span style=color:#666>(</span>i<span style=color:#666>).</span>endsWith<span style=color:#666>(</span><span style=color:#ba2121>&#34;.scala&#34;</span><span style=color:#666>))</span> i
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>else</span> searchFrom <span style=color:#666>(</span>i <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> i <span style=color:green;font-weight:700>=</span> searchFrom<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>在这里，<code>continue</code> 语句被替换成了一个递归的以 <code>i+1</code> 为参数的调用。而且，由于是尾递归，可以被编译器优化。</p><p>当然，标准库里也提供了对 <code>break</code> 的扩展语法，但这种方式使用异常捕获来运行。这样做的目的是，即使 <code>breakable</code> 出现在另一个函数内，通过异常的抛出，也能实现跨函数的 <code>break</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>scala.util.control.Breaks._</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>breakable <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>while</span><span style=color:#666>(</span><span style=color:green;font-weight:700>true</span><span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>something<span style=color:#666>)</span> break
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=作用域>作用域
<a class=anchor href=#%e4%bd%9c%e7%94%a8%e5%9f%9f>#</a></h2><p>Scala 在作用域上与 Java 的主要区别是 Scala 允许在更小的作用域上使用相同的名字来覆盖外面的变量。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>1</span> to <span style=color:#666>3</span><span style=color:#666>)</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>i <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#666>4</span> to <span style=color:#666>6</span><span style=color:#666>)</span> print<span style=color:#666>(</span>i<span style=color:#666>)</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// 456456456
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>  print<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>print<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 21
</span></span></span></code></pre></div><p>值得顺便一提的是，在 REPL 中之所以可以随意覆盖变量，是因为解释器对每一行输入都划分了一个新的作用域。也就是说：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>scala<span style=color:#666>&gt;</span> <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span>scala<span style=color:#666>&gt;</span> <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>scala<span style=color:#666>&gt;</span> print<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span></code></pre></div><p>实际上等同于：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>  <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    print<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#入门>入门</a><ul><li><a href=#apply-方法>apply 方法</a></li><li><a href=#列表>列表</a></li><li><a href=#元组>元组</a></li><li><a href=#immutable--mutable-set-与-map>Immutable / Mutable, Set 与 Map</a></li></ul></li><li><a href=#基础类型类和对象>基础类型、类和对象</a><ul><li><a href=#单例对象>单例对象</a></li><li><a href=#基础类型>基础类型</a></li><li><a href=#字符串>字符串</a></li><li><a href=#字符串插值器interpolater>字符串插值器（Interpolater）</a></li><li><a href=#符号-symbol>符号 Symbol</a></li><li><a href=#操作符>操作符</a></li><li><a href=#application-特质>Application 特质</a></li></ul></li><li><a href=#构造函数>构造函数</a></li><li><a href=#控制流>控制流</a><ul><li><a href=#for>for</a></li><li><a href=#if>if</a></li><li><a href=#try-catch--try-finally>try-catch / try-finally</a></li><li><a href=#将-break-和-continue-转化为尾递归>将 break 和 continue 转化为尾递归</a></li><li><a href=#作用域>作用域</a></li></ul></li></ul></nav></div></aside></main></body></html>