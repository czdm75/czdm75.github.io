<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Programming in Scala on czdm75 Blog</title><link>/notes/programming-scala/</link><description>Recent content in Programming in Scala on czdm75 Blog</description><generator>Hugo</generator><language>en</language><atom:link href="/notes/programming-scala/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Basics</title><link>/notes/programming-scala/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/1/</guid><description>入门 # apply 方法 # 对于代码：
val arr = Array(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;) arr(0) arr(0) = &amp;#34;c&amp;#34; 实际上是调用了：
val arr = Array.apply(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;) arr.apply(0) arr.update(0, &amp;#34;c&amp;#34;) 列表 # Scala 默认的 List 是 Immutable 的。可以对列表进行拼接：
val l = List(1, 2) 1 :: l // List(1, 1, 2) l ::: l // List(1, 2, 1, 2) l :: l // List(List(1, 2), 1, 2) 首先，由于 List 是 Immutable 的，所以所有的拼接操作都返回一个新的 List。
三冒号的写法比较容易理解：它将两个列表连接起来。对于双冒号，则是将前面的元素与后面的列表连接起来。在第四行代码中，由于双冒号前面的元素被作为一个对象来操作，因此得到的是一个具有嵌套结构的 Any 列表。</description></item><item><title>2. Functions</title><link>/notes/programming-scala/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/2/</guid><description>函数和闭包 # 局部函数 # 通常，对于小的 &amp;ldquo;工具函数&amp;rdquo;，我们会使用私有函数来处理：
object Util { def a(): Unit = { val a = 1; // sth b(a) } private def b(i: Int): Unit { // do sth print(i) } } 通过私有函数，我们避免了 b 函数对整个 Util 对象的调用者的污染。不过，对于 Util 本身的编写者来说，如果 b 函数没有别的用处，仍然有些污染视线。因此，可以：
object Util { def a(): Unit = { val a = 1; // do sth def b(): Unit = { // do sth print(a) } b() } } 与上面的实现的区别是，因为作用域共享，我们无需为 b 设定参数，它可以直接访问外面的 a 变量。</description></item><item><title>3 .Inheritance, Package, Assertion</title><link>/notes/programming-scala/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/3/</guid><description>Scala 的层级 # Scala 继承层级 # Any 类定义了以下的方法：
final def ==(that: Any): Boolean final def !=(that: Any): Boolean def equals(that: Any): Boolean def hashCode: Int def toString: String 其中 == != 方法是 final 的，它们的取值取决于 equals 方法。因此，Scala 中可以使用 == 来比较 Integer String 和其他对象。
Any 有两个子类：AnyVal AnyRef。其中 AnyVal 有九个子类，包括 Java 的八种基本类型和 Unit。这些类都不能用 new 来创建，而必须使用字面量。实际上，这些类都是 abstract final 的，所以无法使用 new。Unit 则只有一个值，写作 ()。
AnyVal 的子类被称为值类型，它们之间可以隐式地互相转换。之前提到过，它们还可以隐式地转换为对应的 Rich 类以支持 until range max 等更多操作。值类型在编译之后将会变成基本类型而不是他们对应的装箱类型，这样做能够带来一些性能提升。Scala 在这里做的事情和 Java 5 的自动装箱很相似。另外一个类 AnyRef 实际上就是 java.</description></item><item><title>4. Pattern Matching, Collections</title><link>/notes/programming-scala/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/4/</guid><description>模式匹配 # 样例类 case class # abstract class Expr case class Number(num: Double) extends Expr case class UnOp(operator: String, arg: Expr) extends Expr case class BinOp(operator: String, left: Expr, right: Expr) extends Expr Scala 为一个 case class 提供了包括：
一个 apply 工厂方法，等同于 def apply(num: Double) = new Number(num) 一系列字段。等同于 val num: Double 正确实现的 toString equals hashCode 方法 一个 copy 方法，这个方法可以接收参数以产生部分不同的新对象。 最重要的是，样例类可以进行模式匹配。
模式 # 通配模式 case _ 匹配任何对象，用于缺省捕获。 常量模式 case 1 仅匹配自己，也就是 equals 返回真值的对象。包括数字、字符串、单例对象、val 值等都可以。 变量模式 case e 变量模式也匹配任何对象，但这个变量名在后续的表达式中是有意义的，可以进行进一步处理。在区分常量模式和变量模式时，Scala 简单地使用首字母来判断。如果首字母是大写，就认为常量。必要时可以选择转义。 构造器模式 case BinOp(&amp;quot;+&amp;quot;, e, Number(0)) 构造器可以进行深度匹配，例如这里嵌套的 Number 对象。 序列模式 case List(0, a, _) 元组模式 case (0, a, _) 类型模式 case m: Map[_, _] 在 Scala 中推荐使用类型匹配而非 isInstanceOf[String] asInstanceOf[String] 来判断类型。 变量绑定 case BinOp(&amp;quot;-&amp;quot;, v @ Number(1), _) v 可以作为变量使用。这样可以在变量模式的基础上进行匹配。 常量和变量的匹配顺序规则如下：大写开头作为常量，小写开头作为变量，加转义则变回常量，这是考虑常量的值是作用域中某个变量的情况。大写开头的变量则不被支持。</description></item><item><title>5. Generics, Abstract, Implicits</title><link>/notes/programming-scala/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/5/</guid><description>类型参数化 # 一个摊还 O(1) 复杂度的函数式队列 # 函数式数据结构通常期望使用递归来进行操作并避免状态的暴露，这让编程模型更优雅统一，但同时，与随机访问的数据结构相比，会将复杂度从 O(1) 提高到 O(n)。不过，通过一系列精妙的设计，函数式的数据结构同样可以具有高性能。虽然这方面的研究尚不完善，但 Scala 混合编程范式的特点让我们能够比较容易地做到这一点。
首先我们简单地使用列表来实现一个队列。由于列表是前追加的数据结构，我们的第一反应是使用一个翻过来的列表：
class SlowHeadQueue[T](elems: List[T]) { def head = elems.last def tail = new SlowHeadQueue(elems.init) def enqueue(x: T) = new SlowHeadQueue(x :: elems) } 这个数据结构 enqueue 是 O(1) 的，而 head 和 tail 是 O(n) 的。但是，我们可以考虑将 head 操作和 tail 操作分开，即使用两个背对背的列表来处理。
class Queue[T](private val leading: List[T], private val trailing: List[T]) { private def mirror = if (leading.isEmpty) new Queue(trailing.reverse, Nil) else this def head = mirror.</description></item><item><title>6. Collections, Extractor, etc</title><link>/notes/programming-scala/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/programming-scala/6/</guid><description>List 与 ListBuffer # Scala 的 List 是一个 sealed abstract class，有两个子类：:: 和 Nil。其中 Nil 是一个 case object。所以，不能直接使用 new List()，只能通过 List.apply() 来调用 :: 类。由于 Nil extends List[Nothing] 且 List 是协变的，它能兼容任何列表类型。
::（cons, construct）类表示有元素的列表。它的构造接收两个参数，即列表的 head 元素和 tail 列表。然后，List 类中定义了这样的方法。要记得以冒号结尾的操作符是右结合的，所以：
def :: [B &amp;gt;: A](elem: B): List[B] = new ::(elem, this) 使得 1 :: 2 :: Nil 这样的构造方式得以实现。
现在我们再来考虑类型问题。从结果上来说，一些不同类型的对象进行 :: 操作，最终得到的结果应当是一个以其公共父类为类型参数的列表。这里通过上面这个方法的类型参数得以实现。当：
apple :: List(orange) 这里的 :: 方法在 List(orange) 上被调用，那么上面的类型参数 A 是 Orange，B 则 应该是 A 的一个父类型。又因为接收的参数也是 B 类型，所以最终 B 被决定为 Fruit 类型。</description></item></channel></rss>