<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="类型参数化 #  一个摊还 O(1) 复杂度的函数式队列 #  函数式数据结构通常期望使用递归来进行操作并避免状态的暴露，这让编程模型更优雅统一，但同时，与随机访问的数据结构相比，会将复杂度从 O(1) 提高到 O(n)。不过，通过一系列精妙的设计，函数式的数据结构同样可以具有高性能。虽然这方面的研究尚不完善，但 Scala 混合编程范式的特点让我们能够比较容易地做到这一点。
首先我们简单地使用列表来实现一个队列。由于列表是前追加的数据结构，我们的第一反应是使用一个翻过来的列表：
class SlowHeadQueue[T](elems: List[T]) {  def head = elems.last  def tail = new SlowHeadQueue(elems.init)  def enqueue(x: T) = new SlowHeadQueue(x :: elems) } 这个数据结构 enqueue 是 O(1) 的，而 head 和 tail 是 O(n) 的。但是，我们可以考虑将 head 操作和 tail 操作分开，即使用两个背对背的列表来处理。
class Queue[T](private val leading: List[T], private val trailing: List[T]) {  private def mirror = if (leading."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="5. Generics, Abstract, Implicits"><meta property="og:description" content="类型参数化 #  一个摊还 O(1) 复杂度的函数式队列 #  函数式数据结构通常期望使用递归来进行操作并避免状态的暴露，这让编程模型更优雅统一，但同时，与随机访问的数据结构相比，会将复杂度从 O(1) 提高到 O(n)。不过，通过一系列精妙的设计，函数式的数据结构同样可以具有高性能。虽然这方面的研究尚不完善，但 Scala 混合编程范式的特点让我们能够比较容易地做到这一点。
首先我们简单地使用列表来实现一个队列。由于列表是前追加的数据结构，我们的第一反应是使用一个翻过来的列表：
class SlowHeadQueue[T](elems: List[T]) {  def head = elems.last  def tail = new SlowHeadQueue(elems.init)  def enqueue(x: T) = new SlowHeadQueue(x :: elems) } 这个数据结构 enqueue 是 O(1) 的，而 head 和 tail 是 O(n) 的。但是，我们可以考虑将 head 操作和 tail 操作分开，即使用两个背对背的列表来处理。
class Queue[T](private val leading: List[T], private val trailing: List[T]) {  private def mirror = if (leading."><meta property="og:type" content="article"><meta property="og:url" content="/notes/programming-scala/5/"><meta property="article:section" content="notes"><title>5. Generics, Abstract, Implicits | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle checked>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/ class=active>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>5. Generics, Abstract, Implicits</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#类型参数化>类型参数化</a><ul><li><a href=#一个摊还-o1-复杂度的函数式队列>一个摊还 O(1) 复杂度的函数式队列</a></li><li><a href=#泛型变型>泛型变型</a><ul><li><a href=#变型>变型</a></li><li><a href=#下界和上界>下界和上界</a></li></ul></li></ul></li><li><a href=#抽象成员>抽象成员</a><ul><li><a href=#抽象成员的种类>抽象成员的种类</a></li><li><a href=#抽象-val-的初始化时机>抽象 val 的初始化时机</a></li><li><a href=#抽象类型的作用>抽象类型的作用</a></li><li><a href=#改良类型-refinement-type>改良类型 refinement type</a></li><li><a href=#枚举-enumeration>枚举 Enumeration</a></li></ul></li><li><a href=#隐式定义>隐式定义</a><ul><li><a href=#隐式转换>隐式转换</a></li><li><a href=#隐式参数>隐式参数</a></li><li><a href=#隐式转换的优先级>隐式转换的优先级</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=类型参数化>类型参数化
<a class=anchor href=#%e7%b1%bb%e5%9e%8b%e5%8f%82%e6%95%b0%e5%8c%96>#</a></h1><h2 id=一个摊还-o1-复杂度的函数式队列>一个摊还 O(1) 复杂度的函数式队列
<a class=anchor href=#%e4%b8%80%e4%b8%aa%e6%91%8a%e8%bf%98-o1-%e5%a4%8d%e6%9d%82%e5%ba%a6%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e9%98%9f%e5%88%97>#</a></h2><p>函数式数据结构通常期望使用递归来进行操作并避免状态的暴露，这让编程模型更优雅统一，但同时，与随机访问的数据结构相比，会将复杂度从 O(1) 提高到 O(n)。不过，通过一系列精妙的设计，函数式的数据结构同样可以具有高性能。虽然这方面的研究尚不完善，但 Scala 混合编程范式的特点让我们能够比较容易地做到这一点。</p><p>首先我们简单地使用列表来实现一个队列。由于列表是前追加的数据结构，我们的第一反应是使用一个翻过来的列表：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>SlowHeadQueue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>elems<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> head <span style=color:green;font-weight:700>=</span> elems<span style=color:#666>.</span>last
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> tail <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>SlowHeadQueue</span><span style=color:#666>(</span>elems<span style=color:#666>.</span>init<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> enqueue<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>SlowHeadQueue</span><span style=color:#666>(</span>x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>elems</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这个数据结构 <code>enqueue</code> 是 O(1) 的，而 <code>head</code> 和 <code>tail</code> 是 O(n) 的。但是，我们可以考虑将 <code>head</code> 操作和 <code>tail</code> 操作分开，即使用两个背对背的列表来处理。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> leading<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span> <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> trailing<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>def</span> mirror <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>leading<span style=color:#666>.</span>isEmpty<span style=color:#666>)</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span>trailing<span style=color:#666>.</span>reverse<span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>this</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> head <span style=color:green;font-weight:700>=</span> mirror<span style=color:#666>.</span>leading<span style=color:#666>.</span>head
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> tail <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>val</span> q <span style=color:green;font-weight:700>=</span> mirror
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span>q<span style=color:#666>.</span>leading<span style=color:#666>.</span>tail<span style=color:#666>,</span> q<span style=color:#666>.</span>trailing<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> enqueue<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span>leading<span style=color:#666>,</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>trailing</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>现在，仅当 <code>leading</code> 为空时，才会发生 O(n) 的操作。由于要使得 <code>leading</code> 为空需要 O(n) 次的 <code>tail</code> 操作，所以这个数据结构的摊还成本是 O(1) 的。</p><p>现在，剩下的问题是，构建这个队列看起来非常奇怪，需要传入两个队列。所以，我们需要另一个构造函数。实现方式有几种：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:#00f;font-weight:700>private</span><span style=color:#666>(</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> leading<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span> <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> trailing<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>()</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>(</span>elems<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T*</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>(</span>elems<span style=color:#666>.</span>toList<span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Null</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// you can only call this() from the outside now
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>Queue</span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span> <span style=color:#666>,</span><span style=color:#666>3</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:green;font-weight:700>_</span><span style=color:#b00040>*</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>更好的办法是使用伴生对象：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Queue</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> apply<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T*</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:#666>.</span>toList<span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>实际上，在 Scala 中，既然已经有了 <code>apply</code> 方法，我们就完全不再有必要把带有具体实现的 <code>Queue</code> 类暴露出来。所以，通常我们会这样做：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> head<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> tail<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> enqueue<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Queue</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> apply<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T*</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>QueueImpl</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:#666>.</span>toList<span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>QueueImpl</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> leading<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> trailing<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>  <span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:#666>{</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=泛型变型>泛型变型
<a class=anchor href=#%e6%b3%9b%e5%9e%8b%e5%8f%98%e5%9e%8b>#</a></h2><h3 id=变型>变型
<a class=anchor href=#%e5%8f%98%e5%9e%8b>#</a></h3><p>Scala 中的泛型默认是不变的。<code>[+T]</code> 表示协变，<code>[-T]</code> 表示逆变。Scala 编译器会自动检查代码中类型参数被使用时的正确性。简单地理解，生产者是协变的，消费者是逆变的。典型的例子是 Scala 中的函数类型：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>Function1</span><span style=color:#666>[</span><span style=color:#b00040>-T1</span>, <span style=color:#b00040>+R</span><span style=color:#666>]</span> <span style=color:#00f;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>AnyRef</span> <span style=color:#666>{</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span><span style=color:#666>[</span><span style=color:#b00040>+T</span><span style=color:#666>]</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> get<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span> <span style=color:#666>=</span> <span style=color:#666>???</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span><span style=color:#666>[</span><span style=color:#b00040>-T</span><span style=color:#666>]</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> set<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>???</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span><span style=color:#666>[</span><span style=color:#b00040>-T</span><span style=color:#666>]</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> get<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span> <span style=color:#666>=</span> <span style=color:#666>???</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: contravariant type T occurs in covariant position in type =&gt; T of method get
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  class A[-T] { def get: T = ??? }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                   ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span><span style=color:#666>[</span><span style=color:#b00040>+T</span><span style=color:#666>]</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> set<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>???</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: covariant type T occurs in contravariant position in type T of value x
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  class A[+T] { def set(x: T) = ??? }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                       ^
</span></span></span></code></pre></div><p>Java 的数组默认是协变的，这是因为 Java 1.5 之前没有泛型时的历史原因，Scala 则默认不变型。当我们修改 Java 数组时，可能会得到 <code>ArrayStoreException</code>。而在 Scala 中，不能像 Java 一样直接赋值，只可能像 Java 的默认泛型一样 cast 数组（<code>arr.asInstanceOf[Array[Object]]</code>），然后才有可能发生 <code>ArrayStoreException</code>。也就是说，当能发生这个问题的情况时，你应该已经意识到了这个风险。</p><h3 id=下界和上界>下界和上界
<a class=anchor href=#%e4%b8%8b%e7%95%8c%e5%92%8c%e4%b8%8a%e7%95%8c>#</a></h3><p>对我们上面的队列的例子，如果队列定义为协变的，<code>enqueue</code> 方法就会产生矛盾，因为 setter 是逆变点（消费者）。例如，如果这里没有限制，就可能会有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> q<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>Fruit</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>Apple</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>q<span style=color:#666>.</span>enqueue<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Orange</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>这显然是不合理的。好在我们可以利用下界（相当于 Java 中的类型参数通配符）来限制 <code>enqueue</code> 参数的类型的范围：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>+T</span><span style=color:#666>]</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> leading<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span> <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> trailing<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> enqueue<span style=color:#666>[</span><span style=color:#b00040>U</span> <span style=color:green;font-weight:700>&gt;:</span> <span style=color:#b00040>T</span><span style=color:#666>](</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>U</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span>leading<span style=color:#666>,</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>trailing</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>现在，<code>enqueue</code> 的参数被限制在 <code>T</code> 的父类，其返回值也变成了 <code>Queue[U]</code> 而不是 <code>Queue[T]</code>。于是有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> q<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>Fruit</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>Apple</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>q<span style=color:#666>.</span>enqueue<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Orange</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// won&#39;t compile
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>q<span style=color:#666>.</span>enqueue<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Fruit</span><span style=color:#666>)</span>   <span style=color:#408080;font-style:italic>// q.enqueue now only takes U &gt;: Fruit, no Orange
</span></span></span></code></pre></div><p>有意思的是，这样的方式仅适用于符合函数式范式的 Immutable 的数据结构。而且，我们这里确定了正确的类型的同时，代码的逻辑也被确定了。也许我们一开始并没有想到这样安全地描述 <code>enqueue</code> 方法，但由于编译器的协变检查，我们必须要这样实现。这种方式也被叫做<strong>类型驱动设计</strong>（type-driven design）。在一些学术性质甚至比 Scala 更强的语言，如 Haskell 中，这件事体现得更加明显。</p><p>这也解释了为什么 Scala 采用了"声明点型变"而不是 Java 的"使用点型变"。作为类的定义者，我们可以在这里解决变型问题而不是将这些复杂的问题交给使用者。实际上，许多使用基于 Scala 的成熟框架的开发者，比如 Spark 的用户，完全不需要知道这些有关变型的知识。</p><p>另外，对象内私有的变量不需要进行这些限制，因为它并不会被对象外访问到。例如，上面的队列在 <code>leading</code> 为空时连续 <code>head</code> 的性能较差，因为每一次调用都要重新进行 <code>trailing.reverse</code>。可以在对象内部引入状态来解决：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>+T</span><span style=color:#666>]</span> <span style=color:#00f;font-weight:700>private</span> <span style=color:#666>(</span> <span style=color:green;font-weight:700>private</span><span style=color:#666>[</span><span style=color:#b00040>this</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>var</span> leading<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span> <span style=color:green;font-weight:700>private</span><span style=color:#666>[</span><span style=color:#b00040>this</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>var</span> trailing<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>def</span> mirror<span style=color:#666>()</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>leading<span style=color:#666>.</span>isEmpty<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span> <span style=color:#666>(!</span>trailing<span style=color:#666>.</span>isEmpty<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      leading <span style=color:green;font-weight:700>=</span> trailing<span style=color:#666>.</span>head <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>leading</span>
</span></span><span style=display:flex><span>      trailing <span style=color:green;font-weight:700>=</span> trailing<span style=color:#666>.</span>tail
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> head<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span> <span style=color:#666>=</span> <span style=color:#666>{</span> mirror<span style=color:#666>();</span> leading<span style=color:#666>.</span>head <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> tail<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Queue</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> mirror<span style=color:#666>();</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>(</span>leading<span style=color:#666>.</span>tail<span style=color:#666>,</span> trailing<span style=color:#666>)</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> enqueue<span style=color:#666>[</span><span style=color:#b00040>U</span> <span style=color:green;font-weight:700>&gt;:</span> <span style=color:#b00040>T</span><span style=color:#666>](</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>U</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#666>[</span><span style=color:#b00040>U</span><span style=color:#666>](</span>leading<span style=color:#666>,</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>trailing</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这里的 <code>mirror</code> 使用了指令式编程的方式，目的是体现出，虽然这个过程中出现了关于类型参数 <code>T</code> 的 get 和 set 参数（修改 <code>leading</code> 和 <code>trailing</code> 的值），但我们完全不需要考虑变型问题，因为对象内部的 <code>T</code> 是已经确定的。所以，<code>private[this]</code> 的变量不会进行编译期的变型检查，只会进行基本的类型检查。</p><p>类似地，对于逆变的情况，也可以有上界。例如，对于一个排序函数，需要有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> mergeSort<span style=color:#666>[</span><span style=color:#b00040>T</span> <span style=color:green;font-weight:700>&lt;:</span> <span style=color:#b00040>Ordered</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]](</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span></code></pre></div><p>这样，我们要求传入的列表中的对象必须是 <code>Ordered[T]</code> 的子类型。不过，这并不是使用 <code>Ordered</code> 特质的最佳方式。</p><h1 id=抽象成员>抽象成员
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e6%88%90%e5%91%98>#</a></h1><h2 id=抽象成员的种类>抽象成员的种类
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e6%88%90%e5%91%98%e7%9a%84%e7%a7%8d%e7%b1%bb>#</a></h2><p>一个包括各种抽象成员的例子：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>Abstract</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>type</span> <span style=color:#b00040>T</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> transform<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> initial<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>var</span> current<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Concrete</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Abstract</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>type</span> <span style=color:#b00040>T</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>String</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> transform<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> x <span style=color:#666>+</span> x
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> initial <span style=color:green;font-weight:700>=</span> <span style=color:#ba2121>&#34;hi&#34;</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>var</span> current <span style=color:green;font-weight:700>=</span> initial
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这里的抽象成员包括类型成员、函数、可变变量和不可变变量。</p><p>首先，定义抽象类型的目的是形成一个别名（alias）。这样做的目的通常是隐藏一个复杂而含义不明显的类型，也可以使用 <code>&lt;:</code> 或 <code>>:</code>。然后，在后面的类定义中就可以使用这个别名。</p><p>之前我们已经知道，<code>def</code> <code>val</code> <code>var</code> 对调用者来说并没有本质的区别。但当继承这个定义的时候，<code>val</code> 的下游只能是 <code>val</code>，所以每一次重复调用它，返回值都应该是相同的。<code>def</code> 则无法做出这样的保证。也就是说，可以用 <code>val</code> 来定义抽象的 <code>def</code>，但不能反过来。</p><h2 id=抽象-val-的初始化时机>抽象 val 的初始化时机
<a class=anchor href=#%e6%8a%bd%e8%b1%a1-val-%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e6%97%b6%e6%9c%ba>#</a></h2><p>考虑之前出现过的有理数类：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>RationalTrait</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> numerArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>val</span> denomArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Rational</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> numerArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>val</span> denomArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>RationalTrait</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>RationalTrait</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> numerArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>val</span> denomArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// $anon$1@1c00d406
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Rational</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// Rational@67cd84f9
</span></span></span></code></pre></div><p>这两种方式看起来似乎是一样的。但实际上，二者的参数初始化时间存在区别。使用类的情况下，<code>1</code> 和 <code>2</code> 是作为参数被传入，（在非传名参数的情况下）是先求值，再传入。而在使用 <code>new trait</code> 的情况下，则会先初始化 <code>RationalTrait</code>，再传入这两个值。如果我们加上一个能够检测这种情况的条件：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>RationalTrait</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> numerArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>val</span> denomArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>;</span> require<span style=color:#666>(</span>numerArg <span style=color:#666>&gt;</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>RationalTrait</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> numerArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>val</span> denomArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// java.lang.IllegalArgumentException: requirement failed
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at scala.Predef$.require(Predef.scala:268)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at RationalTrait.$init$(&lt;console&gt;:11)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ... 29 elided
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>new</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> numerArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>val</span> denomArg <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span> <span style=color:#666>}</span> <span style=color:green;font-weight:700>with</span> <span style=color:#00f;font-weight:700>RationalTrait</span>  <span style=color:#408080;font-style:italic>// $anon$1@2ba0b7cf
</span></span></span></code></pre></div><p>在进行 <code>require</code> 判断时，这两个变量的值还是默认值 0，所以抛出了异常。在 Trait 初始化完成之后，才会被赋上值。如果采用混入的方式，那么这两个变量会仙贝初始化，然后才会调用父类的构造方法，不会发生这个问题。</p><p>当然，一种更优雅的方式是将 <code>require</code> 语句放在 <code>lazy val</code> 的初始化中去，这在逻辑上也更合理。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>trait</span> <span style=color:#00f;font-weight:700>LazyRationalTrait</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> numerArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> denomArg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>lazy</span> <span style=color:green;font-weight:700>val</span> <span style=color:green;font-weight:700>=</span> numerArg <span style=color:#666>/</span> g
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>lazy</span> <span style=color:green;font-weight:700>val</span> <span style=color:green;font-weight:700>=</span> denomArg <span style=color:#666>/</span> g
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>lazy</span> <span style=color:green;font-weight:700>val</span> g <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    require<span style=color:#666>(</span>denomArg <span style=color:#666>!=</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>    gcd<span style=color:#666>(</span>numberArg<span style=color:#666>,</span> denomArg<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>def</span> gcd<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> b<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>b <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> a <span style=color:green;font-weight:700>else</span> gcd<span style=color:#666>(</span>b<span style=color:#666>,</span> a <span style=color:#666>%</span> b<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>显然，如果 <code>lazy val</code> 的初始化涉及到副作用，初始化时间的情况将会变得相当复杂。所以，这个特性和函数式数据结构结合得更加紧密。</p><h2 id=抽象类型的作用>抽象类型的作用
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb%e5%9e%8b%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h2><p>考虑这样的情况：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>B</span> <span style=color:green;font-weight:700>extends</span> A
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>C</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> consume<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>D</span> <span style=color:green;font-weight:700>extends</span> C <span style=color:#666>{</span> <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> consume<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> print<span style=color:#666>(</span>x<span style=color:#666>)</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:14: error: class D needs to be abstract, since method consume in class C of type (x: A)Unit is not defined
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// (Note that A does not match B: class B is a subclass of class A, but method parameter types must match exactly.)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        class D extends C { override def consume(x: B) = print(x) }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//              ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:14: error: method consume overrides nothing.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Note: the super classes of class D contain the following, non final members named consume:
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// def consume(x: A): Unit
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        class D extends C { override def consume(x: B) = print(x) }
</span></span></span></code></pre></div><p>我们发现，<code>consume(x: B)</code> 无法重写 <code>consume(x: A)</code>，因为它们接收不同类型的参数。那么如果我们希望限制 <code>D</code> 类型中 <code>consume</code> 方法能够接收的参数类型呢？留下一个废弃的 <code>consume(x: A)</code> 显然不合适，允许重写更不合理。如果我们使用抽象类型：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>C</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>type</span> <span style=color:#b00040>T</span> <span style=color:green;font-weight:700>&lt;:</span> <span style=color:#b00040>A</span>  <span style=color:#408080;font-style:italic>// a type that is subclass of A
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>  <span style=color:green;font-weight:700>def</span> consume<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>T</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>D</span> <span style=color:green;font-weight:700>extends</span> C <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>type</span> <span style=color:#b00040>T</span> <span style=color:#666>=</span> B
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> consume<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> print<span style=color:#666>(</span>x<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> D<span style=color:#666>)</span> consume <span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> B<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// $line46.$read$$iw$$iw$B@43687885
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> D<span style=color:#666>)</span> consume <span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:15: error: type mismatch;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  found   : A
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  required: B
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        (new D) consume (new A)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                         ^
</span></span></span></code></pre></div><p>这样，我们就限制了子类中参数的类型。</p><p>此外，这样定义的类型限制是<strong>路径依赖</strong>的。体现为，如果我们将一个 <code>D</code> 对象放在 <code>C</code> 引用中，那么抛出的 <code>type mismatch</code> 将会是：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>C</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> D  <span style=color:#408080;font-style:italic>// d: C = D@1eb3b8c0
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span>d<span style=color:#666>.</span>consume<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:15: error: type mismatch;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  found   : A
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  required: d.T
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        d.consume(new A)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                  ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> d<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>C</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> D <span style=color:#666>}).</span>d<span style=color:#666>.</span>consume<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:16: error: type mismatch;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  found   : A
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  required: _1.T where val _1: C
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        (new { val d: C = new D }).d.consume(new A)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                                             ^
</span></span></span></code></pre></div><p>可以看到，因为引用是 <code>C</code> 类型的，我们无法直接知道所需的 <code>T</code> 是哪一个实际类型，但是我们知道这个 <code>T</code> 是 <code>d</code> 对象中的，也就是说这个类型依赖于其（对象引用的）路径。具体来说，依赖于这些对象所属的类，有点类似于 Java 的内部类。不过，对于内部类的情况，Scala 使用 <code>#</code> 作为连接符。</p><h2 id=改良类型-refinement-type>改良类型 refinement type
<a class=anchor href=#%e6%94%b9%e8%89%af%e7%b1%bb%e5%9e%8b-refinement-type>#</a></h2><p>抽象类型甚至让 Scala 具有了一定程度上类似于 duck type（没错）的能力。例如，在上面的例子中，如果我们想要一个类型，能够包括所有接收 <code>B</code> 类型的 <code>C</code>（例如，所有食草的动物），那么就有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> cThatTakesBs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>C</span> <span style=color:#666>{</span><span style=color:green;font-weight:700>type</span> <span style=color:#b00040>T</span> <span style=color:#b00040>=</span> <span style=color:#b00040>B</span><span style=color:#666>}]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>...</span>
</span></span></code></pre></div><p>这样我们就无需为一系列" <code>T</code> 为 <code>B</code> 的对象"定义一个麻烦的容易忘记的新 trait 了，也能够更加肆无忌惮地使用 <code>new</code> <code>object</code> <code>with</code> 等语法来创建匿名类了。与 duck typing 相比，Scala 的这种能力需要我们在父类中提前做好设计（又一次，类型驱动设计），但相比于 Python 的按方法名判断，这种方式显然要安全得多。鸭子类型和改良类型都是实现"结构子类型"的一种方式，即由对象的结构决定其类型，而非传统的反过来的"名义子类型"，只有显式继承的才算是子类。</p><h2 id=枚举-enumeration>枚举 Enumeration
<a class=anchor href=#%e6%9e%9a%e4%b8%be-enumeration>#</a></h2><p>由于路径依赖类型的存在，Scala 不需要像很多语言一样让编译器额外处理枚举类型（再一次体现了 Scala 简单的基本语法延伸出复杂的用法和功能）。只需要继承一个类即可：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Color</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Enumeration</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> <span style=color:#00f;font-weight:700>Red</span> <span style=color:green;font-weight:700>=</span> value
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> <span style=color:#00f;font-weight:700>Green</span> <span style=color:green;font-weight:700>=</span> value
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Color</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Enumration</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> <span style=color:#00f;font-weight:700>Red</span><span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Green</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Value</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>Color._</span>
</span></span></code></pre></div><p><code>Enumeration</code> 类的核心部分大致上是：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Enumeration</span> <span style=color:#666>(</span>initial<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Serializable</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>protected</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>def</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Value</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>nextId<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>protected</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>def</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Value</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>i<span style=color:#666>,</span> nextNameOrNull<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>protected</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>def</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>name<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Value</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>nextId<span style=color:#666>,</span> name<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>protected</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>def</span> <span style=color:#00f;font-weight:700>Value</span><span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> name<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Value</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>Val</span><span style=color:#666>(</span>i<span style=color:#666>,</span> name<span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Value</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Ordered</span><span style=color:#666>[</span><span style=color:#b00040>Value</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>with</span> <span style=color:#00f;font-weight:700>Serializable</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>protected</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Val</span><span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> name<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Value</span> <span style=color:green;font-weight:700>with</span> <span style=color:#00f;font-weight:700>Serializable</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>所以，不同的 <code>object extends Enumeration</code> 里的 <code>Value</code> 类，由于路径依赖不能兼容，使得不同枚举类的元素之间不能互相兼容。</p><h1 id=隐式定义>隐式定义
<a class=anchor href=#%e9%9a%90%e5%bc%8f%e5%ae%9a%e4%b9%89>#</a></h1><h2 id=隐式转换>隐式转换
<a class=anchor href=#%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2>#</a></h2><p>在使用隐式转换时，编译器会首先尝试编译。如果类型不能匹配，编译器会在作用域中寻找合适的隐式转换。查找隐式转换的范围是，作用域中所有的"单个标识符"，也就是直接定义在作用域里，而不是某个对象里，再加上源类型与目标类型的伴生对象里。例如，当前作用域下一个变量 <code>someVar.String2Int</code> 不会被搜索，但 <code>String</code> 类和 <code>Int</code> 类对应的伴生对象中的方法都会被搜索。此外，Scala 的隐式转换只能进行一次，不会发生难以控制的链式多次转换的情况。也不会覆盖显式的定义，只要能通过类型检查，就不会调用隐式转换。</p><p>例如，<code>Predef</code> 中定义了数字之间互相转换的函数。再一次，Scala 通过一个通用的语言特性解决了一种"特殊情况"。（虽然 Scala 编译器仍然进行了特殊情况的处理，生成了效率更高的字节码）。</p><p>隐式定义会出现在三个地方：转换到预期的类型，选择接收端和隐式参数。分别对应这样的方式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>scala.language.implicitConversions</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>B</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> run <span style=color:green;font-weight:700>=</span> println<span style=color:#666>(</span><span style=color:#ba2121>&#34;B.run&#34;</span><span style=color:#666>)</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>def</span> a2b<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> B
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> y <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> B
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> fun<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> println<span style=color:#666>(</span><span style=color:#ba2121>&#34;obj B in fun&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> func<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)(</span><span style=color:green;font-weight:700>implicit</span> y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> y<span style=color:#666>.</span>run
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>fun<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>)</span>   <span style=color:#408080;font-style:italic>// converting to a expected type
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// obj B in fun
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>).</span>run  <span style=color:#408080;font-style:italic>// converting the receiver
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// B.run
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>func<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> A<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// implicit parameters
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// B.run
</span></span></span></code></pre></div><p>隐式转换适合用来创建 DSL。例如，用来创建 Map 的语法就是使用隐式转换制作的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>Map</span><span style=color:#666>(</span><span style=color:#666>1</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;one&#34;</span><span style=color:#666>,</span> <span style=color:#666>2</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;two&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>package</span> <span style=color:#00f;font-weight:700>scala</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Predef</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>ArrowAssoc</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>](</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> self<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Anyval</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>@inine</span> <span style=color:green;font-weight:700>def</span> <span style=color:#666>-&gt;</span> <span style=color:#666>[</span><span style=color:#b00040>B</span><span style=color:#666>](</span>y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span><span style=color:#00f;font-weight:700>Tuple2</span><span style=color:#666>[</span><span style=color:#b00040>A</span>, <span style=color:#b00040>B</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Tuple2</span><span style=color:#666>(</span>self<span style=color:#666>,</span> y<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// or, seperated class and function
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Predef</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>ArrowAssoc</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>](</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> self<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Anyval</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#a2f>@inine</span> <span style=color:green;font-weight:700>def</span> <span style=color:#666>-&gt;</span> <span style=color:#666>[</span><span style=color:#b00040>B</span><span style=color:#666>](</span>y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span><span style=color:#666>)</span><span style=color:#00f;font-weight:700>Tuple2</span><span style=color:#666>[</span><span style=color:#b00040>A</span>, <span style=color:#b00040>B</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Tuple2</span><span style=color:#666>(</span>self<span style=color:#666>,</span> y<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>def</span> any2ArrowAssoc<span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>](</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>ArrowAssoc</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>ArrowAssoc</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>其中上面一种方式称作隐式类，相当于一个类定义和一个以其构造方法为形式的隐式转换函数。显然其构造方法必须是单参数的。Scala 还限制隐式类必须存在于另一个对象、类或特质里，这样就一定程度上限制了隐式类的滥用。</p><h2 id=隐式参数>隐式参数
<a class=anchor href=#%e9%9a%90%e5%bc%8f%e5%8f%82%e6%95%b0>#</a></h2><p>隐式参数常被用在提供一个多次用到的通用值的情形。例如定义一个命令提示符：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>PreferedPrompt</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> preference<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> printWithPrompt<span style=color:#666>(</span>str<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)(</span><span style=color:green;font-weight:700>implicit</span> prompt<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PreferedPrompt</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span>
</span></span><span style=display:flex><span>  println<span style=color:#666>(</span>prompt<span style=color:#666>.</span>preference <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> str<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> prompt <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>PreferedPrompt</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;&gt;&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>printWithPrompt<span style=color:#666>(</span><span style=color:#ba2121>&#34;run&#34;</span><span style=color:#666>)(</span>prompt<span style=color:#666>)</span>
</span></span><span style=display:flex><span>printWithPrompt<span style=color:#666>(</span><span style=color:#ba2121>&#34;run&#34;</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>常见的方式是将默认值放在一个对象中，再 <code>import obj._</code>。</p><p>同时，我们在这里专门为隐式参数定义了一个类，而不是使用 String。这是为了避免不必要的额外匹配的风险，因为隐式转换<strong>只寻找类型</strong>而不判断变量名。隐式参数在 Scala 中最常见的场景是用于排序，排序函数的第二个参数列表里通常是一个 <code>Ordering[T]</code> 对象。显然，这里的功能只需要一个 <code>(T, T) => Boolean</code> 类型的参数就能完成，但这样的类型太过泛化，风险比较高。</p><p>考虑一个常见的排序函数的递归实现：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sort<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>l<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])(</span><span style=color:green;font-weight:700>implicit</span> ordering<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Ordering</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span>  sort<span style=color:#666>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>ordering<span style=color:#666>.</span>gt<span style=color:#666>(...))</span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>和我们的直觉相符，Scala 会直接把外层的函数接收的 <code>ordering</code> 作为隐式参数继续使用，也可以直接去调用这个参数。那么，有没有可能不去显式地写 <code>ordering</code> 这个变量名呢？（毕竟它是隐式的）</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sort<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>l<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])(</span><span style=color:green;font-weight:700>implicit</span> ordering<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Ordering</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>implicitly<span style=color:#666>[</span><span style=color:#b00040>Ordering</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]].</span>gt<span style=color:#666>(...))</span>
</span></span><span style=display:flex><span>  <span style=color:#666>...</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p><code>implicitly</code> 是 Scala 定义的一个用于查找一定类型的隐式参数的函数。现在我们发现，有了这种查找方式，我们实际上已经不再需要 <code>ordering</code> 这个变量名了。所以，进一步地，我们可以直接去修改类型参数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sort<span style=color:#666>[</span><span style=color:#b00040>T:</span> <span style=color:#b00040>Ordering</span><span style=color:#666>](</span>l<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>...</span>
</span></span></code></pre></div><p>这样定义意味着要求类型参数 <code>T</code> 必须有相应的 <code>ordering</code>。一个很好的性质是，通过这种方式，我们并不需要修改 <code>T</code> 类型。例如，一个外部库里有一个类型 A，当我们对 A 排序时，不需要修改 A 使其实现 <code>Comparable</code>，而只需要提供一个 <code>Ordering[A]</code>。</p><p>另外一个需要解决的问题是隐式定义的冲突。在 Scala 2.8 之后，采用了和方法重载类似的方式：优先选择"更具体"的那一个。如果同样具体，就需要手动指定。在静态类型语言中，这并不是什么大问题：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> v<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>AnyVal</span> <span style=color:#666>=</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>implicitly<span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span>     <span style=color:#408080;font-style:italic>// 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>implicitly<span style=color:#666>[</span><span style=color:#b00040>AnyVal</span><span style=color:#666>]</span>  <span style=color:#408080;font-style:italic>// 2, which is the more specific one
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> ii<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>3</span>
</span></span><span style=display:flex><span>implicitly<span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span>  <span style=color:#408080;font-style:italic>// ambiguous implicit value 2 and 3 with same weight
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &lt;console&gt;:15: error: ambiguous implicit values:
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  both value i of type =&gt; Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  and value ii of type =&gt; Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  match expected type Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//        implicitly[Int]
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                  ^
</span></span></span></code></pre></div><p>可以使用 <code>-Xprint:typer</code> 参数来查看发生的隐式转换。</p><h2 id=隐式转换的优先级>隐式转换的优先级
<a class=anchor href=#%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2%e7%9a%84%e4%bc%98%e5%85%88%e7%ba%a7>#</a></h2><p>并不是所有隐式转换都会显式发生冲突。例如，<code>String</code> 有两个隐式转换，一个转换成 <code>WrappedString</code>，其方法返回的仍然是 <code>WrappedString</code>。另一个是 <code>StringOps</code>，其返回值仍然是 <code>String</code>，第二个的优先级更高。这样，如果我们需要一个 <code>Seq</code>，会得到 <code>WrappedString</code>，否则仍然得到一个 <code>String</code>。这样的原因是 <code>StringOps</code> 的转换位于 <code>Predef</code>，<code>WrappedString</code> 的转换位于 <code>scala.LowPriorityImplicits</code>。Scala 选择隐式转换的原则是：</p><ul><li>更具体类型的隐式转换优先级更高。</li><li>如果 <code>A extends B</code>，那么 <code>B</code> 中的优先级更高。</li></ul><p>考虑我们定义一个类继承另一个类，那么子类中的隐式很可能更加是我们想要的。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span> <span style=color:#666>=</span> <span style=color:#ba2121>&#34;a&#34;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> b<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>CharSequence</span> <span style=color:#666>=</span> <span style=color:#ba2121>&#34;b&#34;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span><span style=color:green;font-weight:700>implicit</span> s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f  <span style=color:#408080;font-style:italic>// a
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span> <span style=color:#666>=</span> <span style=color:#ba2121>&#34;a&#34;</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>B</span> <span style=color:green;font-weight:700>extends</span> A <span style=color:#666>{</span> <span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>val</span> b<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span> <span style=color:#666>=</span> <span style=color:#ba2121>&#34;b&#34;</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span><span style=color:green;font-weight:700>implicit</span> s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> s
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>B._</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f  <span style=color:#408080;font-style:italic>// b
</span></span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#类型参数化>类型参数化</a><ul><li><a href=#一个摊还-o1-复杂度的函数式队列>一个摊还 O(1) 复杂度的函数式队列</a></li><li><a href=#泛型变型>泛型变型</a><ul><li><a href=#变型>变型</a></li><li><a href=#下界和上界>下界和上界</a></li></ul></li></ul></li><li><a href=#抽象成员>抽象成员</a><ul><li><a href=#抽象成员的种类>抽象成员的种类</a></li><li><a href=#抽象-val-的初始化时机>抽象 val 的初始化时机</a></li><li><a href=#抽象类型的作用>抽象类型的作用</a></li><li><a href=#改良类型-refinement-type>改良类型 refinement type</a></li><li><a href=#枚举-enumeration>枚举 Enumeration</a></li></ul></li><li><a href=#隐式定义>隐式定义</a><ul><li><a href=#隐式转换>隐式转换</a></li><li><a href=#隐式参数>隐式参数</a></li><li><a href=#隐式转换的优先级>隐式转换的优先级</a></li></ul></li></ul></nav></div></aside></main></body></html>