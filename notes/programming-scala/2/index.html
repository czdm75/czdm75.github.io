<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="函数和闭包 #  局部函数 #  通常，对于小的 &ldquo;工具函数&rdquo;，我们会使用私有函数来处理：
object Util {  def a(): Unit = {  val a = 1;  // sth  b(a)  }   private def b(i: Int): Unit {  // do sth  print(i)  } } 通过私有函数，我们避免了 b 函数对整个 Util 对象的调用者的污染。不过，对于 Util 本身的编写者来说，如果 b 函数没有别的用处，仍然有些污染视线。因此，可以：
object Util {  def a(): Unit = {  val a = 1;  // do sth   def b(): Unit = {  // do sth  print(a)  }   b()  } } 与上面的实现的区别是，因为作用域共享，我们无需为 b 设定参数，它可以直接访问外面的 a 变量。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="2. Functions"><meta property="og:description" content="函数和闭包 #  局部函数 #  通常，对于小的 &ldquo;工具函数&rdquo;，我们会使用私有函数来处理：
object Util {  def a(): Unit = {  val a = 1;  // sth  b(a)  }   private def b(i: Int): Unit {  // do sth  print(i)  } } 通过私有函数，我们避免了 b 函数对整个 Util 对象的调用者的污染。不过，对于 Util 本身的编写者来说，如果 b 函数没有别的用处，仍然有些污染视线。因此，可以：
object Util {  def a(): Unit = {  val a = 1;  // do sth   def b(): Unit = {  // do sth  print(a)  }   b()  } } 与上面的实现的区别是，因为作用域共享，我们无需为 b 设定参数，它可以直接访问外面的 a 变量。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/programming-scala/2/"><meta property="article:section" content="notes"><title>2. Functions | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle checked>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/ class=active>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>2. Functions</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#函数和闭包>函数和闭包</a><ul><li><a href=#局部函数>局部函数</a></li><li><a href=#简化函数字面量>简化函数字面量</a></li><li><a href=#部分应用函数-partially-applied-function>部分应用函数 Partially Applied Function</a></li><li><a href=#闭包-closure>闭包 Closure</a></li><li><a href=#变长参数命名参数默认参数>变长参数，命名参数，默认参数</a></li><li><a href=#尾递归>尾递归</a></li><li><a href=#柯里化-currying>柯里化 Currying</a></li></ul></li><li><a href=#控制抽象>控制抽象</a><ul><li><a href=#减少代码重复>减少代码重复</a></li><li><a href=#柯里化>柯里化</a></li><li><a href=#编写控制结构--传名参数by-name-parameter>编写控制结构 & 传名参数（by-name parameter）</a></li></ul></li><li><a href=#组合与继承>组合与继承</a><ul><li><a href=#抽象类>抽象类</a></li><li><a href=#扩展一个类>扩展一个类</a></li><li><a href=#完善类库实现方法定义工厂>完善类库：实现方法，定义工厂</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=函数和闭包>函数和闭包
<a class=anchor href=#%e5%87%bd%e6%95%b0%e5%92%8c%e9%97%ad%e5%8c%85>#</a></h1><h2 id=局部函数>局部函数
<a class=anchor href=#%e5%b1%80%e9%83%a8%e5%87%bd%e6%95%b0>#</a></h2><p>通常，对于小的 &ldquo;工具函数&rdquo;，我们会使用私有函数来处理：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Util</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> a<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Unit</span> <span style=color:#666>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// sth
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    b<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>def</span> b<span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Unit</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// do sth
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:#b00040>print</span><span style=color:#666>(</span><span style=color:#b00040>i</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>通过私有函数，我们避免了 <code>b</code> 函数对整个 <code>Util</code> 对象的调用者的污染。不过，对于 <code>Util</code> 本身的编写者来说，如果 <code>b</code> 函数没有别的用处，仍然有些污染视线。因此，可以：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Util</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> a<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Unit</span> <span style=color:#666>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// do sth
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>def</span> b<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Unit</span> <span style=color:#666>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:#408080;font-style:italic>// do sth
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>      print<span style=color:#666>(</span>a<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    b<span style=color:#666>()</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>与上面的实现的区别是，因为作用域共享，我们无需为 <code>b</code> 设定参数，它可以直接访问外面的 <code>a</code> 变量。</p><h2 id=简化函数字面量>简化函数字面量
<a class=anchor href=#%e7%ae%80%e5%8c%96%e5%87%bd%e6%95%b0%e5%ad%97%e9%9d%a2%e9%87%8f>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x<span style=color:#666>+</span><span style=color:#666>1</span>  <span style=color:#408080;font-style:italic>// Int =&gt; Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//因为前面的对象是 List[Int], x 的类型被推断为 Int
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span><span style=color:#666>1</span> <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span>2</span> <span style=color:#b00040>::</span> <span style=color:#b00040>Nil</span><span style=color:#666>).</span>filter<span style=color:#666>(</span>x <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>&gt;</span> <span style=color:#666>1</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List[Int] = List(2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// 常见的 PlaceHolder 语法
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span><span>2</span><span style=color:#b00040>::Nil</span><span style=color:#666>).</span>filter<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>&gt;</span> <span style=color:#666>1</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List[Int] = List(2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:#666>+</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// (Int, Int) =&gt; Int
</span></span></span></code></pre></div><p>显然，在 <code>_+_</code> 这种语法中，每个参数只能出现一次。</p><h2 id=部分应用函数-partially-applied-function>部分应用函数 Partially Applied Function
<a class=anchor href=#%e9%83%a8%e5%88%86%e5%ba%94%e7%94%a8%e5%87%bd%e6%95%b0-partially-applied-function>#</a></h2><p>下划线也可以用来一次代替多个参数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sum<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> b<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> a <span style=color:#666>+</span> b<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> sum <span style=color:green;font-weight:700>_</span>
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>这时，实际上我们就定义了一个部分应用函数（虽然这里并不"部分"）。总之，部分应用函数意味着你并不提供所有的参数，而是提供几个，或者不提供参数（如上）。上面的 <code>sum</code> 函数也可以被这样使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> plus3 <span style=color:green;font-weight:700>=</span> sum<span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>_:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>plus3<span style=color:#666>(</span><span style=color:#666>4</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>进一步，如果我们在不提供任何参数的情况下再去掉下划线，就得到了：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>).</span>foreach<span style=color:#666>(</span>println<span style=color:#666>)</span>
</span></span></code></pre></div><p>这就相当于我们直接把函数 <code>println</code> 传入。</p><p>不过，这种省略下划线的形式要求 <code>foreach</code> 的参数本来就是一个函数类型。考虑这样的情况：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>4</span><span style=color:#666>,</span> <span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:#666>6</span><span style=color:#666>)).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>tail<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>4</span><span style=color:#666>,</span> <span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:#666>6</span><span style=color:#666>)).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>drop<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>4</span><span style=color:#666>,</span> <span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:#666>6</span><span style=color:#666>)).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>drop<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: missing argument list for method drop in class List
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Unapplied methods are only converted to functions when a function type is expected.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// You can make this conversion explicit by writing `drop _` or `drop(_)` instead of `drop`.
</span></span></span></code></pre></div><p>在"纯函数式语言"，如 ML 和 Haskell 中，或者 Python 这样追求简单和统一的语言中，第三种写法通常是有效的。不过，这样做的结果通常只是打印出一串 <code>&lt;function></code>，这是 <code>drop</code> 这个函数对象的类型。正因为这个原因，所以有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>sum
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: missing argument list for method sum
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Unapplied methods are only converted to functions when a function type is expected.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// You can make this conversion explicit by writing `sum _` or `sum(_,_)` instead of `sum`.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   sum
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>sum <span style=color:green;font-weight:700>_</span>  <span style=color:#408080;font-style:italic>// (Int, Int) =&gt; Int
</span></span></span></code></pre></div><h2 id=闭包-closure>闭包 Closure
<a class=anchor href=#%e9%97%ad%e5%8c%85-closure>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>var</span> c <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span><span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>+</span> c
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span>c <span style=color:green;font-weight:700>=</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 3
</span></span></span></code></pre></div><p>与 Java 8 不同，Scala 允许函数访问外部的可变的变量，这也带来了一些复杂的问题，例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> more <span style=color:green;font-weight:700>=</span> <span style=color:#666>3</span>  <span style=color:#408080;font-style:italic>// won&#39;t be used
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Int</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> more <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span>  <span style=color:#666>(</span>y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> y <span style=color:#666>+</span> x <span style=color:#666>+</span> more
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> fun <span style=color:green;font-weight:700>=</span> f<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>fun<span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 6
</span></span></span></code></pre></div><p>这个例子有点复杂，其核心内容是，函数 <code>f</code> 中的变量 <code>x</code> 和 <code>more</code> 在调用 <code>fun</code> 时都已经离开了作用域，因为 <code>f</code> 函数已经返回。好在，Scala 帮助我们在闭包里保留了正确的值。</p><h2 id=变长参数命名参数默认参数>变长参数，命名参数，默认参数
<a class=anchor href=#%e5%8f%98%e9%95%bf%e5%8f%82%e6%95%b0%e5%91%bd%e5%90%8d%e5%8f%82%e6%95%b0%e9%bb%98%e8%ae%a4%e5%8f%82%e6%95%b0>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> print<span style=color:#666>(</span>args<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String*</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> args<span style=color:#666>.</span>foreach<span style=color:#666>(</span>println<span style=color:#666>)</span>
</span></span><span style=display:flex><span>print<span style=color:#666>(</span><span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;bcd&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>print<span style=color:#666>(</span><span style=color:#00f;font-weight:700>Array</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;bcd&#34;</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: type mismatch;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// found   : Array[String]
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// required: String
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   print(Array(&#34;abc&#34;, &#34;bcd&#34;))
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                  ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>print<span style=color:#666>(</span><span style=color:#00f;font-weight:700>Array</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;bcd&#34;</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:green;font-weight:700>_</span><span style=color:#b00040>*</span><span style=color:#666>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sum<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> b<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>3</span><span style=color:#666>,</span> c<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>4</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> a<span style=color:#666>+</span>b<span style=color:#666>+</span>c
</span></span><span style=display:flex><span>sum<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> c <span style=color:green;font-weight:700>=</span> <span style=color:#666>5</span><span style=color:#666>)</span>
</span></span></code></pre></div><h2 id=尾递归>尾递归
<a class=anchor href=#%e5%b0%be%e9%80%92%e5%bd%92>#</a></h2><p>Scala 会把尾递归优化为一个跳回函数开头的指令。例如，下面两种写法是等价的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> find5<span style=color:#666>(</span>num<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>var</span> n <span style=color:green;font-weight:700>=</span> num
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>while</span> <span style=color:#666>(</span>num <span style=color:#666>!=</span> <span style=color:#666>5</span><span style=color:#666>)</span> n<span style=color:#666>++</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> find5<span style=color:#666>(</span>num<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> num <span style=color:#666>!=</span> <span style=color:#666>5</span> find5<span style=color:#666>(</span>n<span style=color:#666>+</span><span style=color:#666>1</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>else</span> num
</span></span></code></pre></div><p>这样，尾递归在内存和CPU的代价上都和循环一样，却避免了 <code>var</code> 的出现。不过，这样做会让 debug 时的堆栈看起来不太一样。可以使用 <code>-g:notailcalls</code> 来关闭尾递归。</p><p>限于 JVM 的能力，Scala 进行的尾递归比较有限，并没有对间接的尾递归进行优化。例如两个函数交替调用的情况：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> isEven<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>true</span> <span style=color:green;font-weight:700>else</span> isOdd<span style=color:#666>(</span>x <span style=color:#666>-</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> isOdd<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>x <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>false</span> <span style=color:green;font-weight:700>else</span> isEven<span style=color:#666>(</span>x <span style=color:#666>-</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span></code></pre></div><h2 id=柯里化-currying>柯里化 Currying
<a class=anchor href=#%e6%9f%af%e9%87%8c%e5%8c%96-currying>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> oldSum<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> x <span style=color:#666>+</span> y
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sum<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)(</span>y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> x <span style=color:#666>+</span> y
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> curried<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:#666>(</span>y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>+</span> y
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> curried<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> plusOne <span style=color:green;font-weight:700>=</span> sum<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>_</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 3
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>plusOne<span style=color:#666>(</span><span style=color:#666>2</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 3
</span></span></span></code></pre></div><p>在 <code>curried</code> 函数的定义中，为了视觉上更加清楚，加上了大括号。</p><h1 id=控制抽象>控制抽象
<a class=anchor href=#%e6%8e%a7%e5%88%b6%e6%8a%bd%e8%b1%a1>#</a></h1><h2 id=减少代码重复>减少代码重复
<a class=anchor href=#%e5%87%8f%e5%b0%91%e4%bb%a3%e7%a0%81%e9%87%8d%e5%a4%8d>#</a></h2><p>上一章的内容，有些让人觉得 Scala 中传递函数略显麻烦，但接下来我们就能看到这样做的好处。在 Python 这类动态语言中，我们常常会将一个函数作为参数传入，以便复用代码。作为静态语言，Scala 不能随意把函数直接传入，而是通过上一章的那些隐式转换达到同样的效果。在 Python 中，我们可能会这样做：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:green;font-weight:700>def</span> <span style=color:#00f>files_maching</span>(query, method):
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>for</span> f <span style=color:#a2f;font-weight:700>in</span> get_files():
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> method(f<span style=color:#666>.</span>get_name, query):
</span></span><span style=display:flex><span>            <span style=color:green;font-weight:700>yield</span> f
</span></span></code></pre></div><p>这里的 <code>method</code> 可以是字符串的 <code>contain</code> <code>regex_match</code> 之类的函数。总之，到了 Scala，我们通常会这样做：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> filesMatching<span style=color:#666>(</span>query<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>,</span> matcher<span style=color:green;font-weight:700>:</span> <span style=color:#666>(</span><span style=color:#b00040>String</span><span style=color:#666>,</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>file <span style=color:green;font-weight:700>&lt;-</span> files<span style=color:#666>;</span> <span style=color:green;font-weight:700>if</span> matcher<span style=color:#666>(</span>file<span style=color:#666>.</span>getName<span style=color:#666>,</span> query<span style=color:#666>))</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>yield</span> file
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// caller
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>def</span> filesEnding<span style=color:#666>(</span>query<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> filesMatching<span style=color:#666>(</span>query<span style=color:#666>,</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>endsWith<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &#39;&#39;&#39;_.endsWith(_)&#39;&#39;&#39; is equivalent with
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// &#39;&#39;&#39;(fileName: String, query: String) =&gt; filename.endsWith(query)&#39;&#39;&#39;
</span></span></span></code></pre></div><p>仔细观察一下的话，我们还可以进一步简化：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> filesMatching<span style=color:#666>(</span>matcher<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>file <span style=color:green;font-weight:700>&lt;-</span> files<span style=color:#666>;</span> <span style=color:green;font-weight:700>if</span> matcher<span style=color:#666>(</span>file<span style=color:#666>))</span> <span style=color:green;font-weight:700>yield</span> file
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> filesEnding<span style=color:#666>(</span>query<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> filesMatching<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>endsWith<span style=color:#666>(</span>query<span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> filesContaining<span style=color:#666>(</span>query<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> filesMathcing<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>.</span>contains<span style=color:#666>(</span>query<span style=color:#666>))</span>
</span></span></code></pre></div><p>这类高阶函数在 Scala 类库中的应用，比如 <code>List</code> 类型的 <code>exists</code> 方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> containsOdd<span style=color:#666>(</span>nums<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> nums<span style=color:#666>.</span>exists<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>%</span> <span style=color:#666>2</span> <span style=color:#666>==</span> <span style=color:#666>1</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> containsNeg<span style=color:#666>(</span>nums<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> nums<span style=color:#666>.</span>exists<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>&lt;</span> <span style=color:#666>0</span><span style=color:#666>)</span>
</span></span></code></pre></div><h2 id=柯里化>柯里化
<a class=anchor href=#%e6%9f%af%e9%87%8c%e5%8c%96>#</a></h2><p>现在我们可以回头再看看柯里化了。柯里化常被用在与高阶函数相关的场景，使我们自己创建的函数看起来就像语言提供的特性一样。对上面的例子来说，<code>filesMatching</code> 函数还能够明显地看出我们编写的影子，<code>filesEnding</code> 函数使用起来就非常简单了。也就是说，柯里化通过将部分参数预先定义，让我们的 API 看起来更加简洁。对于 Haskell 这样每一个函数只允许一个参数的语言来说，几乎所有的函数都是柯里化的。</p><h2 id=编写控制结构--传名参数by-name-parameter>编写控制结构 & 传名参数（by-name parameter）
<a class=anchor href=#%e7%bc%96%e5%86%99%e6%8e%a7%e5%88%b6%e7%bb%93%e6%9e%84--%e4%bc%a0%e5%90%8d%e5%8f%82%e6%95%b0by-name-parameter>#</a></h2><p>先来考虑一个简单的情况，下面这个结构连续执行一个操作两次：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> twice<span style=color:#666>(</span>op<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Double</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Double</span><span style=color:#666>,</span> x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Double</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> op<span style=color:#666>(</span>op<span style=color:#666>(</span>x<span style=color:#666>))</span>
</span></span><span style=display:flex><span>twice<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>5</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// returns 7
</span></span></span></code></pre></div><p>理解了这个例子之后，我们再来考虑一个常见的实际场景： try-with-resources。我们很自然地会写出这样的代码：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> withPrintWriter<span style=color:#666>(</span>file<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>File</span><span style=color:#666>,</span> op<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PrintWriter</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Unit</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> writer <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>PrintWriter</span><span style=color:#666>(</span>file<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    op<span style=color:#666>(</span>writer<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span> <span style=color:green;font-weight:700>finally</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    writer<span style=color:#666>.</span>close<span style=color:#666>()</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>withPrintWriter<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>File</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;path/to/file&#34;</span><span style=color:#666>),</span> writer <span style=color:green;font-weight:700>=&gt;</span> writer<span style=color:#666>.</span>println<span style=color:#666>(</span><span style=color:#ba2121>&#34;something&#34;</span><span style=color:#666>))</span>
</span></span></code></pre></div><p>用我们目前为止得到的思维模式来考虑，将参数拆分成多个参数列表，代码和上面基本相同。单个参数的参数列表和多参数最大的区别是，我们就得以使用大括号来调用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> withPrintWriter<span style=color:#666>(</span>file<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>File</span><span style=color:#666>)(</span>op<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PrintWriter</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Unit</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> writer <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>PrintWriter</span><span style=color:#666>(</span>file<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>try</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    op<span style=color:#666>(</span>writer<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span> <span style=color:green;font-weight:700>finally</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    writer<span style=color:#666>.</span>close<span style=color:#666>()</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>withPrintWriter<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>File</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;path/to/file&#34;</span><span style=color:#666>))</span> <span style=color:#666>{</span> writer <span style=color:green;font-weight:700>=&gt;</span>
</span></span><span style=display:flex><span>  writer<span style=color:#666>.</span>println<span style=color:#666>(</span><span style=color:#ba2121>&#34;something&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这样的控制结构给了我们一种完全不同的思路。</p><p>不过，这样的结构和我们熟悉的 <code>try-catch</code> 块值类相比，多了一个参数 <code>writer</code>，看起来不太像原生的语言特性。如果我们并不需要在这里传入参数，能不能把参数部分也省略掉呢？考虑一个断言的实现：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> myAssert<span style=color:#666>(</span>predicate<span style=color:green;font-weight:700>:</span> <span style=color:#666>()</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>assertionEnabled <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>predicate<span style=color:#666>())</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>AssertionException</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myAssert<span style=color:#666>(()</span> <span style=color:green;font-weight:700>=&gt;</span> a <span style=color:#666>&gt;</span> b<span style=color:#666>)</span>
</span></span><span style=display:flex><span>myAssert<span style=color:#666>(</span>a <span style=color:#666>&gt;</span> b<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// won&#39;t compile
</span></span></span></code></pre></div><p>在这里，显然第二种调用方式更优雅一些，但在这样的实现中没有办法实现。因此，我们使用传名参数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> myAssert<span style=color:#666>(</span>predicate<span style=color:green;font-weight:700>:</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>assertionEnabled <span style=color:#666>&amp;&amp;</span> <span style=color:#666>!</span>predicate<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>AssertionException</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myAssert<span style=color:#666>(</span>a <span style=color:#666>&gt;</span> b<span style=color:#666>)</span>
</span></span></code></pre></div><p>当然，实际上还有另外一种实现方式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> myAssert<span style=color:#666>(</span>predicate<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>...</span>
</span></span></code></pre></div><p>这两种实现方式的区别在于断言条件被计算的时刻。如果直接实现为 <code>Boolean</code>，那么无论断言是否开启（<code>assersionEnabled</code>），<code>a > b</code> 都会被执行。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>var</span> assertionEnabled <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>false</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> myAssert<span style=color:#666>(</span>predicate<span style=color:green;font-weight:700>:</span> <span style=color:#666>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>assertionEnabled <span style=color:#666>&amp;&amp;</span> predicate<span style=color:#666>)</span> <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>AssertionError</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> boolAssert<span style=color:#666>(</span>predicate<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>assertionEnabled <span style=color:#666>&amp;&amp;</span> predicate<span style=color:#666>)</span> <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>AssertionError</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> pred<span style=color:#666>()</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>throw</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>RuntimeException</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>myAssert<span style=color:#666>(</span>pred<span style=color:#666>())</span>   <span style=color:#408080;font-style:italic>// no problem
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>boolAssert<span style=color:#666>(</span>pred<span style=color:#666>())</span> <span style=color:#408080;font-style:italic>// java.lang.RuntimeException
</span></span></span></code></pre></div><p>在断言关闭的情况下，如果断言条件抛出了异常，那么在使用 <code>predicate: => Boolean</code> 作为参数的实现中，<code>pred()</code> 将不会被执行，异常不会抛出。</p><h1 id=组合与继承>组合与继承
<a class=anchor href=#%e7%bb%84%e5%90%88%e4%b8%8e%e7%bb%a7%e6%89%bf>#</a></h1><p>在这一部分的例子中，我们将最终实现这样一个布局库：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> column1 <span style=color:green;font-weight:700>=</span> elem<span style=color:#666>(</span><span style=color:#ba2121>&#34;hello&#34;</span><span style=color:#666>)</span> above elem<span style=color:#666>(</span><span style=color:#ba2121>&#34;***&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> column2 <span style=color:green;font-weight:700>=</span> elem<span style=color:#666>(</span><span style=color:#ba2121>&#34;***&#34;</span><span style=color:#666>)</span> above elem<span style=color:#666>(</span><span style=color:#ba2121>&#34;world&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>column1 beside column2
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// hello ***
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  *** world
</span></span></span></code></pre></div><h2 id=抽象类>抽象类
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>]</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> height<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> contents<span style=color:#666>.</span>length
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> width<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>height <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> <span style=color:#666>0</span> <span style=color:green;font-weight:700>else</span> contents<span style=color:#666>(</span><span style=color:#666>0</span><span style=color:#666>).</span>length
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>首先我们定义了一个元素的抽象类。这里的三个方法都没有参数括号：这样，调用方也必须不加括号才能访问。</p><p>Scala 世界的通常做法是，对于那些不改变对象本身的方法调用，不加括号，使其看起来更像是一个成员变量。这样做的目的是，使得这个方法看起来很像一个成员变量。我们在解释 Java 为什么要使用 getter 时举了许多次的例子：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>int</span> length<span style=color:#666>;</span> <span style=color:#666>}</span>         <span style=color:#408080;font-style:italic>// version 1.0
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>int</span> <span style=color:#00f>length</span><span style=color:#666>(</span> <span style=color:#666>...</span> <span style=color:#666>);</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// version 2.0
</span></span></span></code></pre></div><p>这个问题在这里直接得到了解决，因为一个名为 <code>length</code> 的变量和一个名为 <code>length</code> 的方法对调用方来说没有任何区别：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>var</span> length <span style=color:#666>}</span>             <span style=color:#408080;font-style:italic>// version 1.0
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> length<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>...</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// version 2.0
</span></span></span></code></pre></div><p>从代码风格来讲，虽然所有的空括号都可以被省略，对于那些<strong>有副作用</strong>的方法，例如执行 IO、修改变量，总之涉及到 mutable 对象的方法，最好还是加上括号。典型的例子如 <code>println()</code>。</p><p>将字段和方法统一对待的这种方式被称为 Scala 的统一访问原则（the Uniform Access Principle）。</p><h2 id=扩展一个类>扩展一个类
<a class=anchor href=#%e6%89%a9%e5%b1%95%e4%b8%80%e4%b8%aa%e7%b1%bb>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span>conts<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> conts
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>由于上面我们提到的统一访问原则，你甚至可以用字段来 override 一个方法，这两种结构位于同一个命名空间内。出于同样的原因，这样的代码在 Java 里可行，在 Scala 里则不行：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:#b00040>int</span> i <span style=color:#666>=</span> 0<span style=color:#666>;</span> <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>int</span> <span style=color:#00f>i</span><span style=color:#666>(</span> <span style=color:green;font-weight:700>return</span> 0<span style=color:#666>;</span> <span style=color:#666>);</span> <span style=color:#666>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> i <span style=color:green;font-weight:700>=</span> <span style=color:#666>0</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>def</span> i <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// won&#39;t compile
</span></span></span></code></pre></div><p>Java 有四个命名空间：字段，方法，类型和包。而 Scala 只有两个：值，包括字段，方法，包和单例对象，以及类型命名空间，包括类和特质（Trait）。</p><p>作为一个有经验的程序员，当我们意识到上面的变量名 <code>conts</code> 是在试图表达和 <code>contents</code> 一样的内容而在躲避变量名冲突时，就应该考虑是不是该重构一下这个片段了。这时适合使用参数化字段。而且，参数化字段和普通的字段一样可以使用 <code>override</code> <code>protected</code> <code>private</code> 来修饰：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Cat</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>val</span> dangerous <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Tiger</span> <span style=color:#666>(</span> <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>val</span> dangerous <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>true</span><span style=color:#666>,</span>
</span></span><span style=display:flex><span>              <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>var</span> age<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span>
</span></span><span style=display:flex><span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Cat</span>
</span></span></code></pre></div><p>需要调用父类的构造方法时：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span><span style=color:green;font-weight:700>val</span> contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Element</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>LineElement</span><span style=color:#666>(</span>s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Array</span><span style=color:#666>(</span>s<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> width <span style=color:green;font-weight:700>=</span> s<span style=color:#666>.</span>length
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> height <span style=color:green;font-weight:700>=</span> <span style=color:#666>1</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>Scala 在重写方法时强制使用 <code>override</code> 修饰符。考虑这样的情况：你想在你的类库里添加一个新的方法，但用户在他们的代码里已经继承了这个类并重写了相同名字的方法，在 Java 中这种情况是相当麻烦的。这种我们不愿见到的重载被称为脆基类。不过如果你和下游调用者的代码都是使用 Scala 编写的，由于缺少 <code>override</code> 修饰符，下游代码编译时将会报错。虽然这样的解决方式仍然不怎么优雅，至少比 Java 的情况要好。</p><p>最后，和 Java 一样，可以给方法或类打上 <code>final</code> 修饰符以防止继承。</p><p>滥用继承是一个常见的问题，毕竟，脆基类的问题只会出现在继承而不会出现在组合中。在使用继承的时候，最好确认：首先，二者必须是一个 is-a 的关系。其次，考虑用户是否真的想将子类当做一个父类对象来使用。比如，上面的 <code>LineElement</code> 继承 <code>ArrayElement</code> 就比较奇怪。让它直接继承 <code>Element</code> 可能是更好的选择。</p><h2 id=完善类库实现方法定义工厂>完善类库：实现方法，定义工厂
<a class=anchor href=#%e5%ae%8c%e5%96%84%e7%b1%bb%e5%ba%93%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95%e5%ae%9a%e4%b9%89%e5%b7%a5%e5%8e%82>#</a></h2><p>简单起见，我们先假设参数和被调用的 <code>Element</code> 宽或高相同。那么，方法可以这样实现：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> above<span style=color:#666>(</span>that<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span><span style=color:green;font-weight:700>this</span><span style=color:#666>.</span>contents <span style=color:#666>++</span> that<span style=color:#666>.</span>contents<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> beside<span style=color:#666>(</span>that<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>ArrayElement</span> <span style=color:#666>(</span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>
</span></span><span style=display:flex><span>        <span style=color:#666>(</span>line1<span style=color:#666>,</span> line2<span style=color:#666>)</span> <span style=color:green;font-weight:700>&lt;-</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>.</span>contents zip that<span style=color:#666>.</span>contents
</span></span><span style=display:flex><span>      <span style=color:#666>)</span> <span style=color:green;font-weight:700>yield</span> line1 <span style=color:#666>+</span> line2
</span></span><span style=display:flex><span>    <span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> toString <span style=color:green;font-weight:700>=</span> contents mkString <span style=color:#ba2121>&#34;\n&#34;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>实现了方法之后，我们希望使用工厂来对调用者暴露接口，而不是直接把继承层级告诉用户。毕竟，上面而我们已经修改了一次 <code>LineElement</code> 的层级了。同时，我们的 <code>above</code> 这些方法也可以转而调用工厂方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> elem<span style=color:#666>(</span>contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span>contents<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> elem<span style=color:#666>(</span>line<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>LineElement</span><span style=color:#666>(</span>line<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>Elements.elem</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> above<span style=color:#666>(</span>that<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span> elem<span style=color:#666>(</span><span style=color:green;font-weight:700>this</span><span style=color:#666>.</span>contents <span style=color:#666>++</span> that<span style=color:#666>.</span>contents<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> beside<span style=color:#666>(</span>that<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span>
</span></span><span style=display:flex><span>    elem<span style=color:#666>(</span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>for</span> <span style=color:#666>((</span>line1<span style=color:#666>,</span> line2<span style=color:#666>)</span> <span style=color:green;font-weight:700>&lt;-</span> <span style=color:green;font-weight:700>this</span><span style=color:#666>.</span>contents zip that<span style=color:#666>.</span>contents
</span></span><span style=display:flex><span>      <span style=color:#666>)</span> <span style=color:green;font-weight:700>yield</span> line1 <span style=color:#666>+</span> line2
</span></span><span style=display:flex><span>    <span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>此外，我们还发现 <code>ArrayElement</code> 本身也完全不需要暴露给用户了。所以，可以将它们全部转移成私有的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>object</span> <span style=color:#00f;font-weight:700>Element</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>val</span> contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Element</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>LineElement</span> <span style=color:#666>{</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> elem<span style=color:#666>(</span>contents<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Array</span><span style=color:#666>[</span><span style=color:#b00040>String</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>ArrayElement</span><span style=color:#666>(</span>contents<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> elem<span style=color:#666>(</span>line<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Element</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>LineElement</span><span style=color:#666>(</span>line<span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#函数和闭包>函数和闭包</a><ul><li><a href=#局部函数>局部函数</a></li><li><a href=#简化函数字面量>简化函数字面量</a></li><li><a href=#部分应用函数-partially-applied-function>部分应用函数 Partially Applied Function</a></li><li><a href=#闭包-closure>闭包 Closure</a></li><li><a href=#变长参数命名参数默认参数>变长参数，命名参数，默认参数</a></li><li><a href=#尾递归>尾递归</a></li><li><a href=#柯里化-currying>柯里化 Currying</a></li></ul></li><li><a href=#控制抽象>控制抽象</a><ul><li><a href=#减少代码重复>减少代码重复</a></li><li><a href=#柯里化>柯里化</a></li><li><a href=#编写控制结构--传名参数by-name-parameter>编写控制结构 & 传名参数（by-name parameter）</a></li></ul></li><li><a href=#组合与继承>组合与继承</a><ul><li><a href=#抽象类>抽象类</a></li><li><a href=#扩展一个类>扩展一个类</a></li><li><a href=#完善类库实现方法定义工厂>完善类库：实现方法，定义工厂</a></li></ul></li></ul></nav></div></aside></main></body></html>