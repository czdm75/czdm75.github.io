<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="模式匹配 #  样例类 case class #  abstract class Expr case class Number(num: Double) extends Expr case class UnOp(operator: String, arg: Expr) extends Expr case class BinOp(operator: String, left: Expr, right: Expr) extends Expr Scala 为一个 case class 提供了包括：
 一个 apply 工厂方法，等同于 def apply(num: Double) = new Number(num) 一系列字段。等同于 val num: Double 正确实现的 toString equals hashCode 方法 一个 copy 方法，这个方法可以接收参数以产生部分不同的新对象。  最重要的是，样例类可以进行模式匹配。
模式 #   通配模式 case _ 匹配任何对象，用于缺省捕获。 常量模式 case 1 仅匹配自己，也就是 equals 返回真值的对象。包括数字、字符串、单例对象、val 值等都可以。 变量模式 case e 变量模式也匹配任何对象，但这个变量名在后续的表达式中是有意义的，可以进行进一步处理。在区分常量模式和变量模式时，Scala 简单地使用首字母来判断。如果首字母是大写，就认为常量。必要时可以选择转义。 构造器模式 case BinOp(&#34;+&#34;, e, Number(0)) 构造器可以进行深度匹配，例如这里嵌套的 Number 对象。 序列模式 case List(0, a, _) 元组模式 case (0, a, _) 类型模式 case m: Map[_, _] 在 Scala 中推荐使用类型匹配而非 isInstanceOf[String] asInstanceOf[String] 来判断类型。 变量绑定 case BinOp(&#34;-&#34;, v @ Number(1), _) v 可以作为变量使用。这样可以在变量模式的基础上进行匹配。  常量和变量的匹配顺序规则如下：大写开头作为常量，小写开头作为变量，加转义则变回常量，这是考虑常量的值是作用域中某个变量的情况。大写开头的变量则不被支持。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="4. Pattern Matching, Collections"><meta property="og:description" content="模式匹配 #  样例类 case class #  abstract class Expr case class Number(num: Double) extends Expr case class UnOp(operator: String, arg: Expr) extends Expr case class BinOp(operator: String, left: Expr, right: Expr) extends Expr Scala 为一个 case class 提供了包括：
 一个 apply 工厂方法，等同于 def apply(num: Double) = new Number(num) 一系列字段。等同于 val num: Double 正确实现的 toString equals hashCode 方法 一个 copy 方法，这个方法可以接收参数以产生部分不同的新对象。  最重要的是，样例类可以进行模式匹配。
模式 #   通配模式 case _ 匹配任何对象，用于缺省捕获。 常量模式 case 1 仅匹配自己，也就是 equals 返回真值的对象。包括数字、字符串、单例对象、val 值等都可以。 变量模式 case e 变量模式也匹配任何对象，但这个变量名在后续的表达式中是有意义的，可以进行进一步处理。在区分常量模式和变量模式时，Scala 简单地使用首字母来判断。如果首字母是大写，就认为常量。必要时可以选择转义。 构造器模式 case BinOp(&#34;+&#34;, e, Number(0)) 构造器可以进行深度匹配，例如这里嵌套的 Number 对象。 序列模式 case List(0, a, _) 元组模式 case (0, a, _) 类型模式 case m: Map[_, _] 在 Scala 中推荐使用类型匹配而非 isInstanceOf[String] asInstanceOf[String] 来判断类型。 变量绑定 case BinOp(&#34;-&#34;, v @ Number(1), _) v 可以作为变量使用。这样可以在变量模式的基础上进行匹配。  常量和变量的匹配顺序规则如下：大写开头作为常量，小写开头作为变量，加转义则变回常量，这是考虑常量的值是作用域中某个变量的情况。大写开头的变量则不被支持。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/programming-scala/4/"><meta property="article:section" content="notes"><title>4. Pattern Matching, Collections | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle checked>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/ class=active>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>4. Pattern Matching, Collections</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#模式匹配>模式匹配</a><ul><li><a href=#样例类-case-class>样例类 case class</a></li><li><a href=#模式>模式</a></li><li><a href=#模式守卫与模式重叠>模式守卫与模式重叠</a></li><li><a href=#封闭类>封闭类</a></li><li><a href=#模式的更多应用>模式的更多应用</a></li></ul></li><li><a href=#列表>列表</a><ul><li><a href=#列表的形式>列表的形式</a></li><li><a href=#列表与模式匹配>列表与模式匹配</a></li><li><a href=#list-相关的高阶方法>List 相关的高阶方法</a></li><li><a href=#折叠>折叠</a></li><li><a href=#list-对象的方法>List 对象的方法</a></li><li><a href=#scala-的类型推断>Scala 的类型推断</a></li></ul></li><li><a href=#集合>集合</a><ul><li><a href=#序列集合映射-seq-set-map>序列、集合、映射 Seq Set Map</a></li><li><a href=#元组>元组</a></li></ul></li><li><a href=#mutable-对象>Mutable 对象</a></li></ul></nav></aside></header><article class=markdown><h1 id=模式匹配>模式匹配
<a class=anchor href=#%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d>#</a></h1><h2 id=样例类-case-class>样例类 case class
<a class=anchor href=#%e6%a0%b7%e4%be%8b%e7%b1%bb-case-class>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Expr</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Number</span><span style=color:#666>(</span>num<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Double</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Expr</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>UnOp</span><span style=color:#666>(</span>operator<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>,</span> arg<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Expr</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Expr</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>BinOp</span><span style=color:#666>(</span>operator<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>,</span> left<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Expr</span><span style=color:#666>,</span> right<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Expr</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>Expr</span>
</span></span></code></pre></div><p>Scala 为一个 case class 提供了包括：</p><ul><li>一个 <code>apply</code> 工厂方法，等同于 <code>def apply(num: Double) = new Number(num)</code></li><li>一系列字段。等同于 <code>val num: Double</code></li><li>正确实现的 <code>toString</code> <code>equals</code> <code>hashCode</code> 方法</li><li>一个 <code>copy</code> 方法，这个方法可以接收参数以产生部分不同的新对象。</li></ul><p>最重要的是，样例类可以进行模式匹配。</p><h2 id=模式>模式
<a class=anchor href=#%e6%a8%a1%e5%bc%8f>#</a></h2><ul><li>通配模式 <code>case _</code> 匹配任何对象，用于缺省捕获。</li><li>常量模式 <code>case 1</code> 仅匹配自己，也就是 <code>equals</code> 返回真值的对象。包括数字、字符串、单例对象、<code>val</code> 值等都可以。</li><li>变量模式 <code>case e</code> 变量模式也匹配任何对象，但这个变量名在后续的表达式中是有意义的，可以进行进一步处理。在区分常量模式和变量模式时，Scala 简单地使用首字母来判断。如果<strong>首字母是大写，就认为常量</strong>。必要时可以选择转义。</li><li>构造器模式 <code>case BinOp("+", e, Number(0))</code> 构造器可以进行深度匹配，例如这里嵌套的 <code>Number</code> 对象。</li><li>序列模式 <code>case List(0, a, _)</code></li><li>元组模式 <code>case (0, a, _)</code></li><li>类型模式 <code>case m: Map[_, _]</code> 在 Scala 中推荐使用类型匹配而非 <code>isInstanceOf[String]</code> <code>asInstanceOf[String]</code> 来判断类型。</li><li>变量绑定 <code>case BinOp("-", v @ Number(1), _)</code> <code>v</code> 可以作为变量使用。这样可以在变量模式的基础上进行匹配。</li></ul><p>常量和变量的匹配顺序规则如下：大写开头作为常量，小写开头作为变量，加转义则变回常量，这是考虑常量的值是作用域中某个变量的情况。大写开头的变量则不被支持。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>math.Pi</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> pi <span style=color:green;font-weight:700>=</span> <span style=color:#666>3.14</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Double</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> n <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>case</span> <span style=color:#00f;font-weight:700>Pi</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Pi</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>case</span> `pi` <span style=color:green;font-weight:700>=&gt;</span> pi
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>case</span> pi <span style=color:green;font-weight:700>=&gt;</span> pi
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Pi</span><span style=color:#666>,</span> <span style=color:#666>3.14</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>)</span> map f  <span style=color:#408080;font-style:italic>// List(3.141592653589793, 3.14, 3.0)
</span></span></span></code></pre></div><p>另一个问题是类型擦除。由于类型擦除，Scala 也没有办法准确地推断出一个泛型容器内部的类型。因此，一个匹配 <code>Map</code> 的模式匹配将能够接受所有的 <code>Map</code> 类型。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>n<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Any</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> n <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span><span style=color:green;font-weight:700>case</span> m<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Map</span><span style=color:#666>[</span><span style=color:#b00040>Int</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>true</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>false</span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// warning: non-variable type argument Int in type pattern scala.collection.immutable.Map[Int,Int] (the underlying of Map[Int,Int]) is unchecked since it is eliminated by erasure
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  (n: Any) =&gt; n match {case m: Map[Int, Int] =&gt; true; case _ =&gt; false}
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                               ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#00f;font-weight:700>Map</span><span style=color:#666>(</span><span style=color:#666>1</span> <span style=color:#666>-&gt;</span><span style=color:#666>2</span><span style=color:#666>))</span>   <span style=color:#408080;font-style:italic>// true
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>f<span style=color:#666>(</span><span style=color:#00f;font-weight:700>Map</span><span style=color:#666>(</span><span style=color:#666>1</span> <span style=color:#666>-&gt;</span><span style=color:#ba2121>&#34;&#34;</span><span style=color:#666>))</span>  <span style=color:#408080;font-style:italic>// true
</span></span></span></code></pre></div><h2 id=模式守卫与模式重叠>模式守卫与模式重叠
<a class=anchor href=#%e6%a8%a1%e5%bc%8f%e5%ae%88%e5%8d%ab%e4%b8%8e%e6%a8%a1%e5%bc%8f%e9%87%8d%e5%8f%a0>#</a></h2><p>在模式匹配中，模式需要是线性的，一个变量模式只能出现一次。如果我们要判断两个位置的值相等，就需要这样做：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> same<span style=color:#666>(</span>s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Any</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> s <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span>x<span style=color:#666>,</span> x<span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>true</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// error: x is already defined as value x
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  def same(s: Any) = s match { case (x, x) =&gt; true; case _ =&gt; false }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                                        ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> same<span style=color:#666>(</span>s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Any</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> s <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span>x<span style=color:#666>,</span> y<span style=color:#666>)</span> <span style=color:green;font-weight:700>if</span> x <span style=color:#666>==</span> y <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>true</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>}</span>
</span></span></code></pre></div><p>这种方式当然也能添加其他的条件。</p><p>模式重叠（Pattern Overlaps）指的是，在模式匹配中，排在上面的模式所覆盖的范围应该小于下面的，否则下面的模式就是 Unreachable Code。</p><h2 id=封闭类>封闭类
<a class=anchor href=#%e5%b0%81%e9%97%ad%e7%b1%bb>#</a></h2><p>是否在模式匹配的最后使用 <code>case _ =></code> 是一个选择。如果使用这样的语句，那么错误就有可能被隐藏起来难以发现。如果不使用，则会抛出 <code>MatchError</code>。但如果使用封闭类（sealed class），Scala 就能够判断出这个类的所有情况都已经被覆盖了。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>sealed</span> <span style=color:green;font-weight:700>abstract</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>B</span> <span style=color:green;font-weight:700>extends</span> A
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>C</span> <span style=color:green;font-weight:700>extends</span> A
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> a <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>true</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// warning: match may not be exhaustive.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// It would fail on the following input: C()
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  def f(a: A) = a match { case a: B =&gt; true }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> a <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>true</span><span style=color:#666>;</span> <span style=color:green;font-weight:700>case</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>C</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>false</span> <span style=color:#666>}</span>  <span style=color:#408080;font-style:italic>// no warning
</span></span></span></code></pre></div><p>当然，也可以选择使用 <code>@unchecked</code> 注解，但这样做通常并不合适。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> f<span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>@unchecked</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>B</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>true</span> <span style=color:#666>}</span>
</span></span></code></pre></div><p>Sealed class 的最典型例子就是 <code>Option</code>。这个类只有两个子类，<code>Some</code> 和 <code>None</code>。Scala 的 <code>Map</code> 就使用了这个类：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> m <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Map</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span> <span style=color:#666>-&gt;</span> <span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span> <span style=color:#666>-&gt;</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>m<span style=color:#666>(</span><span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// java.util.NoSuchElementException: key not found: c
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   at scala.collection.immutable.Map$Map2.apply(Map.scala:135)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ... 28 elided
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span>m<span style=color:#666>.</span>get<span style=color:#666>(</span><span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// None
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>m<span style=color:#666>.</span>get<span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// Some(1)
</span></span></span></code></pre></div><p>处理 <code>Option</code> 的常用方法也包括 <code>map</code> <code>flatMap</code> 和模式匹配。</p><h2 id=模式的更多应用>模式的更多应用
<a class=anchor href=#%e6%a8%a1%e5%bc%8f%e7%9a%84%e6%9b%b4%e5%a4%9a%e5%ba%94%e7%94%a8>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> myTuple <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#666>123</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> <span style=color:#666>(</span>number<span style=color:#666>,</span> string<span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> myTuple
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// number: Int = 123
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// string: String = abc
</span></span></span></code></pre></div><p>类似地，所有的 case class 都可以用类似的方法来解析。</p><p>花括号内的部分实际上就是一个函数字面量，或者说一个 lambda 表达式。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> withDefault<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Option</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Int</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>case</span> <span style=color:#00f;font-weight:700>Some</span><span style=color:#666>(</span>x<span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>case</span> <span style=color:#00f;font-weight:700>None</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// withDefault: Option[Int] =&gt; Int = &lt;function1&gt;
</span></span></span></code></pre></div><p>我们把 <code>withDefault</code> 定义为了一个接收 <code>Option[Int]</code>，返回 <code>Int</code> 的 lambda 表达式，这种语法在 Akka 中非常常用。</p><p>如果一个模式匹配的最后没有 <code>case _</code> 或 <code>case v</code>，那么当遇到未覆盖的值时会抛出 <code>MatchError</code>，这样的模式匹配属于一个<strong>偏函数</strong>。就是说，它不能完全处理整个定义域。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> second<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Function1</span><span style=color:#666>[</span><span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>y</span> <span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span> <span style=color:#666>=&gt;</span> y <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// warning: match may not be exhaustive.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// It would fail on the following inputs: List(_), Nil
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//  val second: Function1[List[Int], Int] = { case x :: y :: _ =&gt; y }
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//                                          ^
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> second<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>PartialFunction</span><span style=color:#666>[</span><span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>y</span> <span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span> <span style=color:#666>=&gt;</span> y <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>,</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>))</span> map second<span style=color:#666>.</span>isDefinedAt  <span style=color:#408080;font-style:italic>// List(false, true)
</span></span></span></code></pre></div><p>在将一个 lambda 表达式隐式转换成一个 <code>PartialFunction</code> 对象时，这个类被这样定义：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>new</span> <span style=color:#00f;font-weight:700>PartialFunction</span><span style=color:#666>[</span><span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span>, <span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> apply<span style=color:#666>(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> xs <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>y</span> <span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span> <span style=color:#666>=&gt;</span> y<span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> isDefinedAt<span style=color:#666>(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> xs <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>case</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>y</span> <span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span> <span style=color:#666>=&gt;</span> <span style=color:green;font-weight:700>true</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:green;font-weight:700>false</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>相对于普通的 <code>Function</code> 类，<code>PartialFunction</code> 额外定义了一系列可以用于量多个偏函数连接起来的方法。如果不能匹配，两种函数都会抛出 <code>MatchError</code>。</p><p>for 表达式里也会出现模式匹配。通常 for 表达式都能够完美匹配，因为容器中只能保存一种对象。一个例外是 <code>Option</code>，这种情况下 <code>None</code> 会被抛弃。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span><span style=color:#00f;font-weight:700>Some</span><span style=color:#666>(</span>a<span style=color:#666>)</span> <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>Some</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>None</span><span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Some</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>)))</span> print<span style=color:#666>(</span>a<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 13
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>for</span> <span style=color:#666>((</span>a<span style=color:#666>,</span> b<span style=color:#666>)</span> <span style=color:green;font-weight:700>&lt;-</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>((</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>),</span> <span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>)))</span> println<span style=color:#666>(</span>a <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> b<span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// 1 2\n3 4
</span></span></span></code></pre></div><h1 id=列表>列表
<a class=anchor href=#%e5%88%97%e8%a1%a8>#</a></h1><h2 id=列表的形式>列表的形式
<a class=anchor href=#%e5%88%97%e8%a1%a8%e7%9a%84%e5%bd%a2%e5%bc%8f>#</a></h2><p>我们熟悉的列表语法：<code>List(1, 2, 3)</code> 是一个语法糖，它等价于 <code>1 :: 2 :: 3 :: Nil</code>，别忘了 <code>::</code> 是右结合的。<code>Nil</code> 的类型是 <code>List[Nothing]</code>。因为 <code>List</code> 是 Immutable 的，它也被实现为协变的。这样，由于 <code>Nothing</code> 是所有类型的子类，<code>Nil</code> 也是所有 <code>List</code> 的子类，因此 <code>Nil</code> 可以作为任何 <code>List</code> 的空列表表示。</p><p>我们已经知道在列表的前面增加元素是高效的，而在 <code>ArrayBuffer</code> 的后面增加元素是高效的。<code>ArrayBuffer</code> 能够向后扩容，而 <code>List</code> 的默认实现是一个链表。不严谨地说，<code>List(1, 2 ,3)</code> 这个对象的 <code>head</code> 属性是 1，而 <code>tail</code> 属性是 <code>List(2, 3)</code>，这样做比复制整个列表节省内存和时间。更重要的是，实现为链表有利于进行模式匹配。</p><p>或者从另一个角度来考虑，列表的所有操作都可以被归纳为三种：<code>head</code> <code>tail</code> <code>isEmpty</code>。对于 <code>List(1, 2, 3)(1)</code>，大体上相当于 <code>(1 :: 2 :: 3 :: Nil).tail.head</code>。Scala 列表的这些特性和 Haskell 非常相似。</p><h2 id=列表与模式匹配>列表与模式匹配
<a class=anchor href=#%e5%88%97%e8%a1%a8%e4%b8%8e%e6%a8%a1%e5%bc%8f%e5%8c%b9%e9%85%8d>#</a></h2><p>在模式匹配中，列表模式也可以使用 <code>::</code> 来表达，上面已经出现了这样的形式。不过利用 <code>::</code> 能够匹配得更加自由：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>b</span> <span style=color:#b00040>::</span> <span style=color:#b00040>c</span> <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a: Int = 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// b: Int = 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// c: List[Int] = List(3, 4)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> a <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>b</span> <span style=color:#b00040>::</span> <span style=color:#b00040>c</span>  <span style=color:#666>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a: Int = 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// b: Int = 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// c: List[Int] = List(3)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span>a<span style=color:#666>,</span> b<span style=color:#666>,</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a: Int = 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// b: Int = 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span>a<span style=color:#666>,</span> b<span style=color:#666>,</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// scala.MatchError: List(1, 2, 3, 4) (of class scala.collection.immutable.$colon$colon)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//   ... 28 elided
</span></span></span></code></pre></div><p>相对于 <code>List(a, b, c)</code> 的形式，使用 <code>::</code> 能够正确地处理不同长度的列表。这两种方式适用于不同的情景。</p><p>有意思的是，这两种形式实际上都不符合我们之前对模式的定义。实际上，<code>List(a, b)</code> 是一个由开发库定义的 extractor 模式的实例（详细说明出现于书 24 章）。而另一种形式 <code>a :: b</code> 当出现在模式匹配中时，不再是调用的 <code>c.::</code> 方法，而是 <code>scala.::</code> 这个类，<code>a :: b</code> 等价于 <code>::(a, b)</code>，其中 <code>::</code> 是一个 Case Class。也就是说，这里的模式部分实际上是使用 <code>a</code> 和 <code>b</code> 作为两个参数生成的 <code>::</code> 对象模式。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>case</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>::</span> <span style=color:#666>[</span><span style=color:#b00040>+A</span><span style=color:#666>](</span><span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>val</span> head<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>A</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>private</span><span style=color:#666>[</span><span style=color:#b00040>scala</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>var</span> next<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>A</span> <span style=color:#b00040>@uncheckedVariance</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>]</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> isEmpty<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Boolean</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>false</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> headOption<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Some</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>Some</span><span style=color:#666>(</span>head<span style=color:#666>)</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> tail<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>A</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> next
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>用模式匹配来实现关于列表的功能就是一个非常类似于 Haskell 的过程了。我们来尝试使用递归和模式匹配来实现 <code>:::</code> 的功能。为了避免和原有的方法冲突，我们将其命名为 <code>+++:</code>：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>implicit</span> <span style=color:green;font-weight:700>final</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>AppendList</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span><span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>val</span> self<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>extends</span> <span style=color:#00f;font-weight:700>AnyVal</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> <span style=color:#666>+++:(</span>other<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    other <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>case</span> <span style=color:#00f;font-weight:700>Nil</span> <span style=color:green;font-weight:700>=&gt;</span> self
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>case</span> head <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>tail</span> <span style=color:#666>=&gt;</span> head <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>tail</span> <span style=color:#b00040>+++:</span> <span style=color:#b00040>self</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span> <span style=color:#666>+++:</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// List(1, 2, 3, 4)
</span></span></span></code></pre></div><p>可以先不去考虑这里的隐式转换。模式匹配的逻辑并不复杂：如果是一个空列表，那么只需要返回原来的列表就可以了。如果是一个有内容的列表，那么就变成其 <code>head</code> 与一个递归的 append 列表的连接。这里的主要部分在于列表的递归思想。当然，实际的代码要比这样效率更高些。</p><p>由于列表的这种实现方式，取得元素的 <code>head</code> 和取得剩余列表的 <code>tail</code> 是 O(1) 的操作，而取得元素的 <code>last</code> 和取得前面一部分列表的 <code>init</code> 是 O(n) 的操作。</p><p>然后，我们来尝试实现一个归并排序：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> msort<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>less<span style=color:green;font-weight:700>:</span> <span style=color:#666>(</span><span style=color:#b00040>T</span><span style=color:#666>,</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> merge<span style=color:#666>(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>],</span> ys<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#666>(</span>xs<span style=color:#666>,</span> ys<span style=color:#666>)</span> <span style=color:green;font-weight:700>match</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span><span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>,</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> ys
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> <span style=color:#00f;font-weight:700>Nil</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> xs
</span></span><span style=display:flex><span>      <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span>x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>xsl</span><span style=color:#666>,</span> y <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>ysl</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>less<span style=color:#666>(</span>x<span style=color:#666>,</span> y<span style=color:#666>))</span> x <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>merge</span><span style=color:#666>(</span><span style=color:#b00040>xsl</span><span style=color:#666>,</span> <span style=color:#b00040>ys</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>else</span> y <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>merge</span><span style=color:#666>(</span><span style=color:#b00040>xs</span><span style=color:#666>,</span> <span style=color:#b00040>ysl</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>val</span> n <span style=color:green;font-weight:700>=</span> xs<span style=color:#666>.</span>length <span style=color:#666>/</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>n <span style=color:#666>==</span> <span style=color:#666>0</span><span style=color:#666>)</span> xs
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>else</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>val</span> <span style=color:#666>(</span>ys<span style=color:#666>,</span> zs<span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> xs splitAt n
</span></span><span style=display:flex><span>    merge<span style=color:#666>(</span>msort<span style=color:#666>(</span>less<span style=color:#666>)(</span>ys<span style=color:#666>),</span> msort<span style=color:#666>(</span>less<span style=color:#666>)(</span>zs<span style=color:#666>))</span>
</span></span><span style=display:flex><span>  <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>msort<span style=color:#666>((</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>&lt;</span> y<span style=color:#666>)(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>))</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> intSort <span style=color:green;font-weight:700>=</span> msort<span style=color:#666>((</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>&lt;</span> y<span style=color:#666>)</span> <span style=color:green;font-weight:700>_</span>
</span></span></code></pre></div><p>这里也能看到柯里化的手法，通过柯里化让一个泛型函数变成了一个固定参数类型的函数，然后接受下一个参数来执行。</p><h2 id=list-相关的高阶方法>List 相关的高阶方法
<a class=anchor href=#list-%e7%9b%b8%e5%85%b3%e7%9a%84%e9%ab%98%e9%98%b6%e6%96%b9%e6%b3%95>#</a></h2><p>高阶方法接受或返回另一个函数。如果你和我一样熟悉 Spark，或者熟悉 Python 的推导式，那么 <code>map</code> <code>filter</code> <code>flatMap</code> <code>foreach</code> 这些函数应该用起来很自然。和 <code>for</code> 一样，Scala 会自动产生与之前相似的类型。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>)</span>         <span style=color:#408080;font-style:italic>// List(2, 3, 4)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>ArrayBuffer</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// ArrayBuffer(2, 3, 4)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>Array</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>).</span>map<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#666>1</span><span style=color:#666>)</span>        <span style=color:#408080;font-style:italic>// Array(2, 3, 4)
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;abcdge&#34;</span><span style=color:#666>).</span>indices  <span style=color:#408080;font-style:italic>// scala.collection.immutable.Range = Range 0 until 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> f <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>l<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span>l<span style=color:#666>.</span>partition <span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> l<span style=color:#666>.</span>takeWhile <span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> l<span style=color:#666>.</span>dropWhile <span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> l<span style=color:#666>.</span>span <span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> l<span style=color:#666>.</span>forall <span style=color:green;font-weight:700>_</span><span style=color:#666>,</span> l<span style=color:#666>.</span>exists <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>f<span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>7</span><span style=color:#666>,</span> <span style=color:#666>5</span><span style=color:#666>))</span> map <span style=color:#666>{</span><span style=color:green;font-weight:700>_</span><span style=color:#666>{</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>&gt;</span> <span style=color:#666>2</span><span style=color:#666>}}</span> foreach println
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// (List(3, 4, 7, 5),List(2, 1))
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// List(3, 4)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// List(2, 1, 7, 5)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// (List(3, 4),List(2, 1, 7, 5))
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// false
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// true
</span></span></span></code></pre></div><h2 id=折叠>折叠
<a class=anchor href=#%e6%8a%98%e5%8f%a0>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> sum<span style=color:#666>(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>(</span><span style=color:#666>0</span> <span style=color:#666>/:</span> xs<span style=color:#666>)</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>这里使用了左折叠的操作。一个折叠操作与三个值有关：<code>(z /: xs) (op)</code>，即开始值、列表和操作符。如果要在开头排除操作符的副作用，例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> l <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#666>(</span><span style=color:#ba2121>&#34;&#34;</span> <span style=color:#666>/:</span> l<span style=color:#666>)(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>           <span style=color:#408080;font-style:italic>// &#34; a b c&#34;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span>l<span style=color:#666>.</span>head <span style=color:#666>/:</span> l<span style=color:#666>.</span>tail<span style=color:#666>)(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>  <span style=color:#408080;font-style:italic>// &#34;a b c&#34;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>l<span style=color:#666>.</span>reduce<span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>            <span style=color:#408080;font-style:italic>// &#34;a b c&#34;
</span></span></span></code></pre></div><p>类似地，<code>:\</code> 操作符向右折叠，同时初始值和列表也要反过来。这样也遵循了之前定义右结合操作符时使用的 <code>:</code> 朝向被调用者的原则。也就是 <code>(List(a, b, c) :\ z)(op)</code>。当然，也可以使用 <code>foldLeft</code> 和 <code>foldRight</code>。此外，还可以使用 <code>reduceLeft</code> 和 <code>reduceRight</code>，它们不接收初始值，直接使用开头或结尾作为初始值。相应地，如果列表为空，它们会抛出异常。</p><p>考虑一个将 <code>List[List[T]]</code> 转换为 <code>List[T]</code> 的 <code>flatten</code> 操作。由于拼接列表这个操作满足结合律，有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> flattenLeft<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xss<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]()</span> <span style=color:#666>/:</span> xss<span style=color:#666>)</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>:</span><span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>def</span> flattenRight<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xss<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>xss <span style=color:green;font-weight:700>:</span><span style=color:#b00040>\</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]())</span> <span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:green;font-weight:700>:</span><span style=color:#b00040>::</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>
</span></span></code></pre></div><p>但这两种实现的性能有所不同。由于 <code>:::</code> 的时间代价与前者的长度成正比，所以 <code>flattenRight</code> 的性能要比 <code>flattenLeft</code> 好得多。类似地，可以实现一个基于折叠的线性复杂度的 <code>reverse</code> 方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> reverseLeft<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]()</span> <span style=color:#666>/:</span> xs<span style=color:#666>)</span> <span style=color:#666>{(</span>ys<span style=color:#666>,</span> y<span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> y <span style=color:green;font-weight:700>:</span><span style=color:#b00040>:</span> <span style=color:#b00040>ys</span><span style=color:#666>}</span>
</span></span></code></pre></div><p>注意到在这两个函数中，都使用了 <code>List[T]()</code> 而非 <code>Nil</code> 来提供类型推断。</p><h2 id=list-对象的方法>List 对象的方法
<a class=anchor href=#list-%e5%af%b9%e8%b1%a1%e7%9a%84%e6%96%b9%e6%b3%95>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#00f;font-weight:700>Range</span>                                            <span style=color:#408080;font-style:italic>// scala.collection.immutable.Range
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>Range</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>10</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>                                  <span style=color:#408080;font-style:italic>// scala.collection.immutable.Range
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>.</span>range<span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>10</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>                             <span style=color:#408080;font-style:italic>// List(1, 3, 5, 7, 9)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>.</span>concat<span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>5</span><span style=color:#666>,</span> <span style=color:#666>6</span><span style=color:#666>))</span>  <span style=color:#408080;font-style:italic>// List(1, 2, 3, 4, 5, 6)
</span></span></span></code></pre></div><p>在目前的实现中，<code>:::</code> 是使用 <code>ListBuffer</code> 实现的，而 <code>List.concat</code> 继承自 <code>scala.collection.StrictOptimizedIterableOps</code>，是基于 <code>Iterable</code> 实现的。</p><p>最后，我们提供一个直接进行 zip 操作的方法，以下两种方式是等价的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>),</span> <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)).</span>zipped<span style=color:#666>.</span>map<span style=color:#666>{(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> i <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> s<span style=color:#666>}</span>     <span style=color:#408080;font-style:italic>// List(1 &#34;a&#34;, 2 &#34;b&#34;, 3 &#34;c&#34;)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>(</span><span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>)</span> zip <span style=color:#00f;font-weight:700>List</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;c&#34;</span><span style=color:#666>)).</span>map<span style=color:#666>{</span> <span style=color:green;font-weight:700>case</span> <span style=color:#666>(</span>i<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>,</span> s<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>String</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> i <span style=color:#666>+</span> <span style=color:#ba2121>&#34; &#34;</span> <span style=color:#666>+</span> s<span style=color:#666>}</span>   <span style=color:#408080;font-style:italic>// List(1 &#34;a&#34;, 2 &#34;b&#34;, 3 &#34;c&#34;)
</span></span></span></code></pre></div><p>区别是，第一种的 <code>map</code> 接受的参数可以直接接收两个参数，而第二种中接收到的是一个 <code>Tuple2[Int, String]</code>。</p><h2 id=scala-的类型推断>Scala 的类型推断
<a class=anchor href=#scala-%e7%9a%84%e7%b1%bb%e5%9e%8b%e6%8e%a8%e6%96%ad>#</a></h2><p>比较两个排序函数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>msort<span style=color:#666>((</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Char</span><span style=color:#666>,</span> y<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Char</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> x <span style=color:#666>&gt;</span> y<span style=color:#666>)(</span>list<span style=color:#666>)</span>
</span></span><span style=display:flex><span>list sortWith <span style=color:#666>(</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>&gt;</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)</span>
</span></span></code></pre></div><p><code>_ > _</code> 这样的简单写法适用于后者但并不能适用于前者，这里就涉及到了 Scala 的类型推断。Scala 的类型推断是基于程序流的。<code>sortWith</code> 是 <code>list</code> 对象的方法，所以我们能够知道 <code>T</code> 的类型，而 <code>msort</code> 不能。回忆 <code>msort</code> 的定义：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> msort<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>less<span style=color:green;font-weight:700>:</span> <span style=color:#666>(</span><span style=color:#b00040>T</span><span style=color:#666>,</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)(</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>???</span>
</span></span></code></pre></div><p>当我们传入 <code>(x: Char, y: char) => x > y</code> 时，<code>T</code> 才被推断为 <code>Char</code> 类型。因此，可以这样调用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>msort<span style=color:#666>[</span><span style=color:#b00040>Char</span><span style=color:#666>](</span><span style=color:green;font-weight:700>_</span> <span style=color:#666>&gt;</span> <span style=color:green;font-weight:700>_</span><span style=color:#666>)(</span>list<span style=color:#666>)</span>
</span></span></code></pre></div><p>手动给 <code>T</code> 赋予值之后，就能够正常地进行推断了。另一种更好的方法是：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>def</span> msort<span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>](</span>xs<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>])(</span>less<span style=color:green;font-weight:700>:</span> <span style=color:#666>(</span><span style=color:#b00040>T</span><span style=color:#666>,</span> <span style=color:#b00040>T</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=&gt;</span> <span style=color:#00f;font-weight:700>Boolean</span><span style=color:#666>)</span><span style=color:green;font-weight:700>:</span> <span style=color:#b00040>List</span><span style=color:#666>[</span><span style=color:#b00040>T</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>???</span>
</span></span></code></pre></div><p>这样，在第一个参数处，就可以直接得到类型参数，无需再手动指定了。不过，这样的结果是失去了柯里化的方便。因此我们得到了一个原则：在提供 API 时，尽量把数据结构放在前面，函数放在后面。</p><p>然后我们回头来看上面的 <code>flatten</code> 函数，函数里使用了 <code>xs :\ List[T]()</code> 而非 <code>Nil</code> 或等价的 <code>List()</code>。这是因为，如果使用 <code>List()</code>，那么折叠过程的第一步需要一个 <code>(List[T], List[Nothing]) => List[T]</code> 的操作符，而之后的部分则需要 <code>(List[T], List[T]) => List[T]</code> 类型，无法统一。</p><h1 id=集合>集合
<a class=anchor href=#%e9%9b%86%e5%90%88>#</a></h1><p><code>Iterable</code> 指代一个集合，而 <code>Iterator</code> 指代对这个集合的操作。实际上，<code>Iterator</code> 继承了 <code>IterableOnce</code> 这个 trait。所以 <code>Iterator</code> 只能遍历一次。</p><h2 id=序列集合映射-seq-set-map>序列、集合、映射 Seq Set Map
<a class=anchor href=#%e5%ba%8f%e5%88%97%e9%9b%86%e5%90%88%e6%98%a0%e5%b0%84-seq-set-map>#</a></h2><p>Scala 的数组和 Java 数组是对齐的，可以直接进行操作，虽然形式上 Scala 的数组是泛型的，这使得它们在变型（逆变和协变）问题上略有不同。</p><p><code>ListBuffer</code> 是可变版本的 <code>List</code>。在循环中拼接一个 <code>List</code> 时，要么需要使用 <code>var</code>，要么需要进行递归。如果操作不是尾递归，就有必要使用 <code>ListBuffer</code> 来控制栈的深度。</p><p><code>Queue</code> 和 <code>Stack</code> 包括可变和不可变的版本，分别使用 <code>enqueue</code> <code>dequeue</code> 和 <code>push</code> <code>pop</code> 来操作。对于不可变的版本，取元素操作会返回一个 <code>Tuple[T, Queue[T]]</code>。</p><p>字符串的隐式转换类 <code>RichString</code> 也是一个 <code>Seq[Char]</code>。</p><p><code>Set</code> 和 <code>Map</code> 都可以使用 <code>+</code> <code>-</code> 来增加或删除元素，使用 <code>++</code> <code>--</code> 删除一个集合里的元素。对于可变版，还可以使用对应的 <code>+=</code> <code>-=</code> 等。对 <code>Map</code>，删除时只需要传入 Key，增加时则是传入一个元组。用箭头来生成 <code>Tuple2[A, B]</code> 作为键值对的语法就适合这种场景。</p><p>出于性能优化的原因，Scala 为 0~4 个元素的不可变集合与映射直接提供了类 <code>scala.collection.immutable.Map.Map4</code> 等一些，更大容量的则使用 <code>HashSet</code> 作为默认。这种小尺寸的集合比可变版本的更加紧凑，更加节省内存，访问时也通常更节省时间。</p><p>Scala 只提供了不可变版本的排序后的集合 <code>TreeSet</code> <code>TreeMap</code>，基于红黑树实现。其元素需要混入 <code>Ordered</code> 或能够隐式转换为 <code>Ordered</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>scala.collection.immutable.TreeSet</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>var</span> t <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>TreeSet</span><span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>3</span><span style=color:#666>,</span> <span style=color:#666>4</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span>t <span style=color:#666>+=</span> <span style=color:#666>2</span>
</span></span><span style=display:flex><span>t  <span style=color:#408080;font-style:italic>// TreeSet(1, 2, 3, 4)
</span></span></span></code></pre></div><p>在这个例子中，虽然 <code>t</code> 指向一个不可变集合，但因为它是一个 <code>var</code>，所以 <code>t</code> 会指向一个新创建的对象。这个原则适用于所有 <code>Immutable var</code>，只要操作符以 <code>=</code> 结尾。</p><p><code>Set</code> 和 <code>Map</code> 都有 <code>toArray</code> 和 <code>toList</code> 方法，虽然会造成元素的拷贝。生成的顺序与 <code>elements</code> 方法的返回值一样。如果要从其它集合转换为 <code>Set</code> 和 <code>Map</code>，或者在可变与不可变之间转换，就需要使用 <code>++</code>。</p><h2 id=元组>元组
<a class=anchor href=#%e5%85%83%e7%bb%84>#</a></h2><p>之前已经提到过模式匹配的一个特例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>val</span> <span style=color:#666>(</span>a<span style=color:#666>,</span> b<span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a: Int = 1
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// b: Int = 2
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>val</span> a<span style=color:#666>,</span> b <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span><span style=color:#666>1</span><span style=color:#666>,</span> <span style=color:#666>2</span><span style=color:#666>)</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a: (Int, Int) = (1,2)
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// b: (Int, Int) = (1,2)
</span></span></span></code></pre></div><p>第二种情况更类似 C 风格的传统代码。</p><h1 id=mutable-对象>Mutable 对象
<a class=anchor href=#mutable-%e5%af%b9%e8%b1%a1>#</a></h1><p>Mutable 类内部经常使用 <code>var</code> 进行定义，但这不是绝对的。例如，一个使用 <code>var</code> 引用进行缓存的类可以是纯函数式的，只要其行为对于相同的输入来说是始终相同的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span> <span style=color:green;font-weight:700>def</span> getValue<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>CachedA</span> <span style=color:green;font-weight:700>extends</span> A <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span> <span style=color:green;font-weight:700>var</span> value<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Option</span><span style=color:#666>[</span><span style=color:#b00040>Int</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>=</span> <span style=color:#00f;font-weight:700>None</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> getValue<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>value<span style=color:#666>.</span>isDefined<span style=color:#666>)</span> value<span style=color:#666>.</span>get <span style=color:green;font-weight:700>else</span> <span style=color:green;font-weight:700>super</span><span style=color:#666>.</span>getValue
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>Scala 对于类中非私有的 <code>var</code> 变量直接提供了 getter 和 setter，这样不仅为未来的修改留出空间，甚至可以让我们自己定义一个虚拟的变量出来。以下的类定义对调用者来说是等价的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>A</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>var</span> a <span style=color:green;font-weight:700>=</span> <span style=color:green;font-weight:700>_</span>  <span style=color:#408080;font-style:italic>// 注意在 Scala 中必须赋一个初值，否则定义的是一个抽象变量
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>B</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>private</span><span style=color:#666>[</span><span style=color:#b00040>this</span><span style=color:#666>]</span> <span style=color:green;font-weight:700>var</span> v <span style=color:green;font-weight:700>=</span> <span style=color:#666>0</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> a<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span> <span style=color:#666>=</span> v
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> a_=<span style=color:#666>(</span>x<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Int</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> v <span style=color:green;font-weight:700>=</span> x
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>当我们访问或修改对象中的 <code>var</code> 变量时，无论是否显式写出来，实际上都是调用了两个方法。这样，有必要的话我们就可以在 getter 和 setter 中添加逻辑，或者实现一些更复杂的逻辑。例如，定义一个温度类：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Therometer</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>var</span> celsius<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Float</span> <span style=color:#666>=</span> <span style=color:green;font-weight:700>_</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> fahrenheit <span style=color:green;font-weight:700>=</span> celsius <span style=color:#666>*</span> <span style=color:#666>9</span> <span style=color:#666>/</span> <span style=color:#666>5</span> <span style=color:#666>+</span> <span style=color:#666>32</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>def</span> fahrenheit_= <span style=color:#666>(</span>f<span style=color:green;font-weight:700>:</span> <span style=color:#b00040>Float</span><span style=color:#666>)</span> <span style=color:green;font-weight:700>=</span> celsius <span style=color:green;font-weight:700>=</span> <span style=color:#666>(</span>f <span style=color:#666>-</span> <span style=color:#666>32</span><span style=color:#666>)</span> <span style=color:#666>*</span> <span style=color:#666>5</span> <span style=color:#666>/</span> <span style=color:#666>9</span>
</span></span><span style=display:flex><span>  <span style=color:green;font-weight:700>override</span> <span style=color:green;font-weight:700>def</span> toString <span style=color:green;font-weight:700>=</span> fahrenheit <span style=color:#666>+</span> <span style=color:#ba2121>&#34;F/&#34;</span> <span style=color:#666>+</span> celcius <span style=color:#666>+</span> <span style=color:#ba2121>&#34;C&#34;</span>
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#模式匹配>模式匹配</a><ul><li><a href=#样例类-case-class>样例类 case class</a></li><li><a href=#模式>模式</a></li><li><a href=#模式守卫与模式重叠>模式守卫与模式重叠</a></li><li><a href=#封闭类>封闭类</a></li><li><a href=#模式的更多应用>模式的更多应用</a></li></ul></li><li><a href=#列表>列表</a><ul><li><a href=#列表的形式>列表的形式</a></li><li><a href=#列表与模式匹配>列表与模式匹配</a></li><li><a href=#list-相关的高阶方法>List 相关的高阶方法</a></li><li><a href=#折叠>折叠</a></li><li><a href=#list-对象的方法>List 对象的方法</a></li><li><a href=#scala-的类型推断>Scala 的类型推断</a></li></ul></li><li><a href=#集合>集合</a><ul><li><a href=#序列集合映射-seq-set-map>序列、集合、映射 Seq Set Map</a></li><li><a href=#元组>元组</a></li></ul></li><li><a href=#mutable-对象>Mutable 对象</a></li></ul></nav></div></aside></main></body></html>