<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="B 树 #  B 树的基本思想是这样的：设想一个树，每个节点都被储存在磁盘里，我们每次取出一个结点，这是很自然的。在进入下一层时，需要访问一个新的结点，这常常意味着新的磁盘访问。相应地，在节点内部进行的比较操作，也就是寻找前进方向的操作，只需要在主存里进行。
显然，主存中的操作的时间代价要低得多。所以，我们让每个节点持有众多的关键字和众多的结点，从而尽量降低树的高度。这意味着，相比于二叉树，使用 B 树将会带来更多的比较操作和更少的磁盘访问。因此，这种数据结构适合大块的数据访问。典型的例子如 BtrFS。
和其他各种树一样，B 树上操作的时间复杂度同样为 $O(\log_tn)$，只是这里的 $t$ 比二叉树中的 2 通常要大得多。
B 树的操作 #  B 树的基本操作在之前的 2-3 树已经介绍过。在插入关键字时，如果结点的大小超过了限制，就 “挤出” 一个最中间的关键字给父节点，并分裂当前结点。由于被挤出的是中间关键字，分类得到的两个新节点的长度应该相近。随后我们需要递归地对父节点进行判断，直到根节点分裂，这是 B 树高度增长的唯一方式。
在回顾了分裂结点的操作后，我们就可以理解 B 树定义中 $t$ 的意义：每个节点内关键字的数量在 $t$ 和 $2t$ 之间，这分别是刚刚分裂过的结点和即将要分裂的结点。
这里有一个不错的 B 树操作的可视化演示。
B+ 树 #  B+ 树是 B 树的一个变种，其所有的关键字都储存在叶子节点当中。由于 B 树中所有的结点高度相同，其查找的时间复杂度非常稳定。B+ 树可以接受重复关键字，将实际数据存储在叶子节点中，内部结点只用来指示存储位置即可。
斐波那契堆 #  可合并堆 #  一个可合并堆应当支持以下的操作：
 创建空堆 插入关键字 取得最小值 删除最小值 合并两个堆  除此之外，斐波那契堆还可以支持减小已有元素的关键字和删除关键字的操作。
之前出现过的二叉堆在前四个操作上效果都不错，时间代价为 $O(\log_2n)$。然而，在合并堆的操作上，二叉堆的速度非常慢。可以这样实现：将两个堆直接合并起来，再执行建堆操作。这样，复杂度会达到 $\Theta(n)$。斐波那契堆通常相比二叉堆具有更好的摊还代价。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="7. B-Tree, Fibonacci Heap, vEB Tree"><meta property="og:description" content="B 树 #  B 树的基本思想是这样的：设想一个树，每个节点都被储存在磁盘里，我们每次取出一个结点，这是很自然的。在进入下一层时，需要访问一个新的结点，这常常意味着新的磁盘访问。相应地，在节点内部进行的比较操作，也就是寻找前进方向的操作，只需要在主存里进行。
显然，主存中的操作的时间代价要低得多。所以，我们让每个节点持有众多的关键字和众多的结点，从而尽量降低树的高度。这意味着，相比于二叉树，使用 B 树将会带来更多的比较操作和更少的磁盘访问。因此，这种数据结构适合大块的数据访问。典型的例子如 BtrFS。
和其他各种树一样，B 树上操作的时间复杂度同样为 $O(\log_tn)$，只是这里的 $t$ 比二叉树中的 2 通常要大得多。
B 树的操作 #  B 树的基本操作在之前的 2-3 树已经介绍过。在插入关键字时，如果结点的大小超过了限制，就 “挤出” 一个最中间的关键字给父节点，并分裂当前结点。由于被挤出的是中间关键字，分类得到的两个新节点的长度应该相近。随后我们需要递归地对父节点进行判断，直到根节点分裂，这是 B 树高度增长的唯一方式。
在回顾了分裂结点的操作后，我们就可以理解 B 树定义中 $t$ 的意义：每个节点内关键字的数量在 $t$ 和 $2t$ 之间，这分别是刚刚分裂过的结点和即将要分裂的结点。
这里有一个不错的 B 树操作的可视化演示。
B+ 树 #  B+ 树是 B 树的一个变种，其所有的关键字都储存在叶子节点当中。由于 B 树中所有的结点高度相同，其查找的时间复杂度非常稳定。B+ 树可以接受重复关键字，将实际数据存储在叶子节点中，内部结点只用来指示存储位置即可。
斐波那契堆 #  可合并堆 #  一个可合并堆应当支持以下的操作：
 创建空堆 插入关键字 取得最小值 删除最小值 合并两个堆  除此之外，斐波那契堆还可以支持减小已有元素的关键字和删除关键字的操作。
之前出现过的二叉堆在前四个操作上效果都不错，时间代价为 $O(\log_2n)$。然而，在合并堆的操作上，二叉堆的速度非常慢。可以这样实现：将两个堆直接合并起来，再执行建堆操作。这样，复杂度会达到 $\Theta(n)$。斐波那契堆通常相比二叉堆具有更好的摊还代价。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/intro-algo/7/"><meta property="article:section" content="notes"><title>7. B-Tree, Fibonacci Heap, vEB Tree | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle checked>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/ class=active>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>7. B-Tree, Fibonacci Heap, vEB Tree</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#b-树>B 树</a><ul><li><a href=#b-树的操作>B 树的操作</a></li><li><a href=#b-树-1>B+ 树</a></li></ul></li><li><a href=#斐波那契堆>斐波那契堆</a><ul><li><a href=#可合并堆>可合并堆</a></li><li><a href=#斐波那契堆-1>斐波那契堆</a></li><li><a href=#斐波那契堆的操作>斐波那契堆的操作</a></li><li><a href=#斐波那契堆的其他操作>斐波那契堆的其他操作</a></li></ul></li><li><a href=#veb-树>vEB 树</a><ul><li><a href=#叠加二叉树结构>叠加二叉树结构</a></li><li><a href=#veb-树-1>vEB 树</a></li><li><a href=#veb-树的查找>vEB 树的查找</a></li></ul></li><li><a href=#用于处理不相交集合的数据结构>用于处理不相交集合的数据结构</a><ul><li><a href=#不相交集合的操作>不相交集合的操作</a></li><li><a href=#不相交集合的链表表示>不相交集合的链表表示</a></li><li><a href=#不相交集合森林>不相交集合森林</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=b-树>B 树
<a class=anchor href=#b-%e6%a0%91>#</a></h1><p>B 树的基本思想是这样的：设想一个树，每个节点都被储存在磁盘里，我们每次取出一个结点，这是很自然的。在进入下一层时，需要访问一个新的结点，这常常意味着新的磁盘访问。相应地，在节点内部进行的比较操作，也就是寻找前进方向的操作，只需要在主存里进行。</p><p>显然，主存中的操作的时间代价要低得多。所以，我们让每个节点持有众多的关键字和众多的结点，从而尽量降低树的高度。这意味着，相比于二叉树，使用 B 树将会带来更多的比较操作和更少的磁盘访问。因此，这种数据结构适合大块的数据访问。典型的例子如 BtrFS。</p><p>和其他各种树一样，B 树上操作的时间复杂度同样为 $O(\log_tn)$，只是这里的 $t$ 比二叉树中的 2 通常要大得多。</p><h2 id=b-树的操作>B 树的操作
<a class=anchor href=#b-%e6%a0%91%e7%9a%84%e6%93%8d%e4%bd%9c>#</a></h2><p>B 树的基本操作在之前的 2-3 树已经介绍过。在插入关键字时，如果结点的大小超过了限制，就 “挤出” 一个最中间的关键字给父节点，并分裂当前结点。由于被挤出的是中间关键字，分类得到的两个新节点的长度应该相近。随后我们需要递归地对父节点进行判断，直到根节点分裂，这是 B 树高度增长的唯一方式。</p><p>在回顾了分裂结点的操作后，我们就可以理解 B 树定义中 $t$ 的意义：每个节点内关键字的数量在 $t$ 和 $2t$ 之间，这分别是刚刚分裂过的结点和即将要分裂的结点。</p><p><a href=https://www.cs.usfca.edu/~galles/visualization/BTree.html>这里</a>有一个不错的 B 树操作的可视化演示。</p><h2 id=b-树-1>B+ 树
<a class=anchor href=#b-%e6%a0%91-1>#</a></h2><p>B+ 树是 B 树的一个变种，其所有的关键字都储存在叶子节点当中。由于 B 树中所有的结点高度相同，其查找的时间复杂度非常稳定。B+ 树可以接受重复关键字，将实际数据存储在叶子节点中，内部结点只用来指示存储位置即可。</p><h1 id=斐波那契堆>斐波那契堆
<a class=anchor href=#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e5%a0%86>#</a></h1><h2 id=可合并堆>可合并堆
<a class=anchor href=#%e5%8f%af%e5%90%88%e5%b9%b6%e5%a0%86>#</a></h2><p>一个可合并堆应当支持以下的操作：</p><ul><li>创建空堆</li><li>插入关键字</li><li>取得最小值</li><li>删除最小值</li><li>合并两个堆</li></ul><p>除此之外，斐波那契堆还可以支持减小已有元素的关键字和删除关键字的操作。</p><p>之前出现过的二叉堆在前四个操作上效果都不错，时间代价为 $O(\log_2n)$。然而，在合并堆的操作上，二叉堆的速度非常慢。可以这样实现：将两个堆直接合并起来，再执行建堆操作。这样，复杂度会达到 $\Theta(n)$。斐波那契堆通常相比二叉堆具有更好的摊还代价。</p><table><thead><tr><th>堆</th><th>新建</th><th>插入</th><th>取堆顶</th><th>删除堆顶</th><th>合并堆</th><th>减小</th><th>删除</th></tr></thead><tbody><tr><td>二叉</td><td>$\Theta(1)$</td><td>$\Theta(\log_2n)$</td><td>$\Theta(1)$</td><td>$\Theta(\log_2n)$</td><td>$\Theta(n)$</td><td>$\Theta(\log_2n)$</td><td>$\Theta(\log_2n)$</td></tr><tr><td>斐波那契</td><td>$\Theta(1)$</td><td>$\Theta(1)$</td><td>$\Theta(1)$</td><td>$\Theta(n)$</td><td>$\Theta(1)$</td><td>$\Theta(1)$</td><td>$\Theta(n)$</td></tr></tbody></table><p>不过，实际情况下，斐波那契堆的常数代价比较高，编程实现也比较困难。因此，并不十分常用。</p><h2 id=斐波那契堆-1>斐波那契堆
<a class=anchor href=#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e5%a0%86-1>#</a></h2><p>一个斐波那契堆是一个森林，其中的每一棵树都符合最小堆性质，即，任何子节点的 key 大于其父节点。所有的根，即每一个结点的所有子节点，都被链接成一个环形双向链表。这样做的目的是，可以非常快速地向链表中插入一个新的节点，或者合并两个链表（在堆的合并操作中）。同一个链表中所有元素的顺序是任意的。</p><p>每个结点有两个额外的属性：子节点的数目 <code>degree</code>，和标记其自改变了父节点以来，是否失去过孩子的布尔值 <code>mark</code>。也就是说，新插入的结点和改变了父节点的结点的 <code>mark</code> 都是 <code>False</code>。堆的入口是一个指向 key 最小的根节点的指针 <code>H.min</code>。除此之外，堆还有一个属性 <code>H.n</code> 用来指示整个堆中的结点数。以 $t(H)$ 为树的数目，$m(H)$ 为已标记的结点数目，那么势函数：</p><p>$$
\Phi(H) = t(H) + 2m(H)
$$</p><p>另外，斐波那契堆中结点的度数，即子节点数将会得到限制。当支持堆合并操作时，最大度数 $D(n) \leqslant \lfloor \log_2n \rfloor$，当支持后两个操作时，会使得 $D(n) = O(\log_2n)$。</p><h2 id=斐波那契堆的操作>斐波那契堆的操作
<a class=anchor href=#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e5%a0%86%e7%9a%84%e6%93%8d%e4%bd%9c>#</a></h2><p>斐波那契堆的核心思想是尽量推后操作。所有的数据结构整理操作都被放在取出最小值的过程中。</p><ul><li><p>合并两个堆时，直接根链表连接起来中，并依需更新 <code>H.min</code> 和 <code>H.n</code> 即可。</p></li><li><p>插入一个新的元素时，实际上和把当前堆与一个大小为 1 的堆合并是一样的。</p></li><li><p>取得最小节点时，直接取 <code>H.min</code> 即可。</p></li><li><p>抽取最小节点时，首先将 <code>H.min</code> 指向的结点的所有子节点修改到根链表中。判断堆是否变成了空堆，随后，遍历所有根结点，把相同度数的根节点合并起来。操作结束后的根链表中所有结点的度都不相同。这个过程可以使用一个数组，数组的下标代表结点的度数。当出现冲突时，说明需要进行合并操作。合并时，直接把根节点较大的那个树变成另一棵树的子树即可。</p></li></ul><h2 id=斐波那契堆的其他操作>斐波那契堆的其他操作
<a class=anchor href=#%e6%96%90%e6%b3%a2%e9%82%a3%e5%a5%91%e5%a0%86%e7%9a%84%e5%85%b6%e4%bb%96%e6%93%8d%e4%bd%9c>#</a></h2><p>在降低一个节点的 key 值时，如果其父节点的 <code>mark</code> 为 <code>False</code>，可以直接将其切断变成一个根节点。这样，所有的性质都不被破坏。此时，依据上面所说，将其父节点的 <code>mark</code> 标记为 <code>True</code>。</p><p>当下一次要再次降低这个父节点的另一个儿子时，其父节点的 <code>mark</code> 就是 <code>True</code>，需要进行一次级联切断，将其父节点也切断变成根节点，并一直向上递归判断 <code>mark</code> 的值。</p><p>在删除一个结点时，相当于把这个节点的 key 降为最小，进行降低 key 值操作后，再执行取出最小值的操作。</p><h1 id=veb-树>vEB 树
<a class=anchor href=#veb-%e6%a0%91>#</a></h1><h2 id=叠加二叉树结构>叠加二叉树结构
<a class=anchor href=#%e5%8f%a0%e5%8a%a0%e4%ba%8c%e5%8f%89%e6%a0%91%e7%bb%93%e6%9e%84>#</a></h2><p>如图，使用一个二叉树作为索引，指示下面数组的对应位置是否存在元素。</p><p><img src=../chap20_1.png alt=二叉树结构></p><p>类似地，可以将其扩展，增加结点的大小：</p><p><img src=../chap20_2.png alt=扩展的树索引></p><h2 id=veb-树-1>vEB 树
<a class=anchor href=#veb-%e6%a0%91-1>#</a></h2><p>vEB 树可以认为是从带树索引的数组演化而来。其空间占用与 key 的取值范围 $u$ 有关。使用多层的树，树的每个节点都是另外一个 vEB 树，其取值范围是父节点所在树的二次方。自顶向下直到取值范围达到 2，成为叶子节点。</p><p>对于每一个结点，其数据结构包括其取值范围 $u$，极值 <code>min</code> 和 <code>max</code>，一个指向 $vEB(\sqrt u)$ 的指针 <code>summary</code>，以及一个长为 $\sqrt u$ 的数组，其中每个位置是一个指向 $vEB(\sqrt u)$ 的指针，即下一层 vEB 树。</p><p><code>summary</code> 的作用是上一节中每一层的 0-1 数组的作用。因为其大小同样为 $\sqrt u$，所以同样使用 vEB 树来储存。在访问时，需要先在 <code>summary</code> 中寻找对应的值，再去 <code>cluster</code> 中寻找数据。</p><p><img src=../chap20_3.png alt=二叉树结构></p><p>实际情况中，$\sqrt u$ 不一定是整数。因此，使用 $\sqrt[\uparrow]u > \sqrt u > \sqrt[\downarrow]u$，使得$\sqrt[\uparrow]u \cdot \sqrt[\downarrow]u = u$。那么，<code>summary</code> 指向一棵 $vEB(\sqrt[\uparrow]u)$，<code>cluster</code> 数组中的每一个指针指向 $vEB(\sqrt[\downarrow]u)$。</p><h2 id=veb-树的查找>vEB 树的查找
<a class=anchor href=#veb-%e6%a0%91%e7%9a%84%e6%9f%a5%e6%89%be>#</a></h2><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>vEB_FIND(V, x)
if x == min or x == max
    return TRUE
else if u == 2
    return FALSE
else return vEB_FIND(V.cluster[high(x)], x)
</code></pre><p>查找最大值和最小值相当于把上面的流程简化。</p><h1 id=用于处理不相交集合的数据结构>用于处理不相交集合的数据结构
<a class=anchor href=#%e7%94%a8%e4%ba%8e%e5%a4%84%e7%90%86%e4%b8%8d%e7%9b%b8%e4%ba%a4%e9%9b%86%e5%90%88%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h1><h2 id=不相交集合的操作>不相交集合的操作
<a class=anchor href=#%e4%b8%8d%e7%9b%b8%e4%ba%a4%e9%9b%86%e5%90%88%e7%9a%84%e6%93%8d%e4%bd%9c>#</a></h2><ul><li><code>MAKE_SET</code>：新建一个仅包含参数的集合</li><li><code>UNION</code>：取两个集合的并集</li><li><code>FIND_SET</code>：寻找包含参数的集合</li></ul><p>不相交集合的一个应用是处理无向图的连通分量。在寻找连通分量的过程中将会需要大量的不相交集合操作。</p><h2 id=不相交集合的链表表示>不相交集合的链表表示
<a class=anchor href=#%e4%b8%8d%e7%9b%b8%e4%ba%a4%e9%9b%86%e5%90%88%e7%9a%84%e9%93%be%e8%a1%a8%e8%a1%a8%e7%a4%ba>#</a></h2><p>使用一个链表来表示一个不相交集合，集合对象保留 <code>head</code> 和 <code>tail</code> 属性，每个元素对象保留指向集合的指针。这样，在寻找元素所在的集合时，就可以直接用指针返回集合。合并两个集合的链表非常容易，但合并时还需要修改其中一个集合的所有指向集合的指针。于是，最终操作的摊还代价达到了 $\Theta(n)$。</p><h2 id=不相交集合森林>不相交集合森林
<a class=anchor href=#%e4%b8%8d%e7%9b%b8%e4%ba%a4%e9%9b%86%e5%90%88%e6%a3%ae%e6%9e%97>#</a></h2><p>使用一棵树来表示一个集合。这样，FIND_SET 操作就变成了一直追随父节点直到树的根。UNION 操作只需要把一棵树变成另一棵的子树，即将其根节点指向另一棵树的根节点即可。</p><p>显然，无论链表还是森林，使较小或较矮的集合合并到较大的集合里都是提高效率的方法。此外，对于森林表示，还可以使用路径压缩的方式，这种方式的 FIND_SET 这样实现：</p><pre tabindex=0><code class=language-pseudocode data-lang=pseudocode>FIND_SET(x)
if x != x.p
    x.p = FIND_SET(x.p)
return x.p
</code></pre><p>这样，整个函数经过的路径上所有的结点都变成了直接指向根节点的结点。于是在未来的查询中，效率就能得到提升。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#b-树>B 树</a><ul><li><a href=#b-树的操作>B 树的操作</a></li><li><a href=#b-树-1>B+ 树</a></li></ul></li><li><a href=#斐波那契堆>斐波那契堆</a><ul><li><a href=#可合并堆>可合并堆</a></li><li><a href=#斐波那契堆-1>斐波那契堆</a></li><li><a href=#斐波那契堆的操作>斐波那契堆的操作</a></li><li><a href=#斐波那契堆的其他操作>斐波那契堆的其他操作</a></li></ul></li><li><a href=#veb-树>vEB 树</a><ul><li><a href=#叠加二叉树结构>叠加二叉树结构</a></li><li><a href=#veb-树-1>vEB 树</a></li><li><a href=#veb-树的查找>vEB 树的查找</a></li></ul></li><li><a href=#用于处理不相交集合的数据结构>用于处理不相交集合的数据结构</a><ul><li><a href=#不相交集合的操作>不相交集合的操作</a></li><li><a href=#不相交集合的链表表示>不相交集合的链表表示</a></li><li><a href=#不相交集合森林>不相交集合森林</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>