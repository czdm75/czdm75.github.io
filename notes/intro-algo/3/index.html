<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="链表 #  链表的哨兵结点 #  链表的哨兵结点表示 nil 值，其 prev 属性指向表尾，next 属性指向表头。这样，就可以省略掉 head 属性，并简化边界条件的处理。如果我们使用的是很多个很短的链表，哨兵结点就会造成比较严重的存储浪费。
不使用指针的链表 #    多数组的实现：对于双向链表，至少使用 3 个数组，分别为 prev、key、next，其值即为所指向对象的数组下标。每个数组相同下标的值合起来是一个完整的结点对象。
  单数组的实现：以一整个数组连续存储对象，使用下标代表指针。当需要访问对象的成员时，在指针上加一个偏移量。相对于多数组的实现，这种方式就可以支持不同长度的对象构成的链表。
  自由表：未被使用的，可能是之前被释放的内存单元组成的链表。。数组表示中的每一个对象不是在链表中，就一定在自由表中。实现上，自由表常常是一个链表栈。刚刚被释放的空间，在下一次插入中就会被用来存储新的对象。显然，多个链表也可以共用同一个自由表。使用自由表的释放操作和插入操作运行代价仍然是 $O(1)$，因此非常实用。
  有根树的表示 #  对于分叉数量未知的树，我们难以使用数组来储存孩子结点的指针。或者，如果最大孩子数很大，那么使用相同数量的指针空间将会浪费大量的存储空间。因此，在这里引入左孩子右兄弟表示法。
在这样表示的树中，每一个结点有三个指针：父结点，左孩子指针和一个兄弟指针，兄弟指针指向它右侧的具有同一个父结点的结点。同一个父结点的所有孩子结点实际上相当于构成一个链表。如果是最右子结点，就把兄弟指针设置为 nil。
散列函数 #  散列函数所需要的最基本性质是，尽量让 key 进入各个槽的概率平均。除此之外，还可能需要一些其他的性质。比如，可能希望相接近的关键字的散列值差距较大，在开放寻址法进行线性探查时需要这种性质，而这种性质由全域散列提供。此外，还可能需要把其他种类的关键字，或负数、浮点数等转换成自然数等。
除法散列 #  最简单的除法散列适用于平均分布的自然数序列。被除数选择不接近 2 的整数幂的较大的质数有利于散列。如对于一个预备存储 2000 个元素的散列表，可取 $h(k) = k \mod 701$。
乘法散列 #  用关键字乘一个常数，通常为一个无理数，取小数部分，再乘上一个值，取整变回自然数。如：
$$ h(k) = \lfloor m(kA \mod 1) \rfloor $$"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="3. LinkedList, HashTable"><meta property="og:description" content="链表 #  链表的哨兵结点 #  链表的哨兵结点表示 nil 值，其 prev 属性指向表尾，next 属性指向表头。这样，就可以省略掉 head 属性，并简化边界条件的处理。如果我们使用的是很多个很短的链表，哨兵结点就会造成比较严重的存储浪费。
不使用指针的链表 #    多数组的实现：对于双向链表，至少使用 3 个数组，分别为 prev、key、next，其值即为所指向对象的数组下标。每个数组相同下标的值合起来是一个完整的结点对象。
  单数组的实现：以一整个数组连续存储对象，使用下标代表指针。当需要访问对象的成员时，在指针上加一个偏移量。相对于多数组的实现，这种方式就可以支持不同长度的对象构成的链表。
  自由表：未被使用的，可能是之前被释放的内存单元组成的链表。。数组表示中的每一个对象不是在链表中，就一定在自由表中。实现上，自由表常常是一个链表栈。刚刚被释放的空间，在下一次插入中就会被用来存储新的对象。显然，多个链表也可以共用同一个自由表。使用自由表的释放操作和插入操作运行代价仍然是 $O(1)$，因此非常实用。
  有根树的表示 #  对于分叉数量未知的树，我们难以使用数组来储存孩子结点的指针。或者，如果最大孩子数很大，那么使用相同数量的指针空间将会浪费大量的存储空间。因此，在这里引入左孩子右兄弟表示法。
在这样表示的树中，每一个结点有三个指针：父结点，左孩子指针和一个兄弟指针，兄弟指针指向它右侧的具有同一个父结点的结点。同一个父结点的所有孩子结点实际上相当于构成一个链表。如果是最右子结点，就把兄弟指针设置为 nil。
散列函数 #  散列函数所需要的最基本性质是，尽量让 key 进入各个槽的概率平均。除此之外，还可能需要一些其他的性质。比如，可能希望相接近的关键字的散列值差距较大，在开放寻址法进行线性探查时需要这种性质，而这种性质由全域散列提供。此外，还可能需要把其他种类的关键字，或负数、浮点数等转换成自然数等。
除法散列 #  最简单的除法散列适用于平均分布的自然数序列。被除数选择不接近 2 的整数幂的较大的质数有利于散列。如对于一个预备存储 2000 个元素的散列表，可取 $h(k) = k \mod 701$。
乘法散列 #  用关键字乘一个常数，通常为一个无理数，取小数部分，再乘上一个值，取整变回自然数。如：
$$ h(k) = \lfloor m(kA \mod 1) \rfloor $$"><meta property="og:type" content="article"><meta property="og:url" content="/notes/intro-algo/3/"><meta property="article:section" content="notes"><title>3. LinkedList, HashTable | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle checked>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/ class=active>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>3. LinkedList, HashTable</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#链表>链表</a><ul><li><a href=#链表的哨兵结点>链表的哨兵结点</a></li><li><a href=#不使用指针的链表>不使用指针的链表</a></li><li><a href=#有根树的表示>有根树的表示</a></li></ul></li><li><a href=#散列函数>散列函数</a><ul><li><a href=#除法散列>除法散列</a></li><li><a href=#乘法散列>乘法散列</a></li><li><a href=#全域散列>全域散列</a></li><li><a href=#完全散列>完全散列</a></li></ul></li><li><a href=#散列冲突的解决>散列冲突的解决</a><ul><li><a href=#链接法拉链法>链接法（拉链法）</a></li><li><a href=#开放寻址法>开放寻址法</a><ul><li><a href=#线性探查>线性探查</a></li><li><a href=#二次探查>二次探查</a></li><li><a href=#双重散列>双重散列</a></li></ul></li><li><a href=#开放寻址的性能分析>开放寻址的性能分析</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=链表>链表
<a class=anchor href=#%e9%93%be%e8%a1%a8>#</a></h1><h2 id=链表的哨兵结点>链表的哨兵结点
<a class=anchor href=#%e9%93%be%e8%a1%a8%e7%9a%84%e5%93%a8%e5%85%b5%e7%bb%93%e7%82%b9>#</a></h2><p>链表的哨兵结点表示 <code>nil</code> 值，其 <code>prev</code> 属性指向表尾，<code>next</code> 属性指向表头。这样，就可以省略掉 <code>head</code> 属性，并简化边界条件的处理。如果我们使用的是很多个很短的链表，哨兵结点就会造成比较严重的存储浪费。</p><h2 id=不使用指针的链表>不使用指针的链表
<a class=anchor href=#%e4%b8%8d%e4%bd%bf%e7%94%a8%e6%8c%87%e9%92%88%e7%9a%84%e9%93%be%e8%a1%a8>#</a></h2><ul><li><p>多数组的实现：对于双向链表，至少使用 3 个数组，分别为 prev、key、next，其值即为所指向对象的数组下标。每个数组相同下标的值合起来是一个完整的结点对象。</p></li><li><p>单数组的实现：以一整个数组连续存储对象，使用下标代表指针。当需要访问对象的成员时，在指针上加一个偏移量。相对于多数组的实现，这种方式就可以支持不同长度的对象构成的链表。</p></li><li><p>自由表：未被使用的，可能是之前被释放的内存单元组成的链表。。数组表示中的每一个对象不是在链表中，就一定在自由表中。实现上，自由表常常是一个链表栈。刚刚被释放的空间，在下一次插入中就会被用来存储新的对象。显然，多个链表也可以共用同一个自由表。使用自由表的释放操作和插入操作运行代价仍然是 $O(1)$，因此非常实用。</p></li></ul><h2 id=有根树的表示>有根树的表示
<a class=anchor href=#%e6%9c%89%e6%a0%b9%e6%a0%91%e7%9a%84%e8%a1%a8%e7%a4%ba>#</a></h2><p>对于分叉数量未知的树，我们难以使用数组来储存孩子结点的指针。或者，如果最大孩子数很大，那么使用相同数量的指针空间将会浪费大量的存储空间。因此，在这里引入<strong>左孩子右兄弟表示法</strong>。</p><p>在这样表示的树中，每一个结点有三个指针：父结点，左孩子指针和一个兄弟指针，兄弟指针指向它右侧的具有同一个父结点的结点。同一个父结点的所有孩子结点实际上相当于构成一个链表。如果是最右子结点，就把兄弟指针设置为 <code>nil</code>。</p><h1 id=散列函数>散列函数
<a class=anchor href=#%e6%95%a3%e5%88%97%e5%87%bd%e6%95%b0>#</a></h1><p>散列函数所需要的最基本性质是，尽量让 key 进入各个槽的概率平均。除此之外，还可能需要一些其他的性质。比如，可能希望相接近的关键字的散列值差距较大，在开放寻址法进行线性探查时需要这种性质，而这种性质由全域散列提供。此外，还可能需要把其他种类的关键字，或负数、浮点数等转换成自然数等。</p><h2 id=除法散列>除法散列
<a class=anchor href=#%e9%99%a4%e6%b3%95%e6%95%a3%e5%88%97>#</a></h2><p>最简单的除法散列适用于平均分布的自然数序列。被除数选择不接近 2 的整数幂的较大的质数有利于散列。如对于一个预备存储 2000 个元素的散列表，可取 $h(k) = k \mod 701$。</p><h2 id=乘法散列>乘法散列
<a class=anchor href=#%e4%b9%98%e6%b3%95%e6%95%a3%e5%88%97>#</a></h2><p>用关键字乘一个常数，通常为一个无理数，取小数部分，再乘上一个值，取整变回自然数。如：</p><p>$$
h(k) = \lfloor m(kA \mod 1) \rfloor
$$</p><p>乘法散列对 $m$ 的值并不挑剔，一般取为一个 2 的幂，这样在计算机内部可以直接通过取一个数的高位来获得散列值。$A$ 的一个比较理想的值为 $\sqrt5-1 \approx 0.618033 \cdots$。</p><h2 id=全域散列>全域散列
<a class=anchor href=#%e5%85%a8%e5%9f%9f%e6%95%a3%e5%88%97>#</a></h2><p>全域散列的思想是通过随机选择散列函数，避免最坏情况的，即所有元素都放置在同一个槽的情况出现。</p><h2 id=完全散列>完全散列
<a class=anchor href=#%e5%ae%8c%e5%85%a8%e6%95%a3%e5%88%97>#</a></h2><p>完全散列的最坏情况查找只需要 $O(1)$ 次访存。一种完全散列的方法是，使用两层散列表。通过精心设计第二层散列函数，使得在第一集中落到同一个槽中的元素在第二级不再出现冲突。为了达到这个目的，第二层的槽数需要为散列到该槽中的关键字数的平方。</p><h1 id=散列冲突的解决>散列冲突的解决
<a class=anchor href=#%e6%95%a3%e5%88%97%e5%86%b2%e7%aa%81%e7%9a%84%e8%a7%a3%e5%86%b3>#</a></h1><h2 id=链接法拉链法>链接法（拉链法）
<a class=anchor href=#%e9%93%be%e6%8e%a5%e6%b3%95%e6%8b%89%e9%93%be%e6%b3%95>#</a></h2><p>每个散列的槽对应的是一个链表，其中存储所有该散列值的元素。如果要不重复地插入元素，或者删除指定 key 的元素，显然需要搜索整个链表。因此，操作的时间代价取决于链表的长度。</p><p>定义散列表的装载因子，即元素数与槽数的比 $\frac n m$ 为 $\alpha$。链表的查找时间取决于链表的长度，显然，最坏情况下整个散列表的查找时间为 $\Theta(n)$。每个槽链表长度期望等于 $\alpha$，时间代价期望为 $\Theta(1+\alpha)$。这是建立在散列完全均匀的假设下。</p><h2 id=开放寻址法>开放寻址法
<a class=anchor href=#%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e6%b3%95>#</a></h2><p>开放寻址法意味着散列表中不存在链表，表有可能被填满。当出现散列冲突时，就根据一定的原则继续寻找下一个可以存储的位置。常见的探查方法有三种：线性探查、二次探查和双重探查。在以下的表述中，我们将未加入探查功能的散列函数称为辅助散列函数，以 $h&rsquo;$ 表示。</p><h3 id=线性探查>线性探查
<a class=anchor href=#%e7%ba%bf%e6%80%a7%e6%8e%a2%e6%9f%a5>#</a></h3><p>$$
h(k,i) = (h&rsquo;(k)+i) \mod m
$$</p><p>式中 $i$ 为探查的次数。线性探查是在失败之后，线性地依次查看后面的槽位，直到找到空的槽为止。线性探查容易实现，但容易发生群集。即，被占用的槽很可能形成连续的长序列，当辅助函数落到这个序列的头部时，就需要相当长的探查序列。</p><h3 id=二次探查>二次探查
<a class=anchor href=#%e4%ba%8c%e6%ac%a1%e6%8e%a2%e6%9f%a5>#</a></h3><p>$$
h(k,i) = (h&rsquo;(k) + c_1i + c_2i^2) \mod m
$$</p><p>线性探查相当于这种方式在常数 $c_1=1,c_2=0$ 时的情况。由于探查位置二次依赖于 $c_2$，探查序列不容易过于群集。</p><h3 id=双重散列>双重散列
<a class=anchor href=#%e5%8f%8c%e9%87%8d%e6%95%a3%e5%88%97>#</a></h3><p>$$
h(k,i) = (h_1(k) + ih_2(k)) \mod m
$$</p><p>双重散列是开放寻址的最好方法之一，需要注意的是 $h_2(k)$ 必须与 $m$ 互质。一个方法是，取 $m$ 为 2 的幂，并设计一个永远产生奇数的 $h_2$。另一种方式是，取 $m$ 为质数，并让 $h_2(k)$ 略小于 $m$。前两种方法可能的探查序列有 $\theta(m)$ 种，而双重散列将其提升到了 $\Theta(m^2)$ 种。</p><h2 id=开放寻址的性能分析>开放寻址的性能分析
<a class=anchor href=#%e5%bc%80%e6%94%be%e5%af%bb%e5%9d%80%e7%9a%84%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90>#</a></h2><p>仍旧使用装载因子 $\alpha$ 的概念。不过，在开放寻址中，$\alpha$ 始终小于 1。和之前一样，$i$ 是探查的次数。于是，探查次数期望的上界：</p><p>$$
\mathrm E[X]
= \sum_{i=1}^\infty \Pr\{X \geqslant i\}
\leqslant \sum_{i=1}^\infty \alpha^{i-1}
= \frac 1 {1-\alpha}
$$</p><p>实际上，一次成功查找的探查期望次数是：</p><p>$$
\frac 1\alpha\ln\frac 1{1-\alpha}
$$</p><p>如果散列表是半满的，探查的期望小于 1.387. 如果散列表 90% 满，期望小于 2.559.</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#链表>链表</a><ul><li><a href=#链表的哨兵结点>链表的哨兵结点</a></li><li><a href=#不使用指针的链表>不使用指针的链表</a></li><li><a href=#有根树的表示>有根树的表示</a></li></ul></li><li><a href=#散列函数>散列函数</a><ul><li><a href=#除法散列>除法散列</a></li><li><a href=#乘法散列>乘法散列</a></li><li><a href=#全域散列>全域散列</a></li><li><a href=#完全散列>完全散列</a></li></ul></li><li><a href=#散列冲突的解决>散列冲突的解决</a><ul><li><a href=#链接法拉链法>链接法（拉链法）</a></li><li><a href=#开放寻址法>开放寻址法</a><ul><li><a href=#线性探查>线性探查</a></li><li><a href=#二次探查>二次探查</a></li><li><a href=#双重散列>双重散列</a></li></ul></li><li><a href=#开放寻址的性能分析>开放寻址的性能分析</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>