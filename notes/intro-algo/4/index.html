<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="二叉搜索树 #  对一个二叉搜索树，任何一个结点的左子结点不大于它本身，右子结点不小于它本身。这样，就可以简单地使用中序遍历查找元素。中序遍历打印出来的序列，就是已经排序完成的序列。中序遍历的时间代价为 $\Theta(n)$。
二叉搜索树的基本操作 #  在高 $h$ 的树上，以下操作的时间代价均为 $O(h)$。
 查找：比较和当前结点的大小，选择子树。 最大和最小：不断取左子结点或右子结点。  深度优先遍历的方式：
 前序遍历 中序遍历 后序遍历  后继前驱 #  如果关键字不重复，那么一个结点的中序遍历后继为大于这个结点的最小者，即升序序列中的下一个。如果结点的右子树非空，那么右树中的最左结点即为后继结点，不断向左寻找即可。
如果右子树为空，说明这个结点是某个左子树的最右结点，而这个左子树的父结点即为后继结点。这意味着，遍历这个结点之后，这个左子树遍历完成，进入某个遍历过程的根结点部分。于是，不断向上寻找，如果当前结点不再是右结点，说明已经找到了这个根结点。如果找到了 $nil$，则说明没有后继，这个结点是整个树的最右结点。
前驱和后继的过程对称，时间代价均为 $O(h)$。
插入和删除 #  插入过程比较简单。寻找结点的关键字应该在的位置，并修改父结点的指针即可。
删除结点可分为三种情况：
 没有子结点，直接删除并修改父结点的指针即可。 只有一个孩子，则用这个孩子来替代这个结点。 两个孩子，则使用后继结点来替代这个结点。由于被删除的这个后继结点是右子树的最左结点，其一定没有左子节点。因此，使用其右子节点代替它的位置，并用这个节点代替待删除的结点。于是，删除完成。  显然，这两种操作的时间代价也是 $O(h)$。
随机构建二叉搜索树 #  二叉搜索树的构建由插入和删除操作完成。显然，实际情况中，这是一个随机过程。在最坏情况下，当元素严格升序或降序插入，二叉搜索树将成为一个链表。十分显而易见的是，在完全随机的情况下，元素均匀插入，二叉树接近完全，其高度的期望为 $O(\log_2n)$。
红黑树 #  性质 #  一个基于二叉搜索树增加一个颜色属性的树，保证没有任何路径会比另一条路径长出二倍的近似平衡树。
 每个结点是红色或黑色的 根结点是黑色的 每个叶子结点都是黑色的 如果一个结点是红色的，则其两个子结点都是黑色的 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同树木的黑色结点。  性质 5 是红黑树的核心：红黑树是一颗近似平衡二叉树。
为了避免叶子结点的空间浪费，可以指定一个哨兵结点为 NIL，并使所有叶子都指向这一个结点。通常忽略叶子结点，因为其并不储存 key 值。
定义任何一个结点的黑高为从该结点到其后代叶子结点的路径上黑色结点的数目。根据性质 5，任何一条简单路径的黑高都相同。一颗有 $n$ 个内部结点的红黑树的高度至多为 $2\log_2(n+1)$。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="4. BST, Balanced BSTs"><meta property="og:description" content="二叉搜索树 #  对一个二叉搜索树，任何一个结点的左子结点不大于它本身，右子结点不小于它本身。这样，就可以简单地使用中序遍历查找元素。中序遍历打印出来的序列，就是已经排序完成的序列。中序遍历的时间代价为 $\Theta(n)$。
二叉搜索树的基本操作 #  在高 $h$ 的树上，以下操作的时间代价均为 $O(h)$。
 查找：比较和当前结点的大小，选择子树。 最大和最小：不断取左子结点或右子结点。  深度优先遍历的方式：
 前序遍历 中序遍历 后序遍历  后继前驱 #  如果关键字不重复，那么一个结点的中序遍历后继为大于这个结点的最小者，即升序序列中的下一个。如果结点的右子树非空，那么右树中的最左结点即为后继结点，不断向左寻找即可。
如果右子树为空，说明这个结点是某个左子树的最右结点，而这个左子树的父结点即为后继结点。这意味着，遍历这个结点之后，这个左子树遍历完成，进入某个遍历过程的根结点部分。于是，不断向上寻找，如果当前结点不再是右结点，说明已经找到了这个根结点。如果找到了 $nil$，则说明没有后继，这个结点是整个树的最右结点。
前驱和后继的过程对称，时间代价均为 $O(h)$。
插入和删除 #  插入过程比较简单。寻找结点的关键字应该在的位置，并修改父结点的指针即可。
删除结点可分为三种情况：
 没有子结点，直接删除并修改父结点的指针即可。 只有一个孩子，则用这个孩子来替代这个结点。 两个孩子，则使用后继结点来替代这个结点。由于被删除的这个后继结点是右子树的最左结点，其一定没有左子节点。因此，使用其右子节点代替它的位置，并用这个节点代替待删除的结点。于是，删除完成。  显然，这两种操作的时间代价也是 $O(h)$。
随机构建二叉搜索树 #  二叉搜索树的构建由插入和删除操作完成。显然，实际情况中，这是一个随机过程。在最坏情况下，当元素严格升序或降序插入，二叉搜索树将成为一个链表。十分显而易见的是，在完全随机的情况下，元素均匀插入，二叉树接近完全，其高度的期望为 $O(\log_2n)$。
红黑树 #  性质 #  一个基于二叉搜索树增加一个颜色属性的树，保证没有任何路径会比另一条路径长出二倍的近似平衡树。
 每个结点是红色或黑色的 根结点是黑色的 每个叶子结点都是黑色的 如果一个结点是红色的，则其两个子结点都是黑色的 对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同树木的黑色结点。  性质 5 是红黑树的核心：红黑树是一颗近似平衡二叉树。
为了避免叶子结点的空间浪费，可以指定一个哨兵结点为 NIL，并使所有叶子都指向这一个结点。通常忽略叶子结点，因为其并不储存 key 值。
定义任何一个结点的黑高为从该结点到其后代叶子结点的路径上黑色结点的数目。根据性质 5，任何一条简单路径的黑高都相同。一颗有 $n$ 个内部结点的红黑树的高度至多为 $2\log_2(n+1)$。"><meta property="og:type" content="article"><meta property="og:url" content="/notes/intro-algo/4/"><meta property="article:section" content="notes"><title>4. BST, Balanced BSTs | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle checked>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/ class=active>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>4. BST, Balanced BSTs</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#二叉搜索树>二叉搜索树</a><ul><li><a href=#二叉搜索树的基本操作>二叉搜索树的基本操作</a></li><li><a href=#后继前驱>后继前驱</a></li><li><a href=#插入和删除>插入和删除</a></li><li><a href=#随机构建二叉搜索树>随机构建二叉搜索树</a></li></ul></li><li><a href=#红黑树>红黑树</a><ul><li><a href=#性质>性质</a></li><li><a href=#旋转操作>旋转操作</a></li><li><a href=#插入>插入</a></li><li><a href=#删除操作>删除操作</a></li></ul></li><li><a href=#avl-树>AVL 树</a><ul><li><a href=#插入-1>插入</a></li><li><a href=#删除>删除</a></li></ul></li><li><a href=#b-树与红黑树>B 树与红黑树</a><ul><li><a href=#2-3-树3-阶-b-树>2-3 树（3 阶 B 树）</a></li><li><a href=#2-3-4-树与红黑树>2-3-4 树与红黑树</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=二叉搜索树>二叉搜索树
<a class=anchor href=#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91>#</a></h1><p>对一个二叉搜索树，任何一个结点的左子结点不大于它本身，右子结点不小于它本身。这样，就可以简单地使用中序遍历查找元素。中序遍历打印出来的序列，就是已经排序完成的序列。中序遍历的时间代价为 $\Theta(n)$。</p><h2 id=二叉搜索树的基本操作>二叉搜索树的基本操作
<a class=anchor href=#%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c>#</a></h2><p>在高 $h$ 的树上，以下操作的时间代价均为 $O(h)$。</p><ul><li>查找：比较和当前结点的大小，选择子树。</li><li>最大和最小：不断取左子结点或右子结点。</li></ul><p>深度优先遍历的方式：</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><h2 id=后继前驱>后继前驱
<a class=anchor href=#%e5%90%8e%e7%bb%a7%e5%89%8d%e9%a9%b1>#</a></h2><p>如果关键字不重复，那么一个结点的中序遍历后继为大于这个结点的最小者，即升序序列中的下一个。如果结点的右子树非空，那么右树中的最左结点即为后继结点，不断向左寻找即可。</p><p>如果右子树为空，说明这个结点是某个左子树的最右结点，而这个左子树的父结点即为后继结点。这意味着，遍历这个结点之后，这个左子树遍历完成，进入某个遍历过程的根结点部分。于是，不断向上寻找，如果当前结点不再是右结点，说明已经找到了这个根结点。如果找到了 $nil$，则说明没有后继，这个结点是整个树的最右结点。</p><p>前驱和后继的过程对称，时间代价均为 $O(h)$。</p><h2 id=插入和删除>插入和删除
<a class=anchor href=#%e6%8f%92%e5%85%a5%e5%92%8c%e5%88%a0%e9%99%a4>#</a></h2><p>插入过程比较简单。寻找结点的关键字应该在的位置，并修改父结点的指针即可。</p><p>删除结点可分为三种情况：</p><ul><li>没有子结点，直接删除并修改父结点的指针即可。</li><li>只有一个孩子，则用这个孩子来替代这个结点。</li><li>两个孩子，则使用后继结点来替代这个结点。由于被删除的这个后继结点是右子树的最左结点，其一定没有左子节点。因此，使用其右子节点代替它的位置，并用这个节点代替待删除的结点。于是，删除完成。</li></ul><p>显然，这两种操作的时间代价也是 $O(h)$。</p><h2 id=随机构建二叉搜索树>随机构建二叉搜索树
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%90%9c%e7%b4%a2%e6%a0%91>#</a></h2><p>二叉搜索树的构建由插入和删除操作完成。显然，实际情况中，这是一个随机过程。在最坏情况下，当元素严格升序或降序插入，二叉搜索树将成为一个链表。十分显而易见的是，在完全随机的情况下，元素均匀插入，二叉树接近完全，其高度的期望为 $O(\log_2n)$。</p><h1 id=红黑树>红黑树
<a class=anchor href=#%e7%ba%a2%e9%bb%91%e6%a0%91>#</a></h1><h2 id=性质>性质
<a class=anchor href=#%e6%80%a7%e8%b4%a8>#</a></h2><p>一个基于二叉搜索树增加一个颜色属性的树，保证没有任何路径会比另一条路径长出二倍的近似平衡树。</p><ul><li>每个结点是红色或黑色的</li><li>根结点是黑色的</li><li>每个叶子结点都是黑色的</li><li>如果一个结点是红色的，则其两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同树木的黑色结点。</li></ul><p>性质 5 是红黑树的核心：红黑树是一颗近似平衡二叉树。</p><p>为了避免叶子结点的空间浪费，可以指定一个哨兵结点为 NIL，并使所有叶子都指向这一个结点。通常忽略叶子结点，因为其并不储存 key 值。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Red-black_tree_example.svg/1350px-Red-black_tree_example.svg.png alt="An example of a red-black tree"></p><p>定义任何一个结点的黑高为从该结点到其后代叶子结点的路径上黑色结点的数目。根据性质 5，任何一条简单路径的黑高都相同。一颗有 $n$ 个内部结点的红黑树的高度至多为 $2\log_2(n+1)$。</p><h2 id=旋转操作>旋转操作
<a class=anchor href=#%e6%97%8b%e8%bd%ac%e6%93%8d%e4%bd%9c>#</a></h2><p>显然，红黑树的查找和一般的二叉搜索树一样。对于插入和删除，为了维护红黑树的性质，需要进行旋转操作。两种操作的时间代价均为 $O(\log_2n)$。旋转操作分为左旋和右旋。旋转的目的是改变两棵子树的高度。旋转前后二叉搜索树的性质不变。可以看到，旋转前后，除 P、Q 两个结点之外的其他三个之间的左右顺序不变，这保持了二叉搜索树的性质。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png alt="Rotation of Tree"></p><h2 id=插入>插入
<a class=anchor href=#%e6%8f%92%e5%85%a5>#</a></h2><p>将要插入的结点按照正常二叉搜索树插入，这时有可能破坏性质 4、5。我们把这个结点标记为红色，于是只可能违反性质 4。然后，调用一个过程，从这个新结点开始进行红黑树的调整。我们将所有情形概括为 5 种：</p><ol><li><p>如果新插入的结点是整棵树的根结点结点，显然直接将其涂为黑色即可。</p></li><li><p>或者，新结点的父结点是黑色。这时，红黑树的任何性质都没有受到影响，无需任何操作。否则，为了保证被插入结点的父结点左右黑高相等，我们就需要进行旋转调整。旋转调整分为以下三种情形：</p></li><li><p>父结点和叔父结点（父结点的兄弟结点）都是红色的。为了满足性质 4，将这两个结点都涂成黑色，并将祖父结点涂成红色。这时，新加入的结点和两个父辈结点都能保证符合红黑树的性质，而被涂红的祖父结点不一定。将祖父结点当成新加入的结点，递归地从情形 1 开始进行整个检查过程。</p></li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/c/c8/Red-black_tree_insert_case_3.png alt=情形3示意图></p><ol start=4><li>父结点是红色，叔父结点为黑色或不存在（实际上是黑色的哨兵结点），并且，子结点方向不一致。形象地说，新结点、父结点、祖父结点不在同一条直线上，有一个拐弯。此时，首先进行一次旋转，将其与其父结点 P 对调。三代结点现在位于一条直线上，都是左子结点或右子结点。随后，把被调换到下面的 P 当做新加入的结点，进行情形 5 的操作。</li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/5/56/Red-black_tree_insert_case_4.png alt=情形4示意图></p><ol start=5><li>父结点是红色，叔父结点为黑色或不存在，并且新结点 N 和其父结点 P 都是各自父结点的同一个方向的子结点。即，三代结点在一条直线上。对新结点的父结点和祖父结点进行一次旋转。即，将这条直线的中间一点变成高点。这个过程，实际上是由于无法直接通过着色来满足性质 4，于是选择通过旋转来改变新结点的父结点。</li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/6/66/Red-black_tree_insert_case_5.png alt=情形5示意图></p><p>所有的情形，使用的都是尾递归。因此，整个算法是一个原地算法。算法的时间代价为 $O(\log_2n)$，且最多发生两次旋转，即情形 4-5 的路径。</p><h2 id=删除操作>删除操作
<a class=anchor href=#%e5%88%a0%e9%99%a4%e6%93%8d%e4%bd%9c>#</a></h2><p>对任何一个结点，它本身有红色和黑色两种可能，子结点的情况有 0、1、2 三种可能，得到以下的这些情况：</p><ul><li><p>被删结点为红色，没有子结点：直接删除即可。</p></li><li><p>被删结点为黑色，并有一个子结点。这时，这个子结点必然为红色。于是，交换这两个结点并改变颜色，就可以安全删除。</p></li><li><p>被删结点为红色，并有一个子结点。这种情况不可能存在。</p></li><li><p>被删结点有两个子结点。这时，首先使用与二叉搜索树一样的方法，用后继结点替代这个结点。在这里只对 key 进行替代即可。此时，实际上就变成了删除后继结点的情况，可以进行递归讨论。</p></li></ul><p>接下来讨论被删结点为黑色且没有子结点的情况。以下所有的图中，N 为被删除的结点的位置，P 是父结点，S 是兄弟结点。</p><ol><li>兄弟结点为黑色，且有一个与兄弟结点方向一致的红色子结点。这时，进行旋转操作。</li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png alt="情形 6 示意图"></p><ol start=2><li>兄弟结点为黑色，且兄弟结点有一个方向不一致的红色子结点。这时，先将兄弟结点进行一次旋转，转化为第 1 种情形。</li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png alt="情形 5 示意图"></p><ol start=3><li><p>兄弟结点为黑色，且兄弟结点没有红色子结点。</p><ol><li><p>若父结点为红，直接对兄弟结点和父结点重新着色即可。</p></li><li><p>若父结点为黑色，则对兄弟结点标为黑色，并对父结点进行递归判断。</p></li></ol></li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/d/d7/Red-black_tree_delete_case_4.png alt="情形 4 示意图"></p><p><img src=https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png alt="情形 3 示意图"></p><ol start=4><li>兄弟结点为红色。此时，父结点一定是黑色。对父结点和兄弟结点进行一次旋转并重新上色。</li></ol><p><img src=https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png alt="情形 2 示意图"></p><h1 id=avl-树>AVL 树
<a class=anchor href=#avl-%e6%a0%91>#</a></h1><p>AVL 树是另一种二叉平衡树。由于这种树的维护代价比较高，在实际应用中并不常见。不过其操作的复杂度同样为 $O(\log_2n)$。在 AVL 树中，两个分支的高度最多相差 1。AVL 树的旋转操作与红黑树类似，只是对于每个结点，不再有红黑属性值，而是变成了高度值（从一个布尔值变成一个整型）。另一种实现是存储两个子树高度的差，此时这个值的范围是 -1、0 或 1。</p><p>由于所有路径的高度最多相差 1，从任何一个结点向上到根的路径上，最多有两个不平衡的结点（只有一个子结点）。在改变结点之后，如果路径上存在两个不平衡的结点，就需要调整。</p><h2 id=插入-1>插入
<a class=anchor href=#%e6%8f%92%e5%85%a5-1>#</a></h2><p>我们把插入之后得到的情况分为 4 种，分别称为 LL、LR、RL、RR。通过旋转操作，将树重新平衡。在按照二叉搜索树的方法插入新结点后，要从新的结点一直回溯到根，逐个遍历，判断是否需要进行旋转。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/c/c7/Tree_Rebalancing.png alt=avl树旋转的图形描述></p><h2 id=删除>删除
<a class=anchor href=#%e5%88%a0%e9%99%a4>#</a></h2><p>与一般的二叉搜索树一样，将含有两个子结点的结点的删除操作转化为其前驱或后继结点的删除。随后，同样回溯到根，检查是否出现失衡。</p><h1 id=b-树与红黑树>B 树与红黑树
<a class=anchor href=#b-%e6%a0%91%e4%b8%8e%e7%ba%a2%e9%bb%91%e6%a0%91>#</a></h1><h2 id=2-3-树3-阶-b-树>2-3 树（3 阶 B 树）
<a class=anchor href=#2-3-%e6%a0%913-%e9%98%b6-b-%e6%a0%91>#</a></h2><p>我们将结点分为两种，2 - 结点有一个 key，并有两个子结点。3 - 结点有两个 key，有三个子结点并保持类似于二叉搜索树的性质。注意，2-3 树中每一层都必须是完全的，也就是不存在 NIL。在向 3 - 结点进行插入时，结点分裂，挤出一个 key 给父结点，并向上回溯。2-3 树是一个绝对平衡的树，操作的复杂度为 $\Theta(\log_2n)$。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/2-3_insertion.svg/581px-2-3_insertion.svg.png alt="2-3 树的插入"></p><h2 id=2-3-4-树与红黑树>2-3-4 树与红黑树
<a class=anchor href=#2-3-4-%e6%a0%91%e4%b8%8e%e7%ba%a2%e9%bb%91%e6%a0%91>#</a></h2><p>2-3-4 树的结构和 2-3 树类似，只是最大的结点变成了 4- 结点。可以看到，这类树的实现比较复杂。现在考虑：将红黑树的所有红色的边放平。并合并。于是，红黑树的黑高变成了 2-3-4 树的高，红色的结点与其父结点合并变成了 2-3-4 树的结点。于是，红黑树与 2-3-4 树是等价的。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#二叉搜索树>二叉搜索树</a><ul><li><a href=#二叉搜索树的基本操作>二叉搜索树的基本操作</a></li><li><a href=#后继前驱>后继前驱</a></li><li><a href=#插入和删除>插入和删除</a></li><li><a href=#随机构建二叉搜索树>随机构建二叉搜索树</a></li></ul></li><li><a href=#红黑树>红黑树</a><ul><li><a href=#性质>性质</a></li><li><a href=#旋转操作>旋转操作</a></li><li><a href=#插入>插入</a></li><li><a href=#删除操作>删除操作</a></li></ul></li><li><a href=#avl-树>AVL 树</a><ul><li><a href=#插入-1>插入</a></li><li><a href=#删除>删除</a></li></ul></li><li><a href=#b-树与红黑树>B 树与红黑树</a><ul><li><a href=#2-3-树3-阶-b-树>2-3 树（3 阶 B 树）</a></li><li><a href=#2-3-4-树与红黑树>2-3-4 树与红黑树</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script>
<script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>