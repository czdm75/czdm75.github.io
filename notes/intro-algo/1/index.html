<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="代价分析和复杂度 # 示例与概念 # 例子：插入排序 例子：归并排序 最坏情况分析 vs 平均情况分析 函数增长的渐进记号 # $O(n)$, $\Theta(n)$, $\Omega(n)$ 表示函数增长的上界、上下界、下界 $o(n)$, $\omega(n)$ 表示不紧确的上下界 常用 $T(n)$ 表示所需的实际时间的函数 分析分治算法，以归并排序为例 # 归并排序最坏运行时间的递归式：
$$ T(n)= \begin{cases} \Theta(1) & \text{if } n=1 \cr 2T(n/2) + \Theta(n) & \text{if } n>1 \end{cases} $$
除使用主定理外，还可以这样理解递归式的值：将递归过程看做一个二叉树。递归调用中的每一层的总代价均为 $cn$，其中 $c$ 为常数。而二叉树的层数应为 $\log_2n+1$，故整个算法的代价期望为 $\Theta(n\log_2n)$。
分治法 # 分治法求最大和的子数组 # 分解。将数组划分为两个子数组。此时，只存在三种子数组：
全部位于中点左侧的子数组 全部位于中点右侧的子数组 跨越中点的子数组 解决。
对于位于中点一侧的子数组，可以直接用递归解决。 对于跨越中点的子数组，将其分为左侧和右侧两部分。那么，左右两个数组都必定是所有以中点为两个边界之一的子数组的最大者。因此，从中点出发，向两侧扫描，并计算从中点到此元素的总和，找到最大。 合并。找到以上三个数组中总和最大者，即为结果。
矩阵乘法的 Strassen 算法 # 朴素的矩阵乘法 # 按照定义进行的矩阵乘法:
$$ C_{ij} = \sum_{k=1}^{n} a_{ik} \cdot b_{kj} $$"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/notes/intro-algo/1/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="1. Compexity, Divide"><meta property="og:description" content="代价分析和复杂度 # 示例与概念 # 例子：插入排序 例子：归并排序 最坏情况分析 vs 平均情况分析 函数增长的渐进记号 # $O(n)$, $\Theta(n)$, $\Omega(n)$ 表示函数增长的上界、上下界、下界 $o(n)$, $\omega(n)$ 表示不紧确的上下界 常用 $T(n)$ 表示所需的实际时间的函数 分析分治算法，以归并排序为例 # 归并排序最坏运行时间的递归式：
$$ T(n)= \begin{cases} \Theta(1) & \text{if } n=1 \cr 2T(n/2) + \Theta(n) & \text{if } n>1 \end{cases} $$
除使用主定理外，还可以这样理解递归式的值：将递归过程看做一个二叉树。递归调用中的每一层的总代价均为 $cn$，其中 $c$ 为常数。而二叉树的层数应为 $\log_2n+1$，故整个算法的代价期望为 $\Theta(n\log_2n)$。
分治法 # 分治法求最大和的子数组 # 分解。将数组划分为两个子数组。此时，只存在三种子数组：
全部位于中点左侧的子数组 全部位于中点右侧的子数组 跨越中点的子数组 解决。
对于位于中点一侧的子数组，可以直接用递归解决。 对于跨越中点的子数组，将其分为左侧和右侧两部分。那么，左右两个数组都必定是所有以中点为两个边界之一的子数组的最大者。因此，从中点出发，向两侧扫描，并计算从中点到此元素的总和，找到最大。 合并。找到以上三个数组中总和最大者，即为结果。
矩阵乘法的 Strassen 算法 # 朴素的矩阵乘法 # 按照定义进行的矩阵乘法:
$$ C_{ij} = \sum_{k=1}^{n} a_{ik} \cdot b_{kj} $$"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><title>1. Compexity, Divide | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle checked>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/ class=active>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>1. Compexity, Divide</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#代价分析和复杂度>代价分析和复杂度</a><ul><li><a href=#示例与概念>示例与概念</a></li><li><a href=#函数增长的渐进记号>函数增长的渐进记号</a></li><li><a href=#分析分治算法以归并排序为例>分析分治算法，以归并排序为例</a></li></ul></li><li><a href=#分治法>分治法</a><ul><li><a href=#分治法求最大和的子数组>分治法求最大和的子数组</a></li><li><a href=#矩阵乘法的-strassen-算法>矩阵乘法的 Strassen 算法</a><ul><li><a href=#朴素的矩阵乘法>朴素的矩阵乘法</a></li><li><a href=#简单的分治算法>简单的分治算法</a></li><li><a href=#strassen-方法>Strassen 方法</a></li></ul></li><li><a href=#求解递归式>求解递归式</a><ul><li><a href=#代入法--简单的数学归纳法>代入法 / 简单的数学归纳法</a></li><li><a href=#递归树法>递归树法</a></li><li><a href=#主定理>主定理</a></li></ul></li></ul></li><li><a href=#概率分析和随机算法>概率分析和随机算法</a><ul><li><a href=#雇用问题>雇用问题</a><ul><li><a href=#问题描述>问题描述</a></li><li><a href=#使用随机指示器分析雇用问题>使用随机指示器分析雇用问题</a></li></ul></li><li><a href=#随机算法>随机算法</a><ul><li><a href=#随机排列数组>随机排列数组</a></li><li><a href=#原地随机化>原地随机化</a></li></ul></li><li><a href=#其他随机相关问题>其他随机相关问题</a><ul><li><a href=#球与箱子问题>球与箱子问题</a></li><li><a href=#特征序列>特征序列</a></li><li><a href=#在线雇用问题>在线雇用问题</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=代价分析和复杂度>代价分析和复杂度
<a class=anchor href=#%e4%bb%a3%e4%bb%b7%e5%88%86%e6%9e%90%e5%92%8c%e5%a4%8d%e6%9d%82%e5%ba%a6>#</a></h1><h2 id=示例与概念>示例与概念
<a class=anchor href=#%e7%a4%ba%e4%be%8b%e4%b8%8e%e6%a6%82%e5%bf%b5>#</a></h2><ul><li>例子：插入排序</li><li>例子：归并排序</li><li>最坏情况分析 vs 平均情况分析</li></ul><h2 id=函数增长的渐进记号>函数增长的渐进记号
<a class=anchor href=#%e5%87%bd%e6%95%b0%e5%a2%9e%e9%95%bf%e7%9a%84%e6%b8%90%e8%bf%9b%e8%ae%b0%e5%8f%b7>#</a></h2><ul><li>$O(n)$, $\Theta(n)$, $\Omega(n)$ 表示函数增长的上界、上下界、下界</li><li>$o(n)$, $\omega(n)$ 表示不紧确的上下界</li><li>常用 $T(n)$ 表示所需的实际时间的函数</li></ul><h2 id=分析分治算法以归并排序为例>分析分治算法，以归并排序为例
<a class=anchor href=#%e5%88%86%e6%9e%90%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95%e4%bb%a5%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f%e4%b8%ba%e4%be%8b>#</a></h2><p>归并排序最坏运行时间的递归式：</p><p>$$
T(n)=
\begin{cases}
\Theta(1) & \text{if } n=1 \cr
2T(n/2) + \Theta(n) & \text{if } n>1
\end{cases}
$$</p><p>除使用主定理外，还可以这样理解递归式的值：将递归过程看做一个二叉树。递归调用中的每一层的总代价均为 $cn$，其中 $c$ 为常数。而二叉树的层数应为 $\log_2n+1$，故整个算法的代价期望为 $\Theta(n\log_2n)$。</p><h1 id=分治法>分治法
<a class=anchor href=#%e5%88%86%e6%b2%bb%e6%b3%95>#</a></h1><h2 id=分治法求最大和的子数组>分治法求最大和的子数组
<a class=anchor href=#%e5%88%86%e6%b2%bb%e6%b3%95%e6%b1%82%e6%9c%80%e5%a4%a7%e5%92%8c%e7%9a%84%e5%ad%90%e6%95%b0%e7%bb%84>#</a></h2><ol><li><p>分解。将数组划分为两个子数组。此时，只存在三种子数组：</p><ul><li>全部位于中点左侧的子数组</li><li>全部位于中点右侧的子数组</li><li>跨越中点的子数组</li></ul></li><li><p>解决。</p><ul><li>对于位于中点一侧的子数组，可以直接用递归解决。</li><li>对于跨越中点的子数组，将其分为左侧和右侧两部分。那么，左右两个数组都必定是所有以中点为两个边界之一的子数组的最大者。因此，从中点出发，向两侧扫描，并计算从中点到此元素的总和，找到最大。</li></ul></li><li><p>合并。找到以上三个数组中总和最大者，即为结果。</p></li></ol><h2 id=矩阵乘法的-strassen-算法>矩阵乘法的 Strassen 算法
<a class=anchor href=#%e7%9f%a9%e9%98%b5%e4%b9%98%e6%b3%95%e7%9a%84-strassen-%e7%ae%97%e6%b3%95>#</a></h2><h3 id=朴素的矩阵乘法>朴素的矩阵乘法
<a class=anchor href=#%e6%9c%b4%e7%b4%a0%e7%9a%84%e7%9f%a9%e9%98%b5%e4%b9%98%e6%b3%95>#</a></h3><p>按照定义进行的矩阵乘法:</p><p>$$
C_{ij} = \sum_{k=1}^{n} a_{ik} \cdot b_{kj}
$$</p><p>复杂度为 $\Theta(n^3)$，在此不做过多叙述。</p><h3 id=简单的分治算法>简单的分治算法
<a class=anchor href=#%e7%ae%80%e5%8d%95%e7%9a%84%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95>#</a></h3><p>对于 $n$ 阶矩阵乘法 $C = A\cdot B$，将三个矩阵都划分为四个部分，划分的四个部分仍遵守矩阵乘法法则。即：</p><p>$$
\newcommand{\bmx}{\begin{bmatrix}}
\newcommand{\emx}{\end{bmatrix}}
\bmx C_{11} & C_{12} \cr C_{21} & C_{22} \emx
= \bmx A_{11} & A_{12} \cr A_{21} & A_{22} \emx
\cdot \bmx B_{11} & B_{12} \cr B_{21} & B_{22} \emx
$$</p><p>对于 $C$ 矩阵中的第一部分，有：</p><p>$$
C_{11} = A_{11} \cdot B_{11} + A_{12} \cdot B_{21}
$$</p><p>其余三个等式略。</p><p>对这个算法进行代价分析。首先，由于利用下标进行原地分解，我们只需要常数时间完成分解过程。随后，对于矩阵 $C$ 的每一个部分，需要进行两次递归的矩阵乘法和一次代价为 $\Theta(n^2)$ 的矩阵加法。共需要进行 8 次矩阵乘法和 4 次矩阵加法。最后，当 “递归回升” 时，$n = 1$，只需要进行一次标量乘法。故整体代价为：</p><p>$$
T(n) = 8T(2/n) + \Theta(n^2)
$$</p><p>注意 $\Theta$ 符号常数项可以被省略，但递归不能，常数系数 $8$ 仍然保留。</p><p>应用主定理（Master Theorem）可知，$T(n) = \Theta(n^3)$。</p><h3 id=strassen-方法>Strassen 方法
<a class=anchor href=#strassen-%e6%96%b9%e6%b3%95>#</a></h3><p>Strassen 方法的具体流程比较复杂。算法的效果是，将每一次调用的 8 次矩阵乘法替换为 7 次矩阵乘法和常数次的矩阵加法（复杂度为 $\Theta(n^2)$）这也就意味着，递归树从每层 8 个分叉减少到了 7 个。随之，整个算法的复杂度降低到了 $\Theta(n^{\log_27}) \approx \Theta(n^{2.81})$。</p><ol><li>将矩阵分解为四个部分。代价为 $\Theta(1)$。</li><li>创建 10 个 $n/2$ 阶的矩阵，每个矩阵保存步骤 1 中创建的两个矩阵的和或差。代价为 $\Theta(n^2)$。</li><li>使用这 14 个矩阵，递归地计算 7 个矩阵积。即进行 7 次递归。</li><li>通过这些矩阵积计算出结果的 4 个子矩阵 $C_{11}, C_{12}, C_{21}, C_{22}$，代价为 $\Theta(n^2)$。</li></ol><p>具体过程在这里省略，也可以参照<a href=http://www.cnblogs.com/zhoutaotao/p/3963048.html>这篇文章</a>。</p><p>需要注意的是，这个算法实际上并不一定是代价更低的（二次常数因子较大）。而且，实际应用中遇到的矩阵大多是稀疏的，可以有更加实用的其他方法。因此，Strassen 方法在实际应用中并不多见。</p><h2 id=求解递归式>求解递归式
<a class=anchor href=#%e6%b1%82%e8%a7%a3%e9%80%92%e5%bd%92%e5%bc%8f>#</a></h2><h3 id=代入法--简单的数学归纳法>代入法 / 简单的数学归纳法
<a class=anchor href=#%e4%bb%a3%e5%85%a5%e6%b3%95--%e7%ae%80%e5%8d%95%e7%9a%84%e6%95%b0%e5%ad%a6%e5%bd%92%e7%ba%b3%e6%b3%95>#</a></h3><h3 id=递归树法>递归树法
<a class=anchor href=#%e9%80%92%e5%bd%92%e6%a0%91%e6%b3%95>#</a></h3><h3 id=主定理>主定理
<a class=anchor href=#%e4%b8%bb%e5%ae%9a%e7%90%86>#</a></h3><p>令 $a\geqslant 1$ 和 $b>1$ 是常数，$f(n)$ 是一个函数，$T(n)$ 是定义在非负整数上的递归式：</p><p>$$
T(n) = aT(n/b) + f(n)
$$</p><p>那么：</p><ol><li>若对某个常数 $\epsilon$，有 $f(n) = O(n^{\log_ba-\epsilon})$，即 $f(n)$ 的代价比前项小，那么 $T(n) = \Theta(n^{\log_ba})$。</li><li>若 $f(n) = O(n^{\log_ba})$，那么 $T(n) = \Theta(n^{\log_ba}\log_2n)$。</li><li>若对某个常数 $\epsilon$，有 $f(n) = \Omega(n^{\log_ba+\epsilon})$，即 $f(n)$ 的代价比前项大，那么 $T(n) = \Theta(f(n))$。</li></ol><p>简要地说，可以这样理解主定理：由递归带来的代价为 $\Theta(n^{\log_ba})$。</p><ul><li>如果式中的常量更大，则常量决定了代价增长的速度。</li><li>反之，就是递归决定了函数增长的速度。</li><li>若二者相等，则需要乘上一个系数 $\log_2n$。</li></ul><p>从递归树解法可以证明主定理。</p><h1 id=概率分析和随机算法>概率分析和随机算法
<a class=anchor href=#%e6%a6%82%e7%8e%87%e5%88%86%e6%9e%90%e5%92%8c%e9%9a%8f%e6%9c%ba%e7%ae%97%e6%b3%95>#</a></h1><ul><li><p>平均情况运行时间</p></li><li><p>随机算法：算法中使用随机数生成器，输出不仅取决于输入</p></li><li><p>指示器变量：对于事件 $A$，指示器随机变量 $\mathrm{I}(A) = \begin{cases} 1 & \text{if $A$ happens}\cr 0 & \text{if $A$ doesn&rsquo;t happen} \end{cases}$。如，抛硬币的随机指示器期望为 $\frac12$。</p></li></ul><h2 id=雇用问题>雇用问题
<a class=anchor href=#%e9%9b%87%e7%94%a8%e9%97%ae%e9%a2%98>#</a></h2><h3 id=问题描述>问题描述
<a class=anchor href=#%e9%97%ae%e9%a2%98%e6%8f%8f%e8%bf%b0>#</a></h3><p>你需要一名办公助理。为此，你雇佣了一名 HR，每天为你带来一位面试者。这个过程需要为 HR 支付一笔面试费（算法中的代价）。每当你遇见一位比现在的办公助理更好的助理，就换掉现在身边的，这个过程需要为 HR 支付更多的费用（切换时需要更高的代价）。估算这个过程的费用是多少。</p><p>该问题可以简化为：遍历一个序列，每当遇到比当前内存中的变量更高的值，就换成序列里的值。在两个变量之间做比较的代价较小，切换的代价较大。</p><p>显然，在最坏情况下，每一次面试都需要进行切换。这时，代价的期望为 $O(c_hn)$。其中，$c_h$ 是雇佣一个新的助理的代价。</p><h3 id=使用随机指示器分析雇用问题>使用随机指示器分析雇用问题
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e9%9a%8f%e6%9c%ba%e6%8c%87%e7%a4%ba%e5%99%a8%e5%88%86%e6%9e%90%e9%9b%87%e7%94%a8%e9%97%ae%e9%a2%98>#</a></h3><p>显然，决定面试者是否被雇佣的随机指示器的期望 $\mathrm{E}[X_i] = 1/i$。这意味着每个面试者有 $1/i$ 的概率比之前的所有人都好，因此被雇佣。那么总的雇佣人数的期望为：</p><p>$$
\mathrm{E}[X] = \mathrm{E} \sum_{i=1}^n X_i = \sum_{i=1}^n \frac 1 i = \ln n + O(1)
$$</p><p>因此，在面试者随机出现的情况下，代价的期望为 $O(c_h\ln n)$。为了逼近这个值，可以在算法开始之前先进行随机化。</p><h2 id=随机算法>随机算法
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e7%ae%97%e6%b3%95>#</a></h2><h3 id=随机排列数组>随机排列数组
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e6%8e%92%e5%88%97%e6%95%b0%e7%bb%84>#</a></h3><p>Permute-by-sorting. 具体做法是：对于输入序列，生成一个相同长度的随机数的数组。为了让数组的内容足够唯一，让随机数取值在 $(1, n^3)$ 范围内。然后，在排序这个数组的同时，排序序列。这个做法的代价与比较排序的代价相等，为 $\Theta(n\log_2n)$。</p><h3 id=原地随机化>原地随机化
<a class=anchor href=#%e5%8e%9f%e5%9c%b0%e9%9a%8f%e6%9c%ba%e5%8c%96>#</a></h3><p>从 1 到 n，将当前元素与序列后方的任意一个元素交换。</p><h2 id=其他随机相关问题>其他随机相关问题
<a class=anchor href=#%e5%85%b6%e4%bb%96%e9%9a%8f%e6%9c%ba%e7%9b%b8%e5%85%b3%e9%97%ae%e9%a2%98>#</a></h2><h3 id=球与箱子问题>球与箱子问题
<a class=anchor href=#%e7%90%83%e4%b8%8e%e7%ae%b1%e5%ad%90%e9%97%ae%e9%a2%98>#</a></h3><p>向 $b$ 个箱子中投球，落入每个箱子的概率均为 $1/b$。这个问题对于散列算法十分有用。我们称落入一个新的箱子中为一次命中。我们以已经有球的箱子的数量划分阶段。如，第 1 阶段表示尚未投球，第 2 阶段表示已投入一个。那么，对于已经有 $i-1$ 个命中的情况，即第 $i$ 阶段，得到一次命中的概率为 $(b-i+1)/b$。该阶段需要投球次数的期望为：</p><p>$$
\mathrm{E}[n_i] = \frac b {b-i+1}
$$</p><p>整个过程共需要投球次数的期望为：</p><p>$$
\mathrm{E} [n]
= \mathrm{E} [\sum_{i=1}^b \frac b {b-i+1}]
= \mathrm{E} [\sum_{i=1}^b \frac 1 i]
= b(\ln b+O(1))
$$</p><p>所以，我们大约要投 $b\ln b$ 次才能保证所有箱子里都有球。这个问题也被称为礼券收集者问题。</p><h3 id=特征序列>特征序列
<a class=anchor href=#%e7%89%b9%e5%be%81%e5%ba%8f%e5%88%97>#</a></h3><p>抛一枚硬币 $n$ 次，最长的连续正面的序列有多长？这个值的期望为 $\Theta(\log_2n)$。可以从上界和下界两个方向来证明。</p><ul><li>布尔不等式：一组事件并集的概率不大于这些事件概率的和，无论这些事件是否独立。</li></ul><h3 id=在线雇用问题>在线雇用问题
<a class=anchor href=#%e5%9c%a8%e7%ba%bf%e9%9b%87%e7%94%a8%e9%97%ae%e9%a2%98>#</a></h3><p>雇用问题的一个变形：面试一批面试者，并最终雇用其中的一个。但是，对于每一个面试者，需要立刻决定是否雇用。在这个问题中，我们需要在面试者的质量和面试次数之间取得平衡。</p><p>一个有用的策略是：先淘汰 $k$ 名面试者，找到他们当中最好的一个。随后，在接下来的面试中，一旦遇到比前 $k$ 个都好的，就立刻雇用。</p><p>我们首先来尝试计算得到最好面试者的概率。设最好面试者在第 $i$ 个且被我们取到的事件为 $S_i$，考虑到前 $k$ 个面试者直接被我们排除掉，其中，当 $i\leqslant k$ 时，不可能取到最佳面试者。于是，取得最好面试者的概率密度函数为：</p><p>$$
\Pr\{S\} = \sum_{i=1}^n \Pr\{S_i\} = \sum_{i=k+1}^n \Pr\{S\}
$$</p><p>接下来求 $\Pr\{S_i\}$。当 $S_i$ 发生时，第一，应聘者应该在第 $i$ 个位置。第二，$k$ 到 $i-1$ 范围内的所有值全部小于前 $k$ 个中的最大者。这两个事件是独立的。对于第二个事件，将其转化为：从 $1$ 到 $i-1$ 范围内的最大值出现在前 $k$ 个中。这个概率为 $k/(i-1)$，故</p><p>$$
\Pr\{S\}
= \sum_{i=k+1}^n \frac k {n(i-1)}
= \frac k n \sum_{i=k}^{n-1} \frac 1 i
$$</p><p>又，利用积分来近似约束这个和数，有：</p><p>$$
\int_k^n \frac 1 x \mathrm d x
\leqslant \sum_{i=k}^{n-1} \frac 1 i
\leqslant \int_{k-1}^{i-1} \frac 1 x \mathrm d x
$$</p><p>求解可以得到下面的上下界：</p><p>$$
\frac k n (\ln n - \ln k)
\leqslant \Pr\{S\}
\leqslant \frac k n (\ln(n-1) - \ln(k-1))
$$</p><p>以 $k$ 为未知数求导。当 $k = \frac ne$ 时，下界取得最大值。</p><p>因此，以此决定我们的 $k$ 取值，那么将以至少 $\frac 1e$ 的概率雇用到最好的面试者。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#代价分析和复杂度>代价分析和复杂度</a><ul><li><a href=#示例与概念>示例与概念</a></li><li><a href=#函数增长的渐进记号>函数增长的渐进记号</a></li><li><a href=#分析分治算法以归并排序为例>分析分治算法，以归并排序为例</a></li></ul></li><li><a href=#分治法>分治法</a><ul><li><a href=#分治法求最大和的子数组>分治法求最大和的子数组</a></li><li><a href=#矩阵乘法的-strassen-算法>矩阵乘法的 Strassen 算法</a><ul><li><a href=#朴素的矩阵乘法>朴素的矩阵乘法</a></li><li><a href=#简单的分治算法>简单的分治算法</a></li><li><a href=#strassen-方法>Strassen 方法</a></li></ul></li><li><a href=#求解递归式>求解递归式</a><ul><li><a href=#代入法--简单的数学归纳法>代入法 / 简单的数学归纳法</a></li><li><a href=#递归树法>递归树法</a></li><li><a href=#主定理>主定理</a></li></ul></li></ul></li><li><a href=#概率分析和随机算法>概率分析和随机算法</a><ul><li><a href=#雇用问题>雇用问题</a><ul><li><a href=#问题描述>问题描述</a></li><li><a href=#使用随机指示器分析雇用问题>使用随机指示器分析雇用问题</a></li></ul></li><li><a href=#随机算法>随机算法</a><ul><li><a href=#随机排列数组>随机排列数组</a></li><li><a href=#原地随机化>原地随机化</a></li></ul></li><li><a href=#其他随机相关问题>其他随机相关问题</a><ul><li><a href=#球与箱子问题>球与箱子问题</a></li><li><a href=#特征序列>特征序列</a></li><li><a href=#在线雇用问题>在线雇用问题</a></li></ul></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script><script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>