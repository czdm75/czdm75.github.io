<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Trie 树（前缀树） # 前缀树的结构是这样的：每个结点的一个分支代表一位数据。这里的一位不一定是一个 bit，也可以是一个字符等，因为前缀树经常被用在字符串处理，如输入时的提示。在这里，节点内部并不需要保存 key，因为其所有位都已经表示在了路径上。
如果每一个分支不只保存一个位，将唯一子树与其父节点合并，就变成了基数树。基数树需要保存的路径信息变多了，但不再使用无用的结点。
Huffman 编码 # Huffman 编码就是一种使用前缀的编码方法，其核心是前缀树的构建。Huffman 编码采用这样的基于概率的前缀构建：将所有可能的值作为叶子，并不断合并频率和最小的两个节点，最终构成一颗二叉前缀树。
树构建完成之后，在每一个节点，以左侧为 0，右侧为 1，构建前缀编码。Huffman 编码是最优的前缀编码。类似地，自顶向下构建前缀树，在每一步尽量使两侧概率相等的编码方式称为 Shannon-Fano 编码，这种方法不一定总能得到最优编码。
数据结构的扩展 # 在这里，数据结构的扩展指的是在原有数据结构上做出一些修改，使得其能够支持更多的特性。这些修改包括设计新的操作，以及增加可能的域。
动态顺序统计 # 为了获得一个集合里每个元素的次序，在红黑树结点的基础上增加一个域 size，用于保存以这个节点为根的子树的总结点数。即顺序统计量。定义中序遍历的顺序为这个元素的秩。
给定秩，寻找相应的元素。从根出发，左子树的 size+1 就是这个节点所在的位置。判断和输入的大小关系，选择子树继续寻找。
给定元素寻找秩的过程与之相反。从这个节点回溯到根，将所有的左子树 size+1 加起来，就是这个结点的秩。两种查找的复杂度均为 $O(\log_2n)$。
为了维护 size 域的值，在每一次插入和删除时，都需要回溯至根来修改，复杂度为 $O(\log_2n)$。此外，当发生旋转时，也要分别修改 size。修改的复杂度为 $O(1)$，所以插入和删除的复杂度不变，仍为 $O(\log_2n)$。
区间树 # 接下来，我们以红黑树为基础，构建一个可以保存区间对象的数据结构，以展示如何进行数据结构的扩展。
基础数据结构：每个节点包含一个区间信息，并以区间的低端点作为其关键字。
附加信息：每个节点额外维护一个值 max，它是以这个节点为根的子树中的所有区间端点的最大值。
对信息的维护：每个结点的 max 为 max(x.int.high, x.left.max, x.right.max)。于是，更新这个属性的复杂度为 $O(\log_2n)$。实际上，操作的复杂度只有 $O(1)$。
设计新的操作：查找与指定区间相交的区间。在查找时，如果左子结点的 max 大于查找目标的左端点，说明左子树中有重叠的部分，则进入左子树继续查找。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/notes/intro-algo/5/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="5. Trie-Tree, Extending Data Structures"><meta property="og:description" content="Trie 树（前缀树） # 前缀树的结构是这样的：每个结点的一个分支代表一位数据。这里的一位不一定是一个 bit，也可以是一个字符等，因为前缀树经常被用在字符串处理，如输入时的提示。在这里，节点内部并不需要保存 key，因为其所有位都已经表示在了路径上。
如果每一个分支不只保存一个位，将唯一子树与其父节点合并，就变成了基数树。基数树需要保存的路径信息变多了，但不再使用无用的结点。
Huffman 编码 # Huffman 编码就是一种使用前缀的编码方法，其核心是前缀树的构建。Huffman 编码采用这样的基于概率的前缀构建：将所有可能的值作为叶子，并不断合并频率和最小的两个节点，最终构成一颗二叉前缀树。
树构建完成之后，在每一个节点，以左侧为 0，右侧为 1，构建前缀编码。Huffman 编码是最优的前缀编码。类似地，自顶向下构建前缀树，在每一步尽量使两侧概率相等的编码方式称为 Shannon-Fano 编码，这种方法不一定总能得到最优编码。
数据结构的扩展 # 在这里，数据结构的扩展指的是在原有数据结构上做出一些修改，使得其能够支持更多的特性。这些修改包括设计新的操作，以及增加可能的域。
动态顺序统计 # 为了获得一个集合里每个元素的次序，在红黑树结点的基础上增加一个域 size，用于保存以这个节点为根的子树的总结点数。即顺序统计量。定义中序遍历的顺序为这个元素的秩。
给定秩，寻找相应的元素。从根出发，左子树的 size+1 就是这个节点所在的位置。判断和输入的大小关系，选择子树继续寻找。
给定元素寻找秩的过程与之相反。从这个节点回溯到根，将所有的左子树 size+1 加起来，就是这个结点的秩。两种查找的复杂度均为 $O(\log_2n)$。
为了维护 size 域的值，在每一次插入和删除时，都需要回溯至根来修改，复杂度为 $O(\log_2n)$。此外，当发生旋转时，也要分别修改 size。修改的复杂度为 $O(1)$，所以插入和删除的复杂度不变，仍为 $O(\log_2n)$。
区间树 # 接下来，我们以红黑树为基础，构建一个可以保存区间对象的数据结构，以展示如何进行数据结构的扩展。
基础数据结构：每个节点包含一个区间信息，并以区间的低端点作为其关键字。
附加信息：每个节点额外维护一个值 max，它是以这个节点为根的子树中的所有区间端点的最大值。
对信息的维护：每个结点的 max 为 max(x.int.high, x.left.max, x.right.max)。于是，更新这个属性的复杂度为 $O(\log_2n)$。实际上，操作的复杂度只有 $O(1)$。
设计新的操作：查找与指定区间相交的区间。在查找时，如果左子结点的 max 大于查找目标的左端点，说明左子树中有重叠的部分，则进入左子树继续查找。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><title>5. Trie-Tree, Extending Data Structures | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle checked>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/ class=active>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>5. Trie-Tree, Extending Data Structures</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#trie-树前缀树>Trie 树（前缀树）</a></li><li><a href=#huffman-编码>Huffman 编码</a></li><li><a href=#数据结构的扩展>数据结构的扩展</a><ul><li><a href=#动态顺序统计>动态顺序统计</a></li><li><a href=#区间树>区间树</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=trie-树前缀树>Trie 树（前缀树）
<a class=anchor href=#trie-%e6%a0%91%e5%89%8d%e7%bc%80%e6%a0%91>#</a></h1><p>前缀树的结构是这样的：每个结点的一个分支代表一位数据。这里的一位不一定是一个 bit，也可以是一个字符等，因为前缀树经常被用在字符串处理，如输入时的提示。在这里，节点内部并不需要保存 key，因为其所有位都已经表示在了路径上。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/b/be/Trie_example.svg/250px-Trie_example.svg.png alt="Trie 树"></p><p>如果每一个分支不只保存一个位，将唯一子树与其父节点合并，就变成了基数树。基数树需要保存的路径信息变多了，但不再使用无用的结点。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/a/ae/Patricia_trie.svg/400px-Patricia_trie.svg.png alt=基数树></p><h1 id=huffman-编码>Huffman 编码
<a class=anchor href=#huffman-%e7%bc%96%e7%a0%81>#</a></h1><p>Huffman 编码就是一种使用前缀的编码方法，其核心是前缀树的构建。Huffman 编码采用这样的基于概率的前缀构建：将所有可能的值作为叶子，并不断合并频率和最小的两个节点，最终构成一颗二叉前缀树。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/c/c8/Huffman_algorithm.gif alt="Huffman 编码动图"></p><p>树构建完成之后，在每一个节点，以左侧为 0，右侧为 1，构建前缀编码。Huffman 编码是最优的前缀编码。类似地，自顶向下构建前缀树，在每一步尽量使两侧概率相等的编码方式称为 Shannon-Fano 编码，这种方法不一定总能得到最优编码。</p><h1 id=数据结构的扩展>数据结构的扩展
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%9a%84%e6%89%a9%e5%b1%95>#</a></h1><p>在这里，数据结构的扩展指的是在原有数据结构上做出一些修改，使得其能够支持更多的特性。这些修改包括设计新的操作，以及增加可能的域。</p><h2 id=动态顺序统计>动态顺序统计
<a class=anchor href=#%e5%8a%a8%e6%80%81%e9%a1%ba%e5%ba%8f%e7%bb%9f%e8%ae%a1>#</a></h2><p>为了获得一个集合里每个元素的次序，在红黑树结点的基础上增加一个域 <code>size</code>，用于保存以这个节点为根的子树的总结点数。即顺序统计量。定义中序遍历的顺序为这个元素的秩。</p><p>给定秩，寻找相应的元素。从根出发，左子树的 <code>size+1</code> 就是这个节点所在的位置。判断和输入的大小关系，选择子树继续寻找。</p><p>给定元素寻找秩的过程与之相反。从这个节点回溯到根，将所有的左子树 <code>size+1</code> 加起来，就是这个结点的秩。两种查找的复杂度均为 $O(\log_2n)$。</p><p>为了维护 <code>size</code> 域的值，在每一次插入和删除时，都需要回溯至根来修改，复杂度为 $O(\log_2n)$。此外，当发生旋转时，也要分别修改 <code>size</code>。修改的复杂度为 $O(1)$，所以插入和删除的复杂度不变，仍为 $O(\log_2n)$。</p><h2 id=区间树>区间树
<a class=anchor href=#%e5%8c%ba%e9%97%b4%e6%a0%91>#</a></h2><p>接下来，我们以红黑树为基础，构建一个可以保存区间对象的数据结构，以展示如何进行数据结构的扩展。</p><ol><li><p>基础数据结构：每个节点包含一个区间信息，并以区间的低端点作为其关键字。</p></li><li><p>附加信息：每个节点额外维护一个值 <code>max</code>，它是以这个节点为根的子树中的所有区间端点的最大值。</p></li><li><p>对信息的维护：每个结点的 <code>max</code> 为 <code>max(x.int.high, x.left.max, x.right.max)</code>。于是，更新这个属性的复杂度为 $O(\log_2n)$。实际上，操作的复杂度只有 $O(1)$。</p></li><li><p>设计新的操作：查找与指定区间相交的区间。在查找时，如果左子结点的 <code>max</code> 大于查找目标的左端点，说明左子树中有重叠的部分，则进入左子树继续查找。</p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#trie-树前缀树>Trie 树（前缀树）</a></li><li><a href=#huffman-编码>Huffman 编码</a></li><li><a href=#数据结构的扩展>数据结构的扩展</a><ul><li><a href=#动态顺序统计>动态顺序统计</a></li><li><a href=#区间树>区间树</a></li></ul></li></ul></nav></div></aside></main><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js></script><script src=https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js></script><script>renderMathInElement(document.querySelector("article.markdown"),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})</script></body></html>