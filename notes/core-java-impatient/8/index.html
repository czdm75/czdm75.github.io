<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="线程和进程 # 线程 # 如果要等待另一个线程完成，使用 join 方法。可以为这个方法加入超时时间。
thread.join(millis); 当 run 方法返回或者抛出异常时，线程结束。每个线程都有自己的异常处理器，默认继承自线程组，通常就是我们熟悉的全局错误处理器。（err 流）可以使用 setUncaughtExceptionHandler 来改变这个处理器。
有时，我们让几个线程执行类似的任务，而最终只需要一个结果，其他的线程都可以被取消。可以在 Runnable 中检查是否中断：
Runnable task = () -> { while (check == true) { if (Thread.currentThread().isInterrupted()) return; ...; } } 实际上，中断（Interrupt）并没有一个非常准确的定义，更多的是程序员自己用来处理一些问题。
如果线程在 wait 等待状态或者 sleep 休眠状态被中断，就会直接抛出 InterruptedException。对于这种情况，可以直接在 Runnable 中使用 try-catch 块进行处理。
Runnable task = () -> { try { ...; } catch (InterruptedException ex) { Thread.currentThread().interrupt(); } } 如果线程在运行中被中断，那么一旦 sleep 被调用，就会立刻抛出异常。很多情况下我们并没有什么可做的，可以考虑直接把线程设置一下中断状态，或者继续将其抛出给真正能够处理的位置。
线程变量和其他属性 # 很多时候我们并不真的需要在线程之间共享变量。Java 提供了 ThreadLocal 类来解决这个问题。这样，每个线程都将得到独立的变量。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/notes/core-java-impatient/8/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="8. Threading"><meta property="og:description" content="线程和进程 # 线程 # 如果要等待另一个线程完成，使用 join 方法。可以为这个方法加入超时时间。
thread.join(millis); 当 run 方法返回或者抛出异常时，线程结束。每个线程都有自己的异常处理器，默认继承自线程组，通常就是我们熟悉的全局错误处理器。（err 流）可以使用 setUncaughtExceptionHandler 来改变这个处理器。
有时，我们让几个线程执行类似的任务，而最终只需要一个结果，其他的线程都可以被取消。可以在 Runnable 中检查是否中断：
Runnable task = () -> { while (check == true) { if (Thread.currentThread().isInterrupted()) return; ...; } } 实际上，中断（Interrupt）并没有一个非常准确的定义，更多的是程序员自己用来处理一些问题。
如果线程在 wait 等待状态或者 sleep 休眠状态被中断，就会直接抛出 InterruptedException。对于这种情况，可以直接在 Runnable 中使用 try-catch 块进行处理。
Runnable task = () -> { try { ...; } catch (InterruptedException ex) { Thread.currentThread().interrupt(); } } 如果线程在运行中被中断，那么一旦 sleep 被调用，就会立刻抛出异常。很多情况下我们并没有什么可做的，可以考虑直接把线程设置一下中断状态，或者继续将其抛出给真正能够处理的位置。
线程变量和其他属性 # 很多时候我们并不真的需要在线程之间共享变量。Java 提供了 ThreadLocal 类来解决这个问题。这样，每个线程都将得到独立的变量。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><title>8. Threading | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle checked>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/ class=active>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>8. Threading</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#线程和进程>线程和进程</a><ul><li><a href=#线程>线程</a></li><li><a href=#线程变量和其他属性>线程变量和其他属性</a></li><li><a href=#进程>进程</a></li><li><a href=#异步>异步</a></li></ul></li><li><a href=#线程池>线程池</a><ul><li><a href=#executor>Executor</a></li><li><a href=#executorservice>ExecutorService</a></li><li><a href=#多个任务的情形>多个任务的情形</a></li></ul></li><li><a href=#线程安全>线程安全</a><ul><li><a href=#保证更新可见的几种情况>保证更新可见的几种情况</a></li><li><a href=#竞争条件>竞争条件</a></li><li><a href=#使用并行算法>使用并行算法</a></li><li><a href=#使用线程安全的数据结构>使用线程安全的数据结构</a><ul><li><a href=#concurrenthashmap>ConcurrentHashMap</a></li><li><a href=#阻塞队列-blocking-queues>阻塞队列 Blocking Queues</a></li><li><a href=#其他数据结构>其他数据结构</a></li><li><a href=#原子值>原子值</a></li></ul></li></ul></li><li><a href=#锁>锁</a><ul><li><a href=#可重入锁-reentrantlock>可重入锁 ReentrantLock</a></li><li><a href=#synchronized-关键字>synchronized 关键字</a></li><li><a href=#条件等待>条件等待</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=线程和进程>线程和进程
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b>#</a></h1><h2 id=线程>线程
<a class=anchor href=#%e7%ba%bf%e7%a8%8b>#</a></h2><p>如果要等待另一个线程完成，使用 <code>join</code> 方法。可以为这个方法加入超时时间。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>thread.<span style=color:#7d9029>join</span>(millis);<span style=color:#bbb>
</span></span></span></code></pre></div><p>当 <code>run</code> 方法返回或者抛出异常时，线程结束。每个线程都有自己的异常处理器，默认继承自线程组，通常就是我们熟悉的全局错误处理器。（err 流）可以使用 <code>setUncaughtExceptionHandler</code> 来改变这个处理器。</p><p>有时，我们让几个线程执行类似的任务，而最终只需要一个结果，其他的线程都可以被取消。可以在 <code>Runnable</code> 中检查是否中断：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Runnable<span style=color:#bbb> </span>task<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>while</span><span style=color:#bbb> </span>(check<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>true</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(Thread.<span style=color:#7d9029>currentThread</span>().<span style=color:#7d9029>isInterrupted</span>())<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>实际上，中断（Interrupt）并没有一个非常准确的定义，更多的是程序员自己用来处理一些问题。</p><p>如果线程在 wait 等待状态或者 sleep 休眠状态被中断，就会直接抛出 <code>InterruptedException</code>。对于这种情况，可以直接在 <code>Runnable</code> 中使用 try-catch 块进行处理。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Runnable<span style=color:#bbb> </span>task<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>try</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb> </span><span style=color:green;font-weight:700>catch</span><span style=color:#bbb> </span>(InterruptedException<span style=color:#bbb> </span>ex)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>Thread.<span style=color:#7d9029>currentThread</span>().<span style=color:#7d9029>interrupt</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果线程在运行中被中断，那么一旦 <code>sleep</code> 被调用，就会立刻抛出异常。很多情况下我们并没有什么可做的，可以考虑直接把线程设置一下中断状态，或者继续将其抛出给真正能够处理的位置。</p><h2 id=线程变量和其他属性>线程变量和其他属性
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e5%8f%98%e9%87%8f%e5%92%8c%e5%85%b6%e4%bb%96%e5%b1%9e%e6%80%a7>#</a></h2><p>很多时候我们并不真的需要在线程之间共享变量。Java 提供了 <code>ThreadLocal</code> 类来解决这个问题。这样，每个线程都将得到独立的变量。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>final</span><span style=color:#bbb> </span>NumberFormat<span style=color:#bbb> </span>format<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>NumberFormat.<span style=color:#7d9029>getCurrencyInstance</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>String<span style=color:#bbb> </span>amount<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>format.<span style=color:#7d9029>format</span>(total);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// may cause race condition, but no need of synchronize</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>final</span><span style=color:#bbb> </span>ThreadLocal<span style=color:#666>&lt;</span>NumberFormat<span style=color:#666>&gt;</span><span style=color:#bbb> </span>format<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>ThreadLocal.<span style=color:#7d9029>withInicial</span>(()<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>NumberFormat.<span style=color:#7d9029>getCurrencyInstance</span>());<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>String<span style=color:#bbb> </span>amount<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>format.<span style=color:#7d9029>get</span>().<span style=color:#7d9029>format</span>(total);<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Thread</code> 类还有一些不常用的其他属性。线程可以分组，但在有了线程池之后，这种方法就不再常用。线程的优先级和虚拟机的实现有关，因此意义不大。线程有状态，但在 Java 中很少用到，对系统开发可能更有用。对于未捕获的异常，可以为每个线程设置不同的<em>异常处理器</em>。</p><p>此外还有 <code>thread.setDaemon(true)</code> 方法。当虚拟机中只剩下 daemon 线程时，虚拟机会退出。因此我们就不再需要手动处理这个问题。</p><h2 id=进程>进程
<a class=anchor href=#%e8%bf%9b%e7%a8%8b>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ProcessBuilder<span style=color:#bbb> </span>builder<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ProcessBuilder(<span style=color:#ba2121>&#34;gcc&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;myapp.c&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>builder<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>builder.<span style=color:#7d9029>directory</span>(path.<span style=color:#7d9029>toFile</span>());<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// returns itself, so:</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Process<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ProcessBuilder(<span style=color:#ba2121>&#34;gcc&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;myapp.c&#34;</span>).<span style=color:#7d9029>redirectInout</span>(inputFile)<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>.<span style=color:#7d9029>directory</span>(path.<span style=color:#7d9029>toFile</span>()).<span style=color:#7d9029>start</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>OutputStream<span style=color:#bbb> </span>processIn<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>getOutputStream</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// input of process</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>InputStream<span style=color:#bbb> </span>processOut<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>getInputStream</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>InputStream<span style=color:#bbb> </span>processErr<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>getErrorStream</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>builder.<span style=color:#7d9029>redirectErrotStream</span>(<span style=color:green;font-weight:700>true</span>);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// combine err and out stream</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Map<span style=color:#666>&lt;</span>String,<span style=color:#bbb> </span>String<span style=color:#666>&gt;</span><span style=color:#bbb> </span>env<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>builder.<span style=color:#7d9029>environment</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>env.<span style=color:#7d9029>put</span>(<span style=color:#ba2121>&#34;LANG&#34;</span>,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;zh_CN&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>env.<span style=color:#7d9029>remove</span>(<span style=color:#ba2121>&#34;JAVA_HOME&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// wait for process to end</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#bbb> </span>result<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>waitfor</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// or with timeout</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(p.<span style=color:#7d9029>waitfor</span>(delay,<span style=color:#bbb> </span>TimeUnit.<span style=color:#7d9029>SECONDS</span>))<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>result<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>exitValue</span>()<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb> </span><span style=color:green;font-weight:700>else</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>p.<span style=color:#7d9029>destroy</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// SIGTERN</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#408080;font-style:italic>// or</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>p.<span style=color:#7d9029>destroyForcibly</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// SIGKILL</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=异步>异步
<a class=anchor href=#%e5%bc%82%e6%ad%a5>#</a></h2><p>这种问题最常见于 GUI 程序：UI 线程不应该被任务阻塞，因此需要把任务方法其他的线程里。而且，UI 框架（例如 JavaFX 和 Android）通常不是线程安全的，因此只有 UI 线程本身应当修改屏幕上的组件。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>CompletableFuture<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span><span style=color:#bbb> </span>contents<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>readPage(url);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>CompletableFuture<span style=color:#666>&lt;</span>List<span style=color:#666>&lt;</span>URL<span style=color:#666>&gt;&gt;</span><span style=color:#bbb> </span>links<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>contens.<span style=color:#7d9029>thenApply</span>(Parser::getLinks);<span style=color:#bbb>
</span></span></span></code></pre></div><p>这样，代码的每一句都不会被阻塞，所有数据都被包装在 Future 中。只有上一步结束之后，下一步才会被执行。</p><p>类似 <code>thenApply</code> 这样的方法通常都有两个变种，其中带有 <code>Async</code> 的会在另一个线程中执行。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span><span style=color:#bbb> </span>future.<span style=color:#7d9029>thenApply</span>(Function<span style=color:#666>&lt;?</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>super</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>U<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span><span style=color:#bbb> </span>future.<span style=color:#7d9029>thenApplyAsync</span>(Function<span style=color:#666>&lt;?</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>super</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>U<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>void</span><span style=color:#bbb> </span>future.<span style=color:#7d9029>thenAccept</span>(Consumer<span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>thenRun</span>(Runnable);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span><span style=color:#bbb> </span>future.<span style=color:#7d9029>thenCompose</span>(Function<span style=color:#666>&lt;?</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>super</span><span style=color:#bbb> </span>T,<span style=color:#bbb> </span>CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>然后我们要考虑抛出异常的情况。当 <code>CompletableFuture</code> 里抛出异常时，异常会被包装在一个 Unchecked 的 <code>ExecutionException</code> 里，在 <code>get</code> 方法被调用时抛出。很多时候我们并不一定调用 <code>get</code>，这时使用 <code>handle</code> 方法，这些方法同样也有 Async 变种：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// handle exception, returns null if no exception</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>future.<span style=color:#7d9029>handle</span>(BiFunction<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>Throwable,<span style=color:#bbb> </span>U<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>future.<span style=color:#7d9029>whenComplete</span>(BiConsumer<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>Throwable<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>此外，还有一些用来对多个 <code>CompletableFuture</code> 的结果进行处理的方法。技术上说，它们的参数实际上是 <code>CompletionStage</code> 接口类型，但 Java 类库中只有 <code>CompletableFuture</code> 实现了这个接口。第三方框架可能会有其他实现在这里也省去了必须的 <code>super</code> 和 <code>extends</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>thenCombine(CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span>,<span style=color:#bbb> </span>BiFunction<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>U,<span style=color:#bbb> </span>V<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>thenAcceptBoth(CompletableFuture<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span>,<span style=color:#bbb> </span>BiConsumer<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>U<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>runAfterBoth(CompletableFuture<span style=color:#666>&lt;?&gt;</span>,<span style=color:#bbb> </span>Runnable);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// apply when one of them complete</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>applyToEither(CompletableFuture<span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span>,<span style=color:#bbb> </span>Function<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>V<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>AcceptEither(CompletableFuture<span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span>,<span style=color:#bbb> </span>Function<span style=color:#666>&lt;</span>T,<span style=color:#bbb> </span>V<span style=color:#666>&gt;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>runAfterEither(CompletableFuture<span style=color:#666>&lt;?&gt;</span>,<span style=color:#bbb> </span>Runnable);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// returns void after condition</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#00f>allOf</span>(CompletableFuture<span style=color:#666>&lt;?&gt;</span>...);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span><span style=color:#00f>anyOf</span>(CompletableFuture<span style=color:#666>&lt;?&gt;</span>...);<span style=color:#bbb>
</span></span></span></code></pre></div><h1 id=线程池>线程池
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e6%b1%a0>#</a></h1><h2 id=executor>Executor
<a class=anchor href=#executor>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Runnable<span style=color:#bbb> </span>task<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>{};<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Executor<span style=color:#bbb> </span>exec<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>exec.<span style=color:#7d9029>execute</span>(task);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// get executors from factory</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Executors.<span style=color:#7d9029>newCachedThreadPool</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Executors.<span style=color:#7d9029>newFixedThreadPool</span>(nthreads);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// get CPU core for fixed pool</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#bbb> </span>processors<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Runtime.<span style=color:#7d9029>getRuntime</span>().<span style=color:#7d9029>availableProcessors</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里，CachedThreadPool 适合大量小任务，或者等待（阻塞）时间较长的任务，如网络相关的。如果加入新任务时有空闲的线程，就会直接利用空闲线程。如果线程空闲超过一分钟，就会被移除。</p><p>FixedThreadPool 硬性限制了线程的最大数量，适合计算密集型的任务，有利于将一个任务长期绑定在一个 CPU 核心上，避免上下文切换开销。</p><h2 id=executorservice>ExecutorService
<a class=anchor href=#executorservice>#</a></h2><p>对于可能抛出异常和需要返回值的任务，需要使用 <code>Callable</code> 和 <code>ExecutorService</code> 实例。<code>ExecutorService</code> 是 <code>Executor</code> 的子接口。同样使用两种 ThreadPool，调用的方式有所不同：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Callable<span style=color:#666>&lt;</span>V<span style=color:#666>&gt;</span><span style=color:#bbb> </span>task<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Future<span style=color:#666>&lt;</span>V<span style=color:#666>&gt;</span><span style=color:#bbb> </span>result<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>exec.<span style=color:#7d9029>submit</span>(task);<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>Future&lt;V></code> 接口表示未来可能用到的的结果，包含这些方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>V<span style=color:#bbb> </span><span style=color:#00f>get</span>()<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>InterruptedException,<span style=color:#bbb> </span>ExecutionException;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>V<span style=color:#bbb> </span><span style=color:#00f>get</span>(<span style=color:#b00040>long</span><span style=color:#bbb> </span>timeout,<span style=color:#bbb> </span>TimeUnit<span style=color:#bbb> </span>unit)<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>InterruptedException,<span style=color:#bbb> </span>ExecutionException,<span style=color:#bbb> </span>TimeoutException;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span><span style=color:#00f>cancel</span>(<span style=color:#b00040>boolean</span><span style=color:#bbb> </span>mayInterruptIfRunning);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span><span style=color:#00f>isCanceled</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span><span style=color:#00f>isDone</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>get</code> 方法可以阻塞，或者使用超时时间，然后返回计算值。如果抛出了异常，这个异常将被包装，并作为 <code>ExecutorException</code> 被抛出。</p><p>如果在任务尚未开始时取消任务，那么任务会直接被删除。否则，只有在 <code>MayInterruptIfRunning</code> 为真时，才能中断线程，这是为了安全考虑。</p><p>如果要让任务可中断，除了标记之外，还要在任务内部循环检查是否被中断，以便正确处理。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Callable<span style=color:#666>&lt;</span>V<span style=color:#666>&gt;</span><span style=color:#bbb> </span>task<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>()<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>while</span><span style=color:#bbb> </span>(...)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(Thread.<span style=color:#7d9029>currentThread</span>().<span style=color:#7d9029>isInterrupted</span>())<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>// actrual work</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>result;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=多个任务的情形>多个任务的情形
<a class=anchor href=#%e5%a4%9a%e4%b8%aa%e4%bb%bb%e5%8a%a1%e7%9a%84%e6%83%85%e5%bd%a2>#</a></h2><p>如果有一批任务需要分别处理，可以把 <code>Callable</code> 集合传进 <code>exec</code>：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#666>&lt;</span>Callable<span style=color:#666>&lt;</span>Long<span style=color:#666>&gt;&gt;</span><span style=color:#bbb> </span>tasks<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>List<span style=color:#666>&lt;</span>Future<span style=color:#666>&lt;</span>Long<span style=color:#666>&gt;&gt;</span><span style=color:#bbb> </span>results<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>executor.<span style=color:#7d9029>invokeAll</span>(tasks);<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>invokeAll</code> 还有一个支持超时的变种。不过，这种方式下，直到所有任务都完成，主调任务都会阻塞。</p><p>一种解决方法是使用 <code>ExecutorCompletionService</code>：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ExecutorCompletionService<span style=color:#bbb> </span>service<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ExecutorCompletionService(executor);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(Callable<span style=color:#666>&lt;</span>V<span style=color:#666>&gt;</span><span style=color:#bbb> </span>c<span style=color:#bbb> </span>:<span style=color:#bbb> </span>tasks)<span style=color:#bbb> </span>service.<span style=color:#7d9029>submit</span>(task);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>0;<span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>&lt;</span><span style=color:#bbb> </span>tasks.<span style=color:#7d9029>size</span>();<span style=color:#bbb> </span>i<span style=color:#666>++</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>service.<span style=color:#7d9029>take</span>().<span style=color:#7d9029>get</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>任务返回的 <code>Future</code> 会以结束的顺序来排列，也就是说，程序将在 <code>get()</code> 处阻塞。</p><p>另外一种方式是使用 <code>invokeAny</code> 方法，这种方式适用于搜索之类的任务。只要有任何一个任务完成，就直接返回结果，而其他尚未完成的任务则被取消。因此这个方法只有一个返回值，而不是一个 <code>List</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>V<span style=color:#bbb> </span>found<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>executor.<span style=color:#7d9029>invokeAny</span>(tasks);<span style=color:#bbb>
</span></span></span></code></pre></div><h1 id=线程安全>线程安全
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8>#</a></h1><ul><li>非原子操作</li><li>缓存</li><li>指令重排</li></ul><h2 id=保证更新可见的几种情况>保证更新可见的几种情况
<a class=anchor href=#%e4%bf%9d%e8%af%81%e6%9b%b4%e6%96%b0%e5%8f%af%e8%a7%81%e7%9a%84%e5%87%a0%e7%a7%8d%e6%83%85%e5%86%b5>#</a></h2><p>这里讨论的是由于线程各自有独立的栈带来的问题：线程 A 对变量 a 的更新，可能在一定时间之后才会显示在线程 B 的栈上。下面这些情形下，一个线程进行的改变会立刻体现到所有的线程里：</p><ul><li><code>final</code> 变量在初始化后的值对所有线程可见</li><li>静态变量在静态初始化结束后的值对所有线程可见</li><li>对 <code>volatile</code> 变量的更新对所有线程可见</li><li>发生在锁释放前的改变，对任何试图获取同一个锁的线程是可见的</li></ul><p>这些情况适合处理只有一个线程对变量的值进行修改的情况。</p><h2 id=竞争条件>竞争条件
<a class=anchor href=#%e7%ab%9e%e4%ba%89%e6%9d%a1%e4%bb%b6>#</a></h2><p>竞争条件出现在两个线程同时修改一个变量的情形。由于对变量的更新不是<strong>原子的</strong>，变量修改可能无法正常体现。这种情况下，<code>volatile</code> 关键字就不足以解决问题。常用的方法有三种：</p><ul><li>不使用多线程共享变量。</li><li>使用 Immutable 变量（实际上也是避免了多线程的共享）</li><li>使用锁（降低性能）。</li><li>使用分区锁，这是锁的一种特殊情况。<code>ConcurrentHashMap</code> 和流都使用了这种方法。</li></ul><p>在实现 Immutable 类的过程中，要保证所有的实例变量都是 <code>final</code> 的，所有的修改方法都返回新的对象，而且所有的方法也都是 <code>final</code> 的，以免被继承覆盖。除此之外，还要保证构造方法里没有可能访问的情形。例如，如果在构造方法里运行一个新的线程，那么这时使用的 <code>Runnable</code> 对象就持有当前对象的 <code>this</code> 引用。如果 <code>Runnable</code> 运行时构造还没有结束，就有可能改变我们创建的对象。</p><h2 id=使用并行算法>使用并行算法
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e5%b9%b6%e8%a1%8c%e7%ae%97%e6%b3%95>#</a></h2><p>Stream API 中的 <code>parallelStream</code> 可以生成并行的类，这里就使用了分段锁。因此，在这个流上进行的操作需要避免共享变量。类似地，<code>Arrays</code> 类中也有一些并行方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Arrays.<span style=color:#7d9029>parallelSetAll</span>(values,<span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>i<span style=color:#bbb> </span><span style=color:#666>%</span><span style=color:#bbb> </span>10);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Arrays.<span style=color:#7d9029>parallelSort</span>(words,<span style=color:#bbb> </span>Comparator.<span style=color:#7d9029>comparing</span>(String::length));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Arrays.<span style=color:#7d9029>parallelSort</span>(words,<span style=color:#bbb> </span>words.<span style=color:#7d9029>length</span><span style=color:#bbb> </span><span style=color:#666>/</span><span style=color:#bbb> </span>2,<span style=color:#bbb> </span>words.<span style=color:#7d9029>length</span>);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// range to be sorted</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Arrays.<span style=color:#7d9029>parallelPrefix</span>(arr,<span style=color:#bbb> </span>(left,<span style=color:#bbb> </span>right)<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>...);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// for [1, 3, 5, 7], (left, right) -&gt; left * right  :</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// get [1, 3, 15, 105] which is [1*1(default), 1*3, 1*3*5, 1*3*5*7]</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=使用线程安全的数据结构>使用线程安全的数据结构
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h2><p>多个线程同时处理一个数据结构，如队列或者 <code>HashMap</code>，可能会造成数据结构的损坏，甚至线程死锁。</p><p><code>java.util.concurrent</code> 包中的集合都是线程安全的，相应地，它们产生的迭代器都是 <strong>弱一致</strong>的。这意味着，相比<code>java.util</code> 包中的集合，即使迭代器构造之后修改集合，也不会抛出 <code>ConcurrentModificationException</code> 异常。不过相应地，迭代器有可能不能准确地反映出元素的修改情况。</p><h3 id=concurrenthashmap>ConcurrentHashMap
<a class=anchor href=#concurrenthashmap>#</a></h3><p>考虑一个计数器的例子：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ConcurrentHashMap<span style=color:#666>&lt;</span>String,<span style=color:#bbb> </span>Long<span style=color:#666>&gt;</span><span style=color:#bbb> </span>map<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ConcurrentHashMap<span style=color:#666>&lt;&gt;</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Long<span style=color:#bbb> </span>oldVal<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>map.<span style=color:#7d9029>get</span>(word);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>map.<span style=color:#7d9029>put</span>(word,<span style=color:#bbb> </span>(oldVal<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span><span style=color:#666>?</span><span style=color:#bbb> </span>1<span style=color:#bbb> </span>:<span style=color:#bbb> </span>oldVal<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>1);<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>ConcurrentHashMap</code> 中的锁没有办法控制 <code>map.put</code> 的原子性。我们可能先取出值，这个值被另一个线程修改，再放回这个值，这时就出现了数据的错误。因此，需要使用 map 中的其他方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>map.<span style=color:#7d9029>compute</span>(word,<span style=color:#bbb> </span>(k,<span style=color:#bbb> </span>v)<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>(v<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span><span style=color:#666>?</span><span style=color:#bbb> </span>1<span style=color:#bbb> </span>:<span style=color:#bbb> </span>v<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>1);<span style=color:#bbb>
</span></span></span></code></pre></div><p>类似的，还有 <code>computeIfAbsent</code> <code>computeIfPresent</code> <code>putIfAbsent</code> 方法。</p><p>或者，对于计数器这种操作，还可以用更加简单的 <code>merge</code> 方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>map.<span style=color:#7d9029>merge</span>(word,<span style=color:#bbb> </span>1L,<span style=color:#bbb> </span>(oldVal,<span style=color:#bbb> </span>newVal)<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>oldVal<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>newVal);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>mep.<span style=color:#7d9029>merge</span>(word,<span style=color:#bbb> </span>1L,<span style=color:#bbb> </span>Long::sum);<span style=color:#bbb>
</span></span></span></code></pre></div><p>这样，如果 map 中不存在对应的值，就会使用默认值 <code>1L</code>。</p><p>当然，这里传入的 lambda 表达式应当是短小快速的，并且不应该视图修改 map 的映射本身。这样，map 才能很好地保证其原子性。在 <code>compute</code> 方法出现之前，人们使用一种反复取值以保证修改成功的模式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>do</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>oldVal<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>map.<span style=color:#7d9029>get</span>(word);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>newVal<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>oldVal<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>1;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb> </span><span style=color:green;font-weight:700>while</span><span style=color:#bbb> </span>(<span style=color:#666>!</span>map.<span style=color:#7d9029>replace</span>(word,<span style=color:#bbb> </span>oldVal,<span style=color:#bbb> </span>newVal));<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果 map 中的值已经不再是我们取出来的值，就需要从头进行取值和计算工作。</p><h3 id=阻塞队列-blocking-queues>阻塞队列 Blocking Queues
<a class=anchor href=#%e9%98%bb%e5%a1%9e%e9%98%9f%e5%88%97-blocking-queues>#</a></h3><p>阻塞队列是一个常用的解决生产者-消费者问题的数据结构。生产者从一端压入，消费者从另一端取出。如果像一个满队列压入或对一个空队列取出，操作就会阻塞。</p><p>对于 <code>BlockingQueue</code> 来说，<code>put</code> 方法和 <code>take</code> 方法是阻塞的，而 <code>add</code> 方法和 <code>remove</code> 方法会抛出异常。这样就使其和一般的 <code>Queue</code> 接口兼容。<code>offer</code> 方法添加一个元素并返回真，如果队列满则返回假。<code>poll</code> 和 <code>peek</code> 则是在队列为空时返回 null。此外，还有使用超时方式的变种：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span>success<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>q.<span style=color:#7d9029>offer</span>(x,<span style=color:#bbb> </span>100,<span style=color:#bbb> </span>TimeUnit.<span style=color:#7d9029>MILLISECONDS</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Object<span style=color:#bbb> </span>head<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>q.<span style=color:#7d9029>poll</span>(100,<span style=color:#bbb> </span>TimeUnit.<span style=color:#7d9029>MILLISECONDS</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>与普通的集合类似，也有 <code>BlockingDeque</code> 提供双向队列，<code>LinkedBlockingQueue</code> 提供链表，<code>ArrayBlockingQueue</code> 使用数组，<code>LinkedBlockingDeque</code> 等实现。</p><h3 id=其他数据结构>其他数据结构
<a class=anchor href=#%e5%85%b6%e4%bb%96%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84>#</a></h3><p>Java 的 concurrent 包提供了另外一些数据结构：<code>ConcurrentSkipListMap</code> <code>ConcurrentSkipListSet</code> <code>CopyOnWriteArrayList</code> <code>CopyOnWriteArraySet</code>。</p><p><code>SkipListMap</code> 中的数据是有序的。在有序集合中，显然 <code>TreeMap</code> 效率最高，其次是使用 <code>Collections.synchronizedSortedMap()</code> 来包装 <code>TreeMap</code>，当并发量很高时，跳跃链表的优势才显现出来。</p><p><img src=https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Skip_list.svg/470px-Skip_list.svg.png alt=SkipListMap></p><p>暂时还没有并发的<code>Set</code> 数据结构。<code>ConcurrentHashMap</code> 的静态方法 <code>newKeySet</code> 产生一个 <code>Set&lt;K></code> 对象，实际上是一个 <code>ConcurrentHashMap</code> 的包装，一个内部类 <code>KeySetView</code>，其所有的 value 都是 <code>Boolean.TRUE</code>，可以直接当做一个 <code>Set</code> 来使用。在这个 <code>Set</code> 中删除元素会影响 Map 本身，但向其中插入是没有意义的，因为没有相应的 value。相比之下，如果向 <code>Map.keySet(V default)</code> 得到的 <code>Set</code> 中插入值，则会使用默认值作为 value。</p><h3 id=原子值>原子值
<a class=anchor href=#%e5%8e%9f%e5%ad%90%e5%80%bc>#</a></h3><p>原子值放在 <code>java.util.concurrent.atomic</code>，包括 <code>AtomicXxx</code> <code>AtomicXxxArray</code> <code>AtomicXxxFieldUpdater</code> 等，其中 <code>Xxx</code> 可以为 <code>Integer</code> <code>Long</code> <code>Reference</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span>AtomicLong<span style=color:#bbb> </span>num<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>AtomicLong();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>id<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>num.<span style=color:#7d9029>incrementAndGet</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>num.<span style=color:#7d9029>updateAndGet</span>(x<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>Math.<span style=color:#7d9029>max</span>(x,<span style=color:#bbb> </span>someOtherNum));<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// DO NOT use num.set()</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>num.<span style=color:#7d9029>accumulateAndGet</span>(someOtherNum,<span style=color:#bbb> </span>Math::max);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// combine the value and param</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>这一类更新操作是<strong>乐观的</strong>（在 JDK 8 中，其实现就是上面的 do-while 方式）。这意味着当并发量很高时，竞争将会十分激烈。这时，可以使用 <code>LongAdder</code> 或 <code>LongAccumulator</code>。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>final</span><span style=color:#bbb> </span>LongAdder<span style=color:#bbb> </span>count<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>LongAdder();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>count.<span style=color:#7d9029>increment</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>count.<span style=color:#7d9029>add</span>(1L);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>total<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>count.<span style=color:#7d9029>sum</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>LongAccumulator</code> 的用法我们之前也见过类似的例子，常用于处理累加类的问题。在构造时提供操作和中立元素，即离散数学中的单位元，对于累加是 0，对于累乘是 1。然后使用 <code>accumulate</code> 方法传入值，使用 <code>get</code> 方法获取值。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>LongAccumulator<span style=color:#bbb> </span>acc<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>LongAccumulator(Long::sum,<span style=color:#bbb> </span>0);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>acc.<span style=color:#7d9029>accumulate</span>(val);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>long</span><span style=color:#bbb> </span>sum<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>acc.<span style=color:#7d9029>get</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p>这两个原子值类的思想是类似的：将运算操作推后，集中起来进行。因为大多数情况下，我们并不需要在运算的每一步立刻得到结果，而只是需要一个最终的累加值。显然，这样的操作应该遵守交换律和结合律。Java 提供了类似的 <code>DoubleAdder</code> 和 <code>DoubleAccumulator</code>。</p><p>实现上，<code>LongAccumulator</code> 内部实际上有一个 <code>Long</code> 类型的集合，每个元素都被初始化为单位元，在这里是 0。每当 <code>accumulate(param)</code> 的时候，就将新加入的值与其中一个值进行运算，例如在这里是用 <code>0 + param</code> 来替换原来的 0。最后，到了调用 <code>get</code> 时，所有的值才会进行累加操作。</p><p>之前我们已经看到 <code>compute(K, Function&lt;? super K, ? extends V>)</code>。如果把 <code>LongAdder</code> 作为 map 的 value，那么就可以使用：<code>counts.computeIfAbsent(key, k -> new LongAdder()).increment()</code>，对映射中的原子值进行操作。</p><h1 id=锁>锁
<a class=anchor href=#%e9%94%81>#</a></h1><h2 id=可重入锁-reentrantlock>可重入锁 ReentrantLock
<a class=anchor href=#%e5%8f%af%e9%87%8d%e5%85%a5%e9%94%81-reentrantlock>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Lock<span style=color:#bbb> </span>countLock<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ReentrantLock();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#bbb> </span>count;<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// variable to be shared</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>countLock.<span style=color:#7d9029>lock</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>try</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>count<span style=color:#666>++</span>;<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// critical area</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb> </span><span style=color:green;font-weight:700>finally</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>countLock.<span style=color:#7d9029>unlock</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// release the lock，no matter throw exception or not</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里，我们显式地使用锁来处理多线程冲突问题。可以看到，这个过程和操作系统提供的锁非常类似。不过，大多数情况下我们使用 <code>synchronized</code> 关键字来隐式地锁住对象。不过，处理锁的问题相当复杂，有可能会造成糟糕的死锁。所以如果能使用线程安全的数据结构，在线程之间传递数据，应该尽量避免使用锁。</p><p>&ldquo;可重入"的典型情况体现在递归方法上。假设我们在一个线程上递归访问同一个同步变量，那么这个线程的栈中的每一次方法调用之间并不会发生冲突，而是被计数。直到计数为 0 的时候，说明所有的方法调用都结束，放开对象的锁，这时整个锁也被放开。</p><h2 id=synchronized-关键字>synchronized 关键字
<a class=anchor href=#synchronized-%e5%85%b3%e9%94%ae%e5%ad%97>#</a></h2><p>上面的代码相当于：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span>(count)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>count<span style=color:#666>++</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>使用 <code>synchronized</code> 关键字也能够保证可见性。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Flag</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>private</span><span style=color:#bbb> </span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span>done;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>set</span>()<span style=color:#bbb> </span>{<span style=color:#bbb> </span>done<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>true</span>;<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span><span style=color:#b00040>boolean</span><span style=color:#bbb> </span><span style=color:#00f>get</span>()<span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>done;<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这样，在 <code>synchronized</code> 方法内对变量进行修改，在所有的线程里都能观察到改变。</p><p>由于对象的锁是公有的，所有位置都可以对一个对象上锁。对实例方法使用 <code>synchronized</code> 关键字相当于锁住整个对象，对静态方法使用相当于锁住整个类。对变量上锁则只是锁住对象。</p><p>在标准库中，<code>HashTable</code> 的几乎所有方法都是 <code>synchronized</code> 的。因此它是线程安全的，但性能较差。更多关于锁的细节可以看<a href=/2018/01/19/Java-%E7%9A%84-synchronized-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E9%94%81/>这里</a>。</p><h2 id=条件等待>条件等待
<a class=anchor href=#%e6%9d%a1%e4%bb%b6%e7%ad%89%e5%be%85>#</a></h2><p>现在我们尝试编写一个阻塞的多线程的队列。为了方便起见，我们使用链表来实现这个队列。这样，插入过程永远不会阻塞，删除过程在队列为空时阻塞。对于一个非阻塞的实现，方法应该这样实现：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Queue</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>private</span><span style=color:#bbb> </span>Node<span style=color:#bbb> </span>head;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>private</span><span style=color:#bbb> </span>Node<span style=color:#bbb> </span>tail;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>add</span>(Object<span style=color:#bbb> </span>val)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>// push at the tail</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span>Object<span style=color:#bbb> </span><span style=color:#00f>remove</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>if</span><span style=color:#bbb> </span>(head<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:#408080;font-style:italic>// remove and return value</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>如果要实现一个阻塞形式的队列，我们就需要在判断 <code>head == null</code> 时让线程等待。不能在这里直接自旋，因为当前线程持有队列对象的锁，其他线程无法进来插入新的元素。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span>Objetc<span style=color:#bbb> </span><span style=color:#00f>take</span>()<span style=color:#bbb> </span><span style=color:green;font-weight:700>throws</span><span style=color:#bbb> </span>InterruptedException<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>while</span><span style=color:#bbb> </span>(head<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span>wait();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>synchronized</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>add</span>(Object<span style=color:#bbb> </span>val)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>notifyAll();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>两个方法持有的都是所在对象的锁。在 <code>notifyAll()</code> 之后，所有正在 <code>wait()</code> 的线程都会被唤醒。因此，需要使用循环再次检查，最终只有一个线程能够进行操作，其他所有的都会再次进入 <code>wait</code>（因为是 <code>synchronized</code> 的）。如果只想唤醒一个线程，则可以使用 <code>notify()</code>，但如果被唤醒的线程再次等待，而没有其他的 <code>notify</code>，就可能发生死锁。</p><p>这种方法可以用来构建阻塞的数据结构，但如果只是想让线程等待某个条件，最好直接使用 Java 提供的其他同步类库，例如 <code>CountDownLatch</code> 和 <code>CyclicBarrier</code>。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#线程和进程>线程和进程</a><ul><li><a href=#线程>线程</a></li><li><a href=#线程变量和其他属性>线程变量和其他属性</a></li><li><a href=#进程>进程</a></li><li><a href=#异步>异步</a></li></ul></li><li><a href=#线程池>线程池</a><ul><li><a href=#executor>Executor</a></li><li><a href=#executorservice>ExecutorService</a></li><li><a href=#多个任务的情形>多个任务的情形</a></li></ul></li><li><a href=#线程安全>线程安全</a><ul><li><a href=#保证更新可见的几种情况>保证更新可见的几种情况</a></li><li><a href=#竞争条件>竞争条件</a></li><li><a href=#使用并行算法>使用并行算法</a></li><li><a href=#使用线程安全的数据结构>使用线程安全的数据结构</a><ul><li><a href=#concurrenthashmap>ConcurrentHashMap</a></li><li><a href=#阻塞队列-blocking-queues>阻塞队列 Blocking Queues</a></li><li><a href=#其他数据结构>其他数据结构</a></li><li><a href=#原子值>原子值</a></li></ul></li></ul></li><li><a href=#锁>锁</a><ul><li><a href=#可重入锁-reentrantlock>可重入锁 ReentrantLock</a></li><li><a href=#synchronized-关键字>synchronized 关键字</a></li><li><a href=#条件等待>条件等待</a></li></ul></li></ul></nav></div></aside></main></body></html>