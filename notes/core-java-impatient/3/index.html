<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="继承 # Java 中的 super 不是另一个对象的引用，而是绕过动态查找方法的指令。相比之下，this 是一个指向本身的引用。 在方法引用中可以使用 super。new Thread(super::work).start(); 重载方法不能改变参数。可以使用 @Override 让编译器进行检查。 子类无法访问父类的 private 成员。因此，应该在构造时调用父类的构造函数。super(params); 如果一个类的父类中有一个实例方法，实现的接口中有一个同名的默认方法。与接口冲突的情况不同，在这里，父类方法永远先于接口的实现。这是为了与旧版本代码的兼容。 final 方法不能被覆盖，final 类不能被继承。 里氏代换原则 # 里氏代换原则是指，一个父类对象可以出现的位置，也可以放置一个子类对象。
因此，子类重载的方法可以返回父类方法返回值的子类。这被叫做协变返回类型。
Java 的数组同样是协变的。也就是说，一个父类数组引用可以指向一个一个子类数组对象。因此，可能存在这样的问题：
Son[] sons = new Son[0]; Father fathers = sons; fathers[0] = new Father(...) // Exception: ArrayStoreException 在这里，fathers 指向的实际上是一个 Son 类的数组，其中只能存储 Son 类的对象。因此，这里出现了一个编译时无法发现的错误。为了避免这种问题，应当限制协变数组的作用域。
抽象类 # 抽象类的某些方法被声明为抽象的：
abstract class Person { private String id; public Person(String name); public abstract int getId(); } 和接口的区别是，抽象类可以拥有实例变量和构造函数。实现上，我们认为，抽象类是一个可以被具体化的模型，而接口代表的是某一个功能，二者的意义是有区别的。因此，类是单继承的，接口是可以多继承的。
当然，抽象类中可以不包含抽象方法，虽然这种情况很少见。但是，包含抽象方法的类必须被声明为抽象的。
访问权限 # 子类的重载方法的可见性必须等于或者高于父类。例如，protected 父类方法的重载只能是 protected 和 public。这里可以看到，protected 是比默认的包访问权限更开放的。换句话说，同一个包内的其他类可以访问 protected 方法。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:url" content="/notes/core-java-impatient/3/"><meta property="og:site_name" content="czdm75 Blog"><meta property="og:title" content="3. Inheritance, Reflection"><meta property="og:description" content="继承 # Java 中的 super 不是另一个对象的引用，而是绕过动态查找方法的指令。相比之下，this 是一个指向本身的引用。 在方法引用中可以使用 super。new Thread(super::work).start(); 重载方法不能改变参数。可以使用 @Override 让编译器进行检查。 子类无法访问父类的 private 成员。因此，应该在构造时调用父类的构造函数。super(params); 如果一个类的父类中有一个实例方法，实现的接口中有一个同名的默认方法。与接口冲突的情况不同，在这里，父类方法永远先于接口的实现。这是为了与旧版本代码的兼容。 final 方法不能被覆盖，final 类不能被继承。 里氏代换原则 # 里氏代换原则是指，一个父类对象可以出现的位置，也可以放置一个子类对象。
因此，子类重载的方法可以返回父类方法返回值的子类。这被叫做协变返回类型。
Java 的数组同样是协变的。也就是说，一个父类数组引用可以指向一个一个子类数组对象。因此，可能存在这样的问题：
Son[] sons = new Son[0]; Father fathers = sons; fathers[0] = new Father(...) // Exception: ArrayStoreException 在这里，fathers 指向的实际上是一个 Son 类的数组，其中只能存储 Son 类的对象。因此，这里出现了一个编译时无法发现的错误。为了避免这种问题，应当限制协变数组的作用域。
抽象类 # 抽象类的某些方法被声明为抽象的：
abstract class Person { private String id; public Person(String name); public abstract int getId(); } 和接口的区别是，抽象类可以拥有实例变量和构造函数。实现上，我们认为，抽象类是一个可以被具体化的模型，而接口代表的是某一个功能，二者的意义是有区别的。因此，类是单继承的，接口是可以多继承的。
当然，抽象类中可以不包含抽象方法，虽然这种情况很少见。但是，包含抽象方法的类必须被声明为抽象的。
访问权限 # 子类的重载方法的可见性必须等于或者高于父类。例如，protected 父类方法的重载只能是 protected 和 public。这里可以看到，protected 是比默认的包访问权限更开放的。换句话说，同一个包内的其他类可以访问 protected 方法。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="notes"><title>3. Inheritance, Reflection | czdm75 Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.f7e98004e6b8d1bafd93b9d4b053644c96b18c50c1205ec6db396c209e97a5a3.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-7258d8e1fea5a0c302a6de537a7b6f57 class=toggle>
<label for=section-7258d8e1fea5a0c302a6de537a7b6f57 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-6c3d93bc59df31a703231f35ad75d678 class=toggle>
<label for=section-6c3d93bc59df31a703231f35ad75d678 class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-75aaf2c83c6ed8e1f079c5418c19dad4 class=toggle checked>
<label for=section-75aaf2c83c6ed8e1f079c5418c19dad4 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/ class=active>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-b2f01d2b22c35e214487b845322f7a58 class=toggle>
<label for=section-b2f01d2b22c35e214487b845322f7a58 class="flex justify-between"><a href=/notes/ddia/>Designing Data-Intensive Applications</a></label><ul><li><a href=/notes/ddia/1/>1. Data System and Data Model</a></li><li><a href=/notes/ddia/2/>2. Storage, Query, Encoding</a></li><li><a href=/notes/ddia/3/>3. Replication and Partition</a></li></ul></li><li><input type=checkbox id=section-8c64db930c5b756022bf5d3ba1af6015 class=toggle>
<label for=section-8c64db930c5b756022bf5d3ba1af6015 class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-15259ec15aa2cb7859c77500905f6b03 class=toggle>
<label for=section-15259ec15aa2cb7859c77500905f6b03 class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-3efdc8e38ef7f47959bf45f30a9dec98 class=toggle>
<label for=section-3efdc8e38ef7f47959bf45f30a9dec98 class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-ebdb83a62411872593631ee1e4ab41d9 class=toggle>
<label for=section-ebdb83a62411872593631ee1e4ab41d9 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>3. Inheritance, Reflection</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#继承>继承</a><ul><li><a href=#里氏代换原则>里氏代换原则</a></li><li><a href=#抽象类>抽象类</a></li><li><a href=#访问权限>访问权限</a></li><li><a href=#匿名子类>匿名子类</a></li></ul></li><li><a href=#object-类>Object 类</a><ul><li><a href=#tostring>toString()</a></li><li><a href=#equals>equals()</a></li><li><a href=#hashcode>hashCode()</a></li><li><a href=#clone>clone()</a></li></ul></li><li><a href=#枚举>枚举</a><ul><li><a href=#枚举类型>枚举类型</a></li><li><a href=#枚举类型的实现>枚举类型的实现</a><ul><li><a href=#构造方法>构造方法</a></li><li><a href=#枚举的方法体>枚举的方法体</a></li><li><a href=#静态成员>静态成员</a></li></ul></li></ul></li><li><a href=#运行时类型信息>运行时类型信息</a><ul><li><a href=#class-类>Class 类</a></li><li><a href=#class-类的一些方法>Class 类的一些方法</a></li><li><a href=#class-loader>Class Loader</a></li><li><a href=#关于-class-loader-的一些问题>关于 Class Loader 的一些问题</a></li><li><a href=#service-loader>Service Loader</a></li></ul></li><li><a href=#反射>反射</a><ul><li><a href=#检查类和对象>检查类和对象</a></li><li><a href=#javabean-和数组>JavaBean 和数组</a></li><li><a href=#代理-proxy>代理 Proxy</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=继承>继承
<a class=anchor href=#%e7%bb%a7%e6%89%bf>#</a></h1><ul><li>Java 中的 <code>super</code> 不是另一个对象的引用，而是绕过动态查找方法的指令。相比之下，<code>this</code> 是一个指向本身的引用。</li><li>在方法引用中可以使用 <code>super</code>。<code>new Thread(super::work).start();</code></li><li>重载方法不能改变参数。可以使用 <code>@Override</code> 让编译器进行检查。</li><li>子类无法访问父类的 <code>private</code> 成员。因此，应该在构造时调用父类的构造函数。<code>super(params);</code></li><li>如果一个类的父类中有一个实例方法，实现的接口中有一个同名的默认方法。与接口冲突的情况不同，在这里，父类方法永远<strong>先于</strong>接口的实现。这是为了与旧版本代码的兼容。</li><li>final 方法不能被覆盖，final 类不能被继承。</li></ul><h2 id=里氏代换原则>里氏代换原则
<a class=anchor href=#%e9%87%8c%e6%b0%8f%e4%bb%a3%e6%8d%a2%e5%8e%9f%e5%88%99>#</a></h2><p>里氏代换原则是指，一个父类对象可以出现的位置，也可以放置一个子类对象。</p><p>因此，子类重载的方法可以返回父类方法返回值的子类。这被叫做<strong>协变返回类型</strong>。</p><p>Java 的数组同样是协变的。也就是说，一个父类数组引用可以指向一个一个子类数组对象。因此，可能存在这样的问题：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Son<span style=color:#666>[]</span><span style=color:#bbb> </span>sons<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>Son<span style=color:#666>[</span>0<span style=color:#666>]</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Father<span style=color:#bbb> </span>fathers<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>sons;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>fathers<span style=color:#666>[</span>0<span style=color:#666>]</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>Father(...)<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// Exception: ArrayStoreException</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>在这里，fathers 指向的实际上是一个 Son 类的数组，其中只能存储 Son 类的对象。因此，这里出现了一个编译时无法发现的错误。为了避免这种问题，应当限制协变数组的作用域。</p><h2 id=抽象类>抽象类
<a class=anchor href=#%e6%8a%bd%e8%b1%a1%e7%b1%bb>#</a></h2><p>抽象类的某些方法被声明为抽象的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>abstract</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Person</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>private</span><span style=color:#bbb> </span>String<span style=color:#bbb> </span>id;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#00f>Person</span>(String<span style=color:#bbb> </span>name);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>abstract</span><span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>getId</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>和接口的区别是，抽象类可以拥有实例变量和构造函数。实现上，我们认为，抽象类是一个可以被具体化的模型，而接口代表的是某一个功能，二者的意义是有区别的。因此，类是单继承的，接口是可以多继承的。</p><p>当然，抽象类中可以不包含抽象方法，虽然这种情况很少见。但是，包含抽象方法的类必须被声明为抽象的。</p><h2 id=访问权限>访问权限
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e6%9d%83%e9%99%90>#</a></h2><p>子类的重载方法的可见性必须等于或者高于父类。例如，<code>protected</code> 父类方法的重载只能是 <code>protected</code> 和 <code>public</code>。这里可以看到，<code>protected</code> 是比默认的包访问权限更开放的。换句话说，同一个包内的其他类可以访问 <code>protected</code> 方法。</p><p>不过，即使 B 继承了 A 类，B 的方法也只能访问 A 对象中的 A 方法，而不能访问其他的 A 对象。这样，就不会存在仅为了访问 <code>protected</code> 方法而编写的类。</p><p>因此，我们可以看到，开放的方法不能被封闭起来，因此要慎重使用 <code>protected</code> 关键字。</p><h2 id=匿名子类>匿名子类
<a class=anchor href=#%e5%8c%bf%e5%90%8d%e5%ad%90%e7%b1%bb>#</a></h2><p>同样可以使用匿名子类，用法和接口的匿名类十分类似。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>ArrayList<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span><span style=color:#bbb> </span>names<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ArrayList<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span>(100)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@Override</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>void</span><span style=color:#bbb> </span><span style=color:#00f>add</span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>index,<span style=color:#bbb> </span>String<span style=color:#bbb> </span>element)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>super</span>.<span style=color:#7d9029>add</span>(index,<span style=color:#bbb> </span>element);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#7d9029>out</span>.<span style=color:#7d9029>println</span>(<span style=color:#ba2121>&#34;added elem&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>同样地，如果给匿名子类使用一个初始化块，将得到这样的结果：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>new</span><span style=color:#bbb> </span>ArrayList<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span>()<span style=color:#bbb> </span>{{<span style=color:#bbb> </span>add(<span style=color:#ba2121>&#34;abc&#34;</span>);<span style=color:#bbb> </span>add(<span style=color:#ba2121>&#34;abc&#34;</span>);<span style=color:#bbb> </span>}};<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里，外面的大括号是类的大括号，里面的是初始化块的大括号。当然，这种技巧并不推荐。因为得到的并不是一个真正的父类对象，在某些实现的 <code>equals()</code> 比较中可能会出现问题。</p><h1 id=object-类>Object 类
<a class=anchor href=#object-%e7%b1%bb>#</a></h1><h2 id=tostring>toString()
<a class=anchor href=#tostring>#</a></h2><p>对于一个普通的对象，习惯上使用这样的 <code>toString()</code> 格式：</p><blockquote><p>java.awt.Point[x=10,y=20]</p></blockquote><p>在 <code>Object</code> 类中，<code>toString()</code> 将给出这样的格式：</p><blockquote><p>java.io.PrintStream@2f6684</p></blockquote><p>对于一个 <code>int[]</code> 对象，打印出来的结果形如：</p><blockquote><p>[I@1a46e30</p></blockquote><p>其中的 <code>[</code> 代表数组类型，<code>I</code> 表示 <code>int</code> 类型。对于一般的对象则会打印出包含包名的类名，形如：</p><blockquote><p>[Ljava.lang.String@123456</p></blockquote><p>更好的方法是使用 <code>Arrays.toString(arr)</code>，将会得到：</p><blockquote><p>[2, 3, 4]</p></blockquote><p>如果是多维数组，则要使用 <code>Arrays.deepToString()</code>。</p><p>当对象与字符串连接时，会自动调用 <code>toString()</code> 方法。</p><h2 id=equals>equals()
<a class=anchor href=#equals>#</a></h2><ul><li><code>equals()</code> 应当是 null 安全的。</li><li>一般认为返回真的两个对象是完全相等的，且检测代价很小。</li><li>由于需要在方法内进行 cast，之前一定要用 <code>instaceof</code> 或 <code>getClass()</code> 进行检查。</li><li>对于基本类型可以使用 <code>==</code> 操作符，对于 <code>double</code>，建议使用 <code>Double.equals()</code>，对无穷和 NaN 安全。</li><li>最好使用调用反转，或者使用 <code>Objects.equals()</code> 方法，以保证 null 安全。</li><li>子类中的 <code>equals()</code> 方法要先调用父类方法。</li></ul><h2 id=hashcode>hashCode()
<a class=anchor href=#hashcode>#</a></h2><ul><li><code>hashCode()</code> 和 <code>equals()</code> 必须兼容。如果 <code>equals</code> 为真，<code>hashCode</code> 必须相等。因此，如果重写了 <code>equals()</code>，就<strong>必须</strong>重写 <code>hashCode()</code>。</li></ul><p>最简单的实现方式是使用 <code>Objects</code> 类提供的方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#bbb> </span>Item<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>hashCode</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>Objects.<span style=color:#7d9029>hash</span>(field1,<span style=color:#bbb> </span>field2...);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=clone>clone()
<a class=anchor href=#clone>#</a></h2><p>如果需要深拷贝，就必须实现一个没有方法的标签接口：<code>Clonable</code>。否则，会抛出 <code>CloneNotSupportedException</code>。这是一个 Checked Exception。</p><p><code>ArrayList</code> 实现的是一个浅拷贝的 <code>clone</code> 方法。因此，如果存储的不是 <code>String</code> 等 Immutable 的对象，得到的两个 <code>ArrayList</code> 将指向相同的元素。而且，这个方法返回 <code>Object</code> 对象，需要经过 cast 来使用。相比之下，数组不需要额外的判断。</p><p>方法的重写也可以借助父类的方法。因此一个完整的实现应该是：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>Clazz<span style=color:#bbb> </span><span style=color:#00f>clone</span>()<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Clazz<span style=color:#bbb> </span>clonedClazz<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>(Clazz)<span style=color:#bbb> </span><span style=color:green;font-weight:700>super</span>.<span style=color:#7d9029>clone</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#a2f>@SuppressWarnings</span>(<span style=color:#ba2121>&#34;unchecked&#34;</span>)<span style=color:#bbb> </span>ArrayList<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span><span style=color:#bbb> </span>cloned<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>(ArrayList<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span>)<span style=color:#bbb> </span>original.<span style=color:#7d9029>clone</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>clonedClazz.<span style=color:#7d9029>original</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>cloned;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>cloned;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><h1 id=枚举>枚举
<a class=anchor href=#%e6%9e%9a%e4%b8%be>#</a></h1><h2 id=枚举类型>枚举类型
<a class=anchor href=#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>enum</span><span style=color:#bbb> </span>Size<span style=color:#bbb> </span>{<span style=color:#bbb> </span>SMALL,<span style=color:#bbb> </span>LARGE<span style=color:#bbb> </span>};<span style=color:#bbb>
</span></span></span></code></pre></div><p>枚举类型是单例的，可以直接用 <code>==</code> 比较。类型已经包含了 <code>toString</code> 和 <code>valueOf</code> 方法。如果给定的字符串没有枚举类型，会抛出异常。可以获取所有的枚举实例：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Size<span style=color:#666>[]</span><span style=color:#bbb> </span>allVals<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Size.<span style=color:#7d9029>values</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p><code>ordinal</code> 方法用来获取枚举类型的序号。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Size.<span style=color:#7d9029>SMALL</span>.<span style=color:#7d9029>ordinal</span>()<span style=color:#bbb> </span><span style=color:#666>==</span><span style=color:#bbb> </span>0;<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//True</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>枚举类型还自动实现了 <code>Comparable&lt;E></code>。技术上来说，每个枚举类型都继承了 <code>Enum&lt;E></code>，并从中得到了以上方法，及 <code>compareTo</code> <code>getDeclaringClass</code>（用于有实现体的枚举）方法。</p><h2 id=枚举类型的实现>枚举类型的实现
<a class=anchor href=#%e6%9e%9a%e4%b8%be%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ae%9e%e7%8e%b0>#</a></h2><h3 id=构造方法>构造方法
<a class=anchor href=#%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95>#</a></h3><p>枚举类型中的每一个枚举常量，如 <code>SMALL</code>，都是该类型的一个实例。因此，如果为类型定义构造函数，就需要为每个枚举提供参数。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>enum</span><span style=color:#bbb> </span>Size<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>SMALL(<span style=color:#ba2121>&#34;S&#34;</span>),<span style=color:#bbb> </span>LARGE(<span style=color:#ba2121>&#34;L&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>private</span><span style=color:#bbb> </span>String<span style=color:#bbb> </span>abbr;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Size(String<span style=color:#bbb> </span>abbr)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>this</span>.<span style=color:#7d9029>abbr</span><span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>abbr;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>String<span style=color:#bbb> </span><span style=color:#00f>getAbbr</span>()<span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>abbr;<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=枚举的方法体>枚举的方法体
<a class=anchor href=#%e6%9e%9a%e4%b8%be%e7%9a%84%e6%96%b9%e6%b3%95%e4%bd%93>#</a></h3><p>也可以为每个枚举常量实现方法，只要在类中进行了定义。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>enum</span><span style=color:#bbb> </span>Operation<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>ADD<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>eval</span><span style=color:#bbb> </span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>arg1,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>args)<span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>args1<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>arg2;<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>},<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>MINUS<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>eval</span><span style=color:#bbb> </span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>arg1,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>args)<span style=color:#bbb> </span>{<span style=color:#bbb> </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>args1<span style=color:#bbb> </span><span style=color:#666>-</span><span style=color:#bbb> </span>arg2;<span style=color:#bbb> </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>};<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>abstract</span><span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>eval</span>(<span style=color:#b00040>int</span><span style=color:#bbb> </span>arg1,<span style=color:#bbb> </span><span style=color:#b00040>int</span><span style=color:#bbb> </span>arg2);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这里，实际上每个枚举常量都是该类的一个匿名子类的对象。</p><h3 id=静态成员>静态成员
<a class=anchor href=#%e9%9d%99%e6%80%81%e6%88%90%e5%91%98>#</a></h3><p><strong>枚举常量在静态成员构造之前构造</strong>。因此，枚举常量的构造函数中不能访问静态成员，它们此时还不存在。静态成员的初始化应当在静态块中完成。</p><h1 id=运行时类型信息>运行时类型信息
<a class=anchor href=#%e8%bf%90%e8%a1%8c%e6%97%b6%e7%b1%bb%e5%9e%8b%e4%bf%a1%e6%81%af>#</a></h1><h2 id=class-类>Class 类
<a class=anchor href=#class-%e7%b1%bb>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#ba2121>&#34;&#34;</span>.<span style=color:#7d9029>getClass</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//最好不要省略&lt;?&gt;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c2<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Class.<span style=color:#7d9029>forName</span>(<span style=color:#ba2121>&#34;java.lang.String&#34;</span>);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// throws ReflectiveOperationException</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c3<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>String.<span style=color:#7d9029>class</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c4<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Runnable.<span style=color:#7d9029>class</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c5<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#b00040>int</span>.<span style=color:#7d9029>class</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c6<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span><span style=color:#b00040>void</span>.<span style=color:#7d9029>class</span>;<span style=color:#bbb>
</span></span></span></code></pre></div><p>可以看到，<code>class</code> 对象不仅可以表示通常的类，还可以表示接口、基本类型和 <code>void</code>。严格来说，&ldquo;类型&rdquo; 而非 &ldquo;类&rdquo; 是一个更合适的名字。</p><p><code>forName</code> 方法可以用来生成那些在编译期还不知道的对象。比如，可以吧类名存在外部文件中，读取后通过 <code>forName</code> 来生成对象，这样就构成了一个动态框架。</p><p><code>Class.getName()</code> 方法可以得到与之前我们见到的 <code>toString</code> 方法类似的格式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getName</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//java.lang.String</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#666>[]</span>.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getName</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//[I</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>String<span style=color:#666>[]</span>.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getName</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//[Ljava.lang.String</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>String<span style=color:#666>[]</span>.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getCanonicalName</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>//java.lang.String[]</span><span style=color:#bbb>
</span></span></span></code></pre></div><p>但是，在使用 <code>forName</code> 方法时，只能使用传统的 <code>[I</code> 形式。</p><h2 id=class-类的一些方法>Class 类的一些方法
<a class=anchor href=#class-%e7%b1%bb%e7%9a%84%e4%b8%80%e4%ba%9b%e6%96%b9%e6%b3%95>#</a></h2><p><code>Class</code> 对象拥有一系列的 <code>getXxxName</code> 方法和一系列的 <code>isXxx</code> 方法，用于得到类名及检测类是否为数组、枚举、注解、嵌套类等。此外还有：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#666>&lt;?</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>super</span><span style=color:#bbb> </span>T<span style=color:#666>&gt;</span><span style=color:#bbb> </span><span style=color:#00f>getSuperClass</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Class<span style=color:#666>&lt;?&gt;[]</span><span style=color:#bbb> </span>getInterfaces();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Package<span style=color:#bbb> </span><span style=color:#00f>getPackage</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#b00040>int</span><span style=color:#bbb> </span><span style=color:#00f>getModifiers</span>();<span style=color:#bbb>
</span></span></span></code></pre></div><p>其中，<code>getModifiers</code> 得到的返回值可以用 <code>java.lang.reflace.Modifier</code> 类中的 <code>toString(int)</code> 方法和 <code>isXxx(int)</code> 方法来处理。类似这样的关于类的属性的方法还有很多。</p><p><code>Class</code> 类的一个重要作用是定位资源。例如，将 <code>config.txt</code> 和 .class 文件放在同一个目录下，一起打包成 jar，就可以这样使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>InputStream<span style=color:#bbb> </span>stream<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>MyClass.<span style=color:#7d9029>class</span>.<span style=color:#7d9029>getResourceAsStream</span>(<span style=color:#ba2121>&#34;config.txt&#34;</span>);<span style=color:#bbb>
</span></span></span></code></pre></div><p>另外，还有 <code>getResource</code> 方法返回一个资源的 <code>URL</code>，用于一些遗留方法。</p><h2 id=class-loader>Class Loader
<a class=anchor href=#class-loader>#</a></h2><p>Class Loader 读取字节码，并将它们转化成一个类型。通常，JVM 使用三个 Class Loader：</p><ul><li>bootstrap Class Loader 加载 Java 类库。</li><li>扩展 Class Loader 加载 &ldquo;标准库扩展&rdquo; 部分，在以前的版本中位于 jre/lib/ext。</li><li>系统 Class Loader 加载应用程序类，在 class path 中进行查找。</li></ul><p>安全起见，bootstrap ClassLoader 不能在代码中被获取到。并且，只有这个 Class Loader 能够加载 <code>java</code> 包下的核心类。<code>String.class.getClassLoader</code> 返回 null。在 Oracle 实现中，另外两个 ClassLoader 都是用 Java 实现的，为 <code>URLClassLoader</code> 的实例对象。因此，可以使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>((URLClassLoader)<span style=color:#bbb> </span>Main.<span style=color:#7d9029>class</span>.<span style=color:#7d9029>getClassLoader</span>()).<span style=color:#7d9029>getURLs</span>()<span style=color:#bbb>
</span></span></span></code></pre></div><p>得到 class path 中内容的 URL。</p><h2 id=关于-class-loader-的一些问题>关于 Class Loader 的一些问题
<a class=anchor href=#%e5%85%b3%e4%ba%8e-class-loader-%e7%9a%84%e4%b8%80%e4%ba%9b%e9%97%ae%e9%a2%98>#</a></h2><p>考虑这样一种情况。有这样一个工具方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Util</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Object<span style=color:#bbb> </span><span style=color:#00f>createInstance</span>(String<span style=color:#bbb> </span>className)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Class.<span style=color:#7d9029>forName</span>(className);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这个类由 Class Loader A 来加载。现在，我希望从另一个由 Class Loader B 来加载的类来调用这个方法，而我们想要加载的 jar 位于 B 的 class path 下，并不在 A 的 classpath 下。由于 <code>Util.creatInstance</code> 方法调用的是自己所在的 CLass Loader A，这个 jar 包将无法被找到。因此，需要使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>Object<span style=color:#bbb> </span><span style=color:#00f>createInstance</span>(String<span style=color:#bbb> </span>className,<span style=color:#bbb> </span>ClassLoader<span style=color:#bbb> </span>loader)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Class.<span style=color:#7d9029>forName</span>(className,<span style=color:#bbb> </span><span style=color:green;font-weight:700>true</span>,<span style=color:#bbb> </span>loader);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>或者，如果调用此方法的过程位于另一个线程里，可以使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// caller</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Thread.<span style=color:#7d9029>currentThread</span>().<span style=color:#7d9029>setContextClassLoader</span>(loader);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// the instanciate method</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Util</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span>Object<span style=color:#bbb> </span><span style=color:#00f>createInstance</span>(String<span style=color:#bbb> </span>className)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>            </span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Class.<span style=color:#7d9029>forName</span>(className,<span style=color:#bbb> </span><span style=color:green;font-weight:700>true</span>,<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>             </span>Thread.<span style=color:#7d9029>currentThread</span>().<span style=color:#7d9029>getContextClassLoader</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>这是因为每个线程持有自己的上下文加载器（Context Class Loader），默认的总是继承与创建线程，通常为系统 Class Loader。调用结束后，应该把 Class Loader 修改回来。</p><h2 id=service-loader>Service Loader
<a class=anchor href=#service-loader>#</a></h2><p>Service Loader 是一种为加载实现共同接口的不同插件提供方便的方式。例如，我们有一个接口和一个实现：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>package</span><span style=color:#bbb> </span><span style=color:#00f;font-weight:700>com.test.crypt</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Cipher</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:#b00040>byte</span><span style=color:#666>[]</span><span style=color:#bbb> </span><span style=color:#00f>encrypt</span>(<span style=color:#b00040>byte</span><span style=color:#666>[]</span><span style=color:#bbb> </span>source<span style=color:#bbb> </span><span style=color:#b00040>byte</span><span style=color:#666>[]</span><span style=color:#bbb> </span>key);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>//---------------</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>package</span><span style=color:#bbb> </span><span style=color:#00f;font-weight:700>com.test.crypt.impl</span>;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>AESCipher</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>implements</span><span style=color:#bbb> </span>Cipher<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>然后，我们提供一个文本文件：<code>META-INF/services/com.test.crypt.Cipher</code>，其中包含了实现的类名：</p><pre><code>com.test.crypt.impl.AESCipher
</code></pre><p>这样，就相当于为一种服务提供了一个实现。然后，在程序代码中可以这样使用：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// 通过Cipher.class指示ServiceLoader去寻找提供的实现</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>static</span><span style=color:#bbb> </span>ServiceLoader<span style=color:#666>&lt;</span>Cipher<span style=color:#666>&gt;</span><span style=color:#bbb> </span>cipherLoader<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>ServiceLoader.<span style=color:#7d9029>load</span>(Cipher.<span style=color:#7d9029>class</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// 遍历所有配置中提供的实现</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(Cipher<span style=color:#bbb> </span>c<span style=color:#bbb> </span>:<span style=color:#bbb> </span>cipherLoader)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>显然，ServiceLoader 只应该被初始化一次。仅需一次，需要的类就被加载进内存了。</p><h1 id=反射>反射
<a class=anchor href=#%e5%8f%8d%e5%b0%84>#</a></h1><p>反射可以在运行时检查任意对象的内容，通常用于对象关系映射和 GUI。需要注意的是，它运行起来要更慢。</p><h2 id=检查类和对象>检查类和对象
<a class=anchor href=#%e6%a3%80%e6%9f%a5%e7%b1%bb%e5%92%8c%e5%af%b9%e8%b1%a1>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Class<span style=color:#666>&lt;?&gt;</span><span style=color:#bbb> </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Class.<span style=color:#7d9029>forName</span>(className);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// print all methods</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>while</span><span style=color:#bbb> </span>(c1<span style=color:#bbb> </span><span style=color:#666>!=</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>null</span>)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(Mehod<span style=color:#bbb> </span>m<span style=color:#bbb> </span>:<span style=color:#bbb> </span>c1.<span style=color:#7d9029>getDeclaredMethods</span>())<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>c1<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>c1.<span style=color:#7d9029>getSuperClass</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// checkout all variables in an Object</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Object<span style=color:#bbb> </span>obj<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(Field<span style=color:#bbb> </span>f<span style=color:#bbb> </span>:<span style=color:#bbb> </span>obj.<span style=color:#7d9029>getClass</span>.<span style=color:#7d9029>getDeclaredFields</span>())<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>f.<span style=color:#7d9029>setAccessible</span>(<span style=color:green;font-weight:700>true</span>);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// may be denied by security manager, no by default</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Object<span style=color:#bbb> </span>val<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>f.<span style=color:#7d9029>get</span>(obj);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// Field f in obj</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>f.<span style=color:#7d9029>setDouble</span>(obj<span style=color:#bbb> </span>,0.<span style=color:#7d9029>1</span>);<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// Modify the field</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>...<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// checkout methods</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Person<span style=color:#bbb> </span>p<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// for method &#34;setName(String)&#34;</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Method<span style=color:#bbb> </span>m<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>p.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getMethod</span>(<span style=color:#ba2121>&#34;setName&#34;</span>,<span style=color:#bbb> </span>String.<span style=color:#7d9029>class</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// check out Method[] like above is also possible</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// call the method</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>m.<span style=color:#7d9029>invoke</span>(obj,<span style=color:#bbb> </span><span style=color:#ba2121>&#34;...name&#34;</span>);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// construct an object with no param</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Object<span style=color:#bbb> </span>obj<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>c1.<span style=color:#7d9029>newInstance</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#408080;font-style:italic>// construck with param</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Cunstructor<span style=color:#bbb> </span>constr<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>c1.<span style=color:#7d9029>getConstructor</span>(c1);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Object<span style=color:#bbb> </span>obj<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>constr.<span style=color:#7d9029>newInctance</span>(param);<span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=javabean-和数组>JavaBean 和数组
<a class=anchor href=#javabean-%e5%92%8c%e6%95%b0%e7%bb%84>#</a></h2><p>对于 Bean 对象，反射系统还提供了更具体的一系列方法</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>BeanInfo<span style=color:#bbb> </span>info<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Introspector.<span style=color:#7d9029>getBeanInfo</span>(c1);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>PropertyDescriptor<span style=color:#666>[]</span><span style=color:#bbb> </span>props<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>info.<span style=color:#7d9029>getPropertyDecsriptors</span>();<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:green;font-weight:700>for</span><span style=color:#bbb> </span>(PropertyDescriptor<span style=color:#bbb> </span>prop<span style=color:#bbb> </span>:<span style=color:#bbb> </span>props)<span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>prop.<span style=color:#7d9029>getName</span>()...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>对于数组，同样有一类方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>c1.<span style=color:#7d9029>isArray</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// true</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>c1.<span style=color:#7d9029>getCompanentType</span>();<span style=color:#bbb>  </span><span style=color:#408080;font-style:italic>// content class</span><span style=color:#bbb>
</span></span></span></code></pre></div><h2 id=代理-proxy>代理 Proxy
<a class=anchor href=#%e4%bb%a3%e7%90%86-proxy>#</a></h2><p>Proxy 类用于使用反射在运行时创建一个实现某个接口的类。由于我们不能在运行时直接编写新代码，需要一个<strong>调用处理器</strong>，即一个实现了 <code>InvocationHandler</code> 接口的对象。下面实现一个在 <code>Comparable</code> 接口基础上添加调试信息的过程。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span><span style=color:#bbb> </span><span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>InvocationHandler</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>Object<span style=color:#bbb> </span><span style=color:#00f>invoke</span>(Object<span style=color:#bbb> </span>proxy,<span style=color:#bbb> </span>Method<span style=color:#bbb> </span>method,<span style=color:#bbb> </span>Object<span style=color:#666>[]</span><span style=color:#bbb> </span>args);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>Object<span style=color:#bbb> </span>value<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>...;<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>value<span style=color:#bbb> </span><span style=color:#666>=</span><span style=color:#bbb> </span>Proxy.<span style=color:#7d9029>newProxyInstance</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>(<span style=color:green;font-weight:700>null</span>,<span style=color:#bbb> </span>value.<span style=color:#7d9029>getClass</span>().<span style=color:#7d9029>getInterfaces</span>(),<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>     </span><span style=color:#408080;font-style:italic>//lambda expression that implements InvocationHandler</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>(Object<span style=color:#bbb> </span>proxy,<span style=color:#bbb> </span>Method<span style=color:#bbb> </span>m,<span style=color:#bbb> </span>Object<span style=color:#666>[]</span><span style=color:#bbb> </span>margs)<span style=color:#bbb> </span><span style=color:#666>-&gt;</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span>System.<span style=color:#7d9029>out</span>.<span style=color:#7d9029>println</span>(value<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span><span style=color:#ba2121>&#39;.&#39;</span><span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>m.<span style=color:#7d9029>getName</span>()<span style=color:#bbb> </span><span style=color:#666>+</span><span style=color:#bbb> </span>Arrays.<span style=color:#7d9029>toString</span>(margs));<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>        </span><span style=color:green;font-weight:700>return</span><span style=color:#bbb> </span>m.<span style=color:#7d9029>invoke</span>(value,<span style=color:#bbb> </span>margs);<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>});<span style=color:#bbb>
</span></span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#继承>继承</a><ul><li><a href=#里氏代换原则>里氏代换原则</a></li><li><a href=#抽象类>抽象类</a></li><li><a href=#访问权限>访问权限</a></li><li><a href=#匿名子类>匿名子类</a></li></ul></li><li><a href=#object-类>Object 类</a><ul><li><a href=#tostring>toString()</a></li><li><a href=#equals>equals()</a></li><li><a href=#hashcode>hashCode()</a></li><li><a href=#clone>clone()</a></li></ul></li><li><a href=#枚举>枚举</a><ul><li><a href=#枚举类型>枚举类型</a></li><li><a href=#枚举类型的实现>枚举类型的实现</a><ul><li><a href=#构造方法>构造方法</a></li><li><a href=#枚举的方法体>枚举的方法体</a></li><li><a href=#静态成员>静态成员</a></li></ul></li></ul></li><li><a href=#运行时类型信息>运行时类型信息</a><ul><li><a href=#class-类>Class 类</a></li><li><a href=#class-类的一些方法>Class 类的一些方法</a></li><li><a href=#class-loader>Class Loader</a></li><li><a href=#关于-class-loader-的一些问题>关于 Class Loader 的一些问题</a></li><li><a href=#service-loader>Service Loader</a></li></ul></li><li><a href=#反射>反射</a><ul><li><a href=#检查类和对象>检查类和对象</a></li><li><a href=#javabean-和数组>JavaBean 和数组</a></li><li><a href=#代理-proxy>代理 Proxy</a></li></ul></li></ul></nav></div></aside></main></body></html>