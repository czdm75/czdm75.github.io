<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Core Java for Impatients on czdm75 Blog</title><link>/notes/core-java-impatient/</link><description>Recent content in Core Java for Impatients on czdm75 Blog</description><generator>Hugo -- gohugo.io</generator><atom:link href="/notes/core-java-impatient/index.xml" rel="self" type="application/rss+xml"/><item><title>1. Basic OOP</title><link>/notes/core-java-impatient/1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/1/</guid><description>第一章 基本的编程结构 # 基本类型和变量 # 数字 # 4 字节整型 int 约正负 21 亿，8字节整型 long 约正负 9×10^19，约 900 千亿。4 字节浮点数 float 约 6 位有效数字，范围至正负 10^38 ；8 字节浮点数 double 约 15 位有效数字，范围至正负 10^308。
Integer Byte Short Long Double Float 均有 MAX_VALUE 和 MIN_VALUE 成员变量，指示其边界范围。Float 和 Double 还有 NaN、POSITIVE_INFINITY 和 NEGATIVE_INFINITY 三个静态变量。NaN 之间互不相等。
Java 还提供了 BigInteger 和 BigDemical 两个类，尤其适用于金融。
在部分机器上，如 Intel x86平台，使用 80 bit 的浮点单元来提高浮点运算的精度。如果需要严格的 64 bit 浮点运算，可以在方法前加上 strictfp 修饰符。另外几个不常见的关键字是与多线程有关的 volatile，与序列化有关的 transient 和与跨语言调用有关的 native。此外，StrictMath 类也提供了类似的功能。</description></item><item><title>2. Interface, Lambda</title><link>/notes/core-java-impatient/2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/2/</guid><description>接口 # 在 cast 之前，先使用 instanceof 进行检查。 继承接口 # public interface Closable { void close(); } public interface Channel extends Closable { boolean isOpen(); } 那么，实现 Channel 接口的类必须实现两个方法。
静态方法和默认方法 # 接口中的静态方法是后来才加入到 Java 中的。在这种语法出现之前，这些方法被放到伴随类中。例如，Collection 接口和 Collections 类。接口中的静态方法，意味着这个方法是属于这个接口类型的。因此，必须提供实现。调用时，使用 Interface.method。
可以为方法提供默认的实现，在方法前加上 default 关键字即可。除了提供默认实现之外，这种方式还提供了不同版本间接口变化的可能性。例如，Collection 接口现在新加入了一个有默认方法体的 Stream 方法。如果引入的 class 文件是以前编译的，即其不包含 Stream 方法，将抛出 AbstractMethodError 异常。
在实现多个接口时，可能存在默认方法的冲突。（如果两个接口都不提供默认方法体，因为我们只会实现一个，所以不存在冲突。如果有一个默认方法体，即使另一个方法不提供默认的，也属于冲突情况，因为非默认的方法可能被默认的覆盖。）这时，编译器会报错。我们需要自己解决冲突的情况。
public class Employee implements Person, Identified { public int getId() { // 调用父类型的方法 return Identified.</description></item><item><title>3. Inheritance, Reflection</title><link>/notes/core-java-impatient/3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/3/</guid><description>继承 # Java 中的 super 不是另一个对象的引用，而是绕过动态查找方法的指令。相比之下，this 是一个指向本身的引用。 在方法引用中可以使用 super。new Thread(super::work).start(); 重载方法不能改变参数。可以使用 @Override 让编译器进行检查。 子类无法访问父类的 private 成员。因此，应该在构造时调用父类的构造函数。super(params); 如果一个类的父类中有一个实例方法，实现的接口中有一个同名的默认方法。与接口冲突的情况不同，在这里，父类方法永远先于接口的实现。这是为了与旧版本代码的兼容。 final 方法不能被覆盖，final 类不能被继承。 里氏代换原则 # 里氏代换原则是指，一个父类对象可以出现的位置，也可以放置一个子类对象。
因此，子类重载的方法可以返回父类方法返回值的子类。这被叫做协变返回类型。
Java 的数组同样是协变的。也就是说，一个父类数组引用可以指向一个一个子类数组对象。因此，可能存在这样的问题：
Son[] sons = new Son[0]; Father fathers = sons; fathers[0] = new Father(...) // Exception: ArrayStoreException 在这里，fathers 指向的实际上是一个 Son 类的数组，其中只能存储 Son 类的对象。因此，这里出现了一个编译时无法发现的错误。为了避免这种问题，应当限制协变数组的作用域。
抽象类 # 抽象类的某些方法被声明为抽象的：
abstract class Person { private String id; public Person(String name); public abstract int getId(); } 和接口的区别是，抽象类可以拥有实例变量和构造函数。实现上，我们认为，抽象类是一个可以被具体化的模型，而接口代表的是某一个功能，二者的意义是有区别的。因此，类是单继承的，接口是可以多继承的。</description></item><item><title>4. Exception, Logging</title><link>/notes/core-java-impatient/4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/4/</guid><description>异常 # 异常对象 # RuntimeException 和 CheckedException 继承于 Exception，Exception 和 Error 继承于 Throwable。Error 和 RuntimeException 均属于 Unchecked Exception。
Checked Exception 和 Unchecked Exception 在意义上是存在区别的。例如，有关 IO 和类加载的异常大多是 Checked Exception，因为编写代码时无法判断该异常会不会发生。唯一的办法是捕获并处理它。相比之下，类似 NumberFormatException 这一类异常的发生是可以在代码中进行避免的。因此，属于 Unchecked Exception，需要在代码中进行预防而非捕获。
如果调用可能抛出 Checked Exception，就需要在方法头声明，以便找到最终最适合处理的位置。对于 lambda 表达式也同理。如果 lambda 表达式可能抛出 Checked Exception，就无法被传给一个不抛出异常的函数式接口。好在，大多数情况下，抛出的异常都适合在 lambda 表达式里捕获处理。
在编写自定义的异常类时，建议至少提供两个构造方法：一个无参的方法和一个接受消息字符串的方法。
异常捕获 # 多种异常 # 对于需要处理多种异常的情况，可以分别或一起捕获：
try { ... } catch (ExceptionClass | ExceptionClazz ex) { ex.fun()... } catch (ExClass ex) { .</description></item><item><title>5. Generics</title><link>/notes/core-java-impatient/5/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/5/</guid><description>使用泛型 # 泛型方法 # public class Arrays { public static &amp;lt;T&amp;gt; void swap(T[] array int i, int j) { ... } } // call Arrays.swap(arr, 1 ,2); Arrays.&amp;lt;String&amp;gt; swap(arr, 1, 2); // for better error message 类型限定 # // for an arraylist public static &amp;lt;T extends AutoClosable&amp;gt; void closeAll(ArrayList&amp;lt;T&amp;gt; elems) throws Exception { for (T elem : elems) elem.close(); // an method in interface AutoClosable } //for an array, no need for generic public static void closeAll(AutoClosable[] elems) throws Exception { .</description></item><item><title>6. Collections, Streams</title><link>/notes/core-java-impatient/6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/6/</guid><description>集合 # Collections.nCopies(n, o) 返回一个特殊的内部类 Coolections$CopiesList，能够作为多个拷贝的 List 来使用，但实际只存储一份。 Queue 是一个队列，Deque 是双向队列。 鼓励在代码中使用接口。如 List&amp;lt;T&amp;gt; l = new ArrayList&amp;lt;&amp;gt;()。 同样地，在编写有关集合的代码时，尽量使用接口作为参数，以扩大适用范围。 Collections 的一些静态方法 # 静态方法 功能 boolean disjoint(Collection&amp;lt;?&amp;gt; c1, Collection&amp;lt;?&amp;gt; c2) 判断是否有重复 void copy(List&amp;lt;? super T&amp;gt; dest, List&amp;lt;? extends T&amp;gt; src) 复制 boolean replaceAll(List&amp;lt;T&amp;gt; list, T oldVal, T newVal) 替换 void fill(List&amp;lt;? super T&amp;gt; list, T obj) 填充 int frequency(Collection&amp;lt;?</description></item><item><title>7. IO, Regexp, Serialization</title><link>/notes/core-java-impatient/7/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/7/</guid><description>IO 流 # 创建和使用字节流 # // Create Stream Path path = new Path(&amp;#34;...&amp;#34;) InputStream in = Files.newInputStream(path); OutputStream in = Files.newOutputStream(path); byte[] bytes = ...; InputStream in = new ByteArrayInputStream(bytes); ByteArrayOutputStream out = new ByteArrayOutputStream(); byte[] bytes = out.toByteArray(); // read bytes int b = in.read(); //single byte, 0~255, or -1 for EOF. but byte is -128~127. byte[] bytes = ...; actualBytesRead = in.read(bytes); //read till EOF or byte[] full, return count actualBytesRead = in.</description></item><item><title>8. Threading</title><link>/notes/core-java-impatient/8/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/8/</guid><description>线程和进程 # 线程 # 如果要等待另一个线程完成，使用 join 方法。可以为这个方法加入超时时间。
thread.join(millis); 当 run 方法返回或者抛出异常时，线程结束。每个线程都有自己的异常处理器，默认继承自线程组，通常就是我们熟悉的全局错误处理器。（err 流）可以使用 setUncaughtExceptionHandler 来改变这个处理器。
有时，我们让几个线程执行类似的任务，而最终只需要一个结果，其他的线程都可以被取消。可以在 Runnable 中检查是否中断：
Runnable task = () -&amp;gt; { while (check == true) { if (Thread.currentThread().isInterrupted()) return; ...; } } 实际上，中断（Interrupt）并没有一个非常准确的定义，更多的是程序员自己用来处理一些问题。
如果线程在 wait 等待状态或者 sleep 休眠状态被中断，就会直接抛出 InterruptedException。对于这种情况，可以直接在 Runnable 中使用 try-catch 块进行处理。
Runnable task = () -&amp;gt; { try { ...; } catch (InterruptedException ex) { Thread.currentThread().interrupt(); } } 如果线程在运行中被中断，那么一旦 sleep 被调用，就会立刻抛出异常。很多情况下我们并没有什么可做的，可以考虑直接把线程设置一下中断状态，或者继续将其抛出给真正能够处理的位置。</description></item><item><title>9. Notations</title><link>/notes/core-java-impatient/9/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/notes/core-java-impatient/9/</guid><description>注解 # 注解元素 # @Test(timeout=10000) @BugReport(showStopper=true, assignedTo=&amp;#34;Harry&amp;#34;, testCase=CacheTest.class, status=BugReport.Status.COMFIRMED ) @SuppressWarnings(&amp;#34;unchecked&amp;#34;) // only one parameter, equals @SuppressWarnings(value=&amp;#34;unchecked&amp;#34;) @BugReport(reportedBy={&amp;#34;harry&amp;#34;, &amp;#34;fred&amp;#34;}) // array of above @BugReport(ref=@Reference(id=1123)) // another annotation 注解元素可以是：
基本类型 String class 对象 enum 实例 注解 这些元素的一维数组 元素可以有默认值。例如 JUnit 的 @Test 注解的 timeout 元素默认为 0。
使用注解 # 一个位置可以有多个注解。如果注解被声明为可重复的，甚至可以重复同一个注解多次。
泛型类的类型参数也可以使用注解。在包的 package-info.java 中包含了带有注解的包语句，是包的 Javadoc。
public class Cache&amp;lt;@Immutable V&amp;gt; {} @GPL(version=&amp;#34;3&amp;#34;) package com.</description></item></channel></rss>