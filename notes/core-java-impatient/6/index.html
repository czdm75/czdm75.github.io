<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="集合 #   Collections.nCopies(n, o) 返回一个特殊的内部类 Coolections$CopiesList，能够作为多个拷贝的 List 来使用，但实际只存储一份。 Queue 是一个队列，Deque 是双向队列。 鼓励在代码中使用接口。如 List<T> l = new ArrayList<>()。 同样地，在编写有关集合的代码时，尽量使用接口作为参数，以扩大适用范围。  Collections 的一些静态方法 #     静态方法 功能     boolean disjoint(Collection<?> c1, Collection<?> c2) 判断是否有重复   void copy(List<? super T> dest, List<? extends T> src) 复制   boolean replaceAll(List<T> list, T oldVal, T newVal) 替换   void fill(List<? super T> list, T obj) 填充   int frequency(Collection<?"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="6. Collections, Streams"><meta property="og:description" content="集合 #   Collections.nCopies(n, o) 返回一个特殊的内部类 Coolections$CopiesList，能够作为多个拷贝的 List 来使用，但实际只存储一份。 Queue 是一个队列，Deque 是双向队列。 鼓励在代码中使用接口。如 List<T> l = new ArrayList<>()。 同样地，在编写有关集合的代码时，尽量使用接口作为参数，以扩大适用范围。  Collections 的一些静态方法 #     静态方法 功能     boolean disjoint(Collection<?> c1, Collection<?> c2) 判断是否有重复   void copy(List<? super T> dest, List<? extends T> src) 复制   boolean replaceAll(List<T> list, T oldVal, T newVal) 替换   void fill(List<? super T> list, T obj) 填充   int frequency(Collection<?"><meta property="og:type" content="article"><meta property="og:url" content="/notes/core-java-impatient/6/"><meta property="article:section" content="notes"><title>6. Collections, Streams | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle checked>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/ class=active>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>6. Collections, Streams</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#集合>集合</a><ul><li><a href=#collections-的一些静态方法>Collections 的一些静态方法</a></li><li><a href=#迭代器>迭代器</a></li></ul></li><li><a href=#常见的集合>常见的集合</a><ul><li><a href=#set>Set</a></li><li><a href=#map>Map</a></li><li><a href=#properties---一种-map>Properties - 一种 Map</a></li><li><a href=#bitset>BitSet</a></li><li><a href=#枚举-set-和-map>枚举 Set 和 Map</a></li><li><a href=#队列栈优先级队列>队列，栈，优先级队列</a></li><li><a href=#weakhashmap>WeakHashMap</a></li></ul></li><li><a href=#视图>视图</a></li><li><a href=#流>流</a><ul><li><a href=#创建流>创建流</a></li><li><a href=#流转换>流转换</a></li></ul></li><li><a href=#optional>Optional</a><ul><li><a href=#创建-optional>创建 Optional</a></li><li><a href=#使用-optional>使用 Optional</a></li></ul></li><li><a href=#收集和处理流>收集和处理流</a><ul><li><a href=#收集到集合内>收集到集合内</a></li><li><a href=#归约操作-reduce>归约操作 reduce</a></li><li><a href=#分组分片下游收集器>分组，分片，下游收集器</a></li></ul></li><li><a href=#并行流>并行流</a></li></ul></nav></aside></header><article class=markdown><h1 id=集合>集合
<a class=anchor href=#%e9%9b%86%e5%90%88>#</a></h1><p><img src=../collection-interfaces.png alt="Java Collection Interfaces"></p><ul><li><code>Collections.nCopies(n, o)</code> 返回一个特殊的内部类 <code>Coolections$CopiesList</code>，能够作为多个拷贝的 <code>List</code> 来使用，但实际只存储一份。</li><li><code>Queue</code> 是一个队列，<code>Deque</code> 是双向队列。</li><li>鼓励在代码中使用接口。如 <code>List&lt;T> l = new ArrayList&lt;>()</code>。</li><li>同样地，在编写有关集合的代码时，尽量使用接口作为参数，以扩大适用范围。</li></ul><h2 id=collections-的一些静态方法>Collections 的一些静态方法
<a class=anchor href=#collections-%e7%9a%84%e4%b8%80%e4%ba%9b%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95>#</a></h2><table><thead><tr><th><strong>静态方法</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td><code>boolean disjoint(Collection&lt;?> c1, Collection&lt;?> c2)</code></td><td>判断是否有重复</td></tr><tr><td><code>void copy(List&lt;? super T> dest, List&lt;? extends T> src)</code></td><td>复制</td></tr><tr><td><code>boolean replaceAll(List&lt;T> list, T oldVal, T newVal)</code></td><td>替换</td></tr><tr><td><code>void fill(List&lt;? super T> list, T obj)</code></td><td>填充</td></tr><tr><td><code>int frequency(Collection&lt;?> c, Object o)</code></td><td>数量</td></tr><tr><td><code>int indexOfSubList(List&lt;?> source, List&lt;?> target)</code></td><td>子列表，也有 last方法</td></tr></tbody></table><h2 id=迭代器>迭代器
<a class=anchor href=#%e8%bf%ad%e4%bb%a3%e5%99%a8>#</a></h2><ul><li>由 <code>Iterable&lt;T></code> 定义的方法：<code>Iterator&lt;T> iterator()</code>，使用 <code>hasNext()</code> 和 <code>next()</code> 来访问所有元素。也可以直接使用 foreach 循环。</li><li><code>remove()</code> 方法用来移除<strong>刚刚返回的元素</strong>，而不是现在指向的元素。这意味着，两次 <code>next()</code> 之间只能调用一次 <code>remove()</code>。</li><li><code>ListIterator&lt;T></code> 作为子接口，加入了 <code>set</code> <code>add</code> 和 <code>previous</code> 方法。</li><li>许多非线程安全的集合类的迭代器是 fail-fast 的。这意味着如果其他线程改变了集合，将会抛出 <code>ConcurrentModificationException</code>。</li></ul><h1 id=常见的集合>常见的集合
<a class=anchor href=#%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9b%86%e5%90%88>#</a></h1><h2 id=set>Set
<a class=anchor href=#set>#</a></h2><ul><li><p><code>SortedSet</code> 接口提供顺序访问，<code>NavigableSet</code> 接口提供访问邻居元素的方法。<code>TreeSet</code> 实现了这两个接口。</p></li><li><p><code>HashSet</code> 的性能与元素的 <code>hashCode()</code> 相关。显然，碰撞越弱，性能越好。</p></li><li><p><code>Set</code> 的元素必须实现 <code>Comparable&lt;T></code>，或者在构造函数提供 <code>Comparator&lt;T></code>。</p></li><li><p><code>SortedSet</code> 提供的方法：<code>first()</code> <code>last()</code> <code>headSet()</code> <code>subSet()</code> <code>tailSet</code>。</p></li><li><p><code>NavigableSet</code> 提供的方法：<code>higher()</code> <code>ceiling()</code> <code>floor()</code> <code>lower()</code> <code>pollFirst()</code> <code>pollLast()</code> 等。</p></li></ul><h2 id=map>Map
<a class=anchor href=#map>#</a></h2><ul><li><p><code>TreeSet</code> 提供顺序访问，但性能更弱。</p></li><li><p>当 Key 不存在时，会返回 null。但对于使用了装箱类的 Map，对 null 的拆箱操作就会引发异常。因此，最好使用 <code>getOrDefault()</code> 方法，提供缺省值。</p></li><li><p><code>merge</code> 方法可以用来更新 Map 中的计数器：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>counts<span style=color:#666>.</span><span style=color:#7d9029>merge</span><span style=color:#666>(</span>word<span style=color:#666>,</span> 1<span style=color:#666>,</span> Integer<span style=color:#666>::</span>sum<span style=color:#666>);</span>
</span></span></code></pre></div><p>如果 word 键不存在，就会新建并设为 1。否则，就会加 1。</p></li><li><p><code>HashTable</code> 是线程安全的，不接受 null。相比之下 <code>ConcurrentHashMap</code> 更加实用。</p></li></ul><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td><code>V putIfAbsent(K key, V value)</code></td><td>如果不存在，则插入。如果存在，不修改，返回 Map 内的值。</td></tr><tr><td><code>V compute(K key, V value, BiFunction&lt;...> remappingFunction)</code></td><td>（系列）如果存在 key 的对应 v，就对 v 和传入的 value 进行运算。如果运算结果是 null，就删除 Entry。</td></tr><tr><td><code>V remove(Object key)</code></td><td>删除并返回 value。<code>replace()</code> 类似。</td></tr><tr><td><code>boolean remove(Object key, Object value)</code></td><td>如果 Map 内的 key 和 value 都对应，删除。</td></tr><tr><td><code>Set&lt;K> keySet()</code></td><td>类似的还有 <code>values()</code> <code>entrySet()</code></td></tr></tbody></table><h2 id=properties---一种-map>Properties - 一种 Map
<a class=anchor href=#properties---%e4%b8%80%e7%a7%8d-map>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Properties setings <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> Properties<span style=color:#666>();</span>
</span></span><span style=display:flex><span>settings<span style=color:#666>.</span><span style=color:#7d9029>put</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;width&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;200&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>try</span> <span style=color:#666>(</span>OutputStream out <span style=color:#666>=</span> Files<span style=color:#666>.</span><span style=color:#7d9029>newOutPutStream</span><span style=color:#666>(</span>path<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    settings<span style=color:#666>.</span><span style=color:#7d9029>store</span><span style=color:#666>(</span>out<span style=color:#666>,</span> <span style=color:#ba2121>&#34;ProgramProperties&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>得到：</p><pre tabindex=0><code class=language-properties data-lang=properties>#ProgramProperties
#{DateTime}
width=200
</code></pre><p>Properties 文件是 ASCII 编码的。Unicode 字符将会以 escape 形式（<code>\uxxxx</code>）存储。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>try</span> <span style=color:#666>(</span>InputStream in <span style=color:#666>=</span> Files<span style=color:#666>.</span><span style=color:#7d9029>newInputStream</span><span style=color:#666>(</span>path<span style=color:#666>))</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    settings<span style=color:#666>.</span><span style=color:#7d9029>laod</span><span style=color:#666>(</span>in<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>String title <span style=color:#666>=</span> settings<span style=color:#666>.</span><span style=color:#7d9029>getProperty</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;title&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;defaultValue&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// don&#39;t use get(), for it consumes (Object, Object) rather than String
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>System<span style=color:#666>.</span><span style=color:#7d9029>getProperties</span><span style=color:#666>();</span>  <span style=color:#408080;font-style:italic>// Some system properties
</span></span></span></code></pre></div><h2 id=bitset>BitSet
<a class=anchor href=#bitset>#</a></h2><p>内部实现是一个 <code>long[]</code>，因此效率比 <code>boolean[]</code> 更高。（Java 规范并没有规定 <code>boolean</code> 的大小。）注意这个类并没有实现 <code>Collection&lt;Integer></code> 接口，是一个独立的类。</p><p>提供的方法包括某个或某个范围内的 <code>get</code> <code>set</code> <code>clear</code> <code>flip</code> 等逻辑操作、<code>previous</code> <code>next</code> 等。</p><h2 id=枚举-set-和-map>枚举 Set 和 Map
<a class=anchor href=#%e6%9e%9a%e4%b8%be-set-%e5%92%8c-map>#</a></h2><p><code>EnumSet</code> 包含静态工厂方法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Set<span style=color:#666>&lt;</span>WeekDay<span style=color:#666>&gt;</span> always <span style=color:#666>=</span> EnumSet<span style=color:#666>.</span><span style=color:#7d9029>allOf</span><span style=color:#666>(</span>Weekday<span style=color:#666>.</span><span style=color:#7d9029>class</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>Set<span style=color:#666>&lt;</span>WeekDay<span style=color:#666>&gt;</span> never <span style=color:#666>=</span> EnumSet<span style=color:#666>.</span><span style=color:#7d9029>noneOf</span><span style=color:#666>(</span>Weekday<span style=color:#666>.</span><span style=color:#7d9029>class</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>Set<span style=color:#666>&lt;</span>WeekDay<span style=color:#666>&gt;</span> workday <span style=color:#666>=</span> EnumSet<span style=color:#666>.</span><span style=color:#7d9029>range</span><span style=color:#666>(</span>Weekday<span style=color:#666>.</span><span style=color:#7d9029>MON</span><span style=color:#666>,</span> Weekday<span style=color:#666>.</span><span style=color:#7d9029>FRI</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>Set<span style=color:#666>&lt;</span>WeekDay<span style=color:#666>&gt;</span> three <span style=color:#666>=</span> EnumSet<span style=color:#666>.</span><span style=color:#7d9029>of</span><span style=color:#666>(</span>Weekday<span style=color:#666>.</span><span style=color:#7d9029>MON</span><span style=color:#666>,</span> Weekday<span style=color:#666>.</span><span style=color:#7d9029>TUE</span><span style=color:#666>,</span> Weekday<span style=color:#666>.</span><span style=color:#7d9029>WED</span><span style=color:#666>);</span>
</span></span></code></pre></div><p><code>EnumMap</code> 是以枚举类型为 key，任意指定 value 的 Map。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>EnumMap<span style=color:#666>&lt;</span>Weekday<span style=color:#666>,</span> String<span style=color:#666>&gt;</span> map <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> EnumMap<span style=color:#666>&lt;&gt;(</span>Weekday<span style=color:#666>.</span><span style=color:#7d9029>class</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span>map<span style=color:#666>.</span><span style=color:#7d9029>put</span><span style=color:#666>(</span>WeekDay<span style=color:#666>.</span><span style=color:#7d9029>MON</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;abc&#34;</span><span style=color:#666>);</span>
</span></span></code></pre></div><h2 id=队列栈优先级队列>队列，栈，优先级队列
<a class=anchor href=#%e9%98%9f%e5%88%97%e6%a0%88%e4%bc%98%e5%85%88%e7%ba%a7%e9%98%9f%e5%88%97>#</a></h2><p><code>Stack</code> 类是历史遗留，不应该被使用。通常，使用 <code>Queue</code> 和 <code>Deque</code> 已经足够。如果不关心线程安全，可以直接使用 <code>ArrayDeque</code>。</p><p>优先级队列以任意顺序插入，而只会弹出最小元素。可以用于作业调度，始终弹出优先级最高的任务。使用 <code>add()</code> 和 <code>remove()</code>。</p><h2 id=weakhashmap>WeakHashMap
<a class=anchor href=#weakhashmap>#</a></h2><p>弱哈希表解决这样一个问题：即使 key 已经不再被使用了，由于 Map 对其的引用，它并不会被 GC 掉。技术上说，<code>WeakHashMap</code> 使用 <code>WeakReference</code>。总之，当其唯一引用来自 Map 时，就自动删除。</p><h1 id=视图>视图
<a class=anchor href=#%e8%a7%86%e5%9b%be>#</a></h1><p>集合视图（View）是一个轻量级的集合对象，它可以用来访问元素，但并不储存元素。与 SQL 中的视图非常类似。例如，<code>keySet</code> <code>values</code> <code>Arrays.asList</code> 方法都是这样，其中所有引用的元素都同时被原来的集合引用。这也意味着对这些元素的修改将会体现到原来的集合中。下面是一些常见的视图。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// Ranges
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>List<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> nextFive <span style=color:#666>=</span> sentence<span style=color:#666>.</span><span style=color:#7d9029>subList</span><span style=color:#666>(</span>5<span style=color:#666>,</span> 10<span style=color:#666>)</span><span>；</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// in Navigable interface
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>NavigableSet<span style=color:#666>&lt;</span>E<span style=color:#666>&gt;</span> <span style=color:#00f>headSet</span><span style=color:#666>(</span>E toElement<span style=color:#666>,</span> <span style=color:#b00040>boolean</span> inclusive<span style=color:#666>);</span>
</span></span><span style=display:flex><span>NavigableSet<span style=color:#666>&lt;</span>E<span style=color:#666>&gt;</span> <span style=color:#00f>subSet</span><span style=color:#666>(</span>E fromElement<span style=color:#666>,</span> E toElement<span style=color:#666>,</span> <span style=color:#b00040>boolean</span> inclusive<span style=color:#666>);</span>
</span></span><span style=display:flex><span>NavigableSet<span style=color:#666>&lt;</span>E<span style=color:#666>&gt;</span> <span style=color:#00f>tailSet</span><span style=color:#666>(</span>E fromElement<span style=color:#666>,</span> <span style=color:#b00040>boolean</span> inclusive<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// other set and map, similar
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>SortedSet<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> asOnly <span style=color:#666>=</span> words<span style=color:#666>.</span><span style=color:#7d9029>subSet</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;a&#34;</span><span style=color:#666>,</span> <span style=color:#ba2121>&#34;b&#34;</span><span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//subMap, headMap, tailMap...
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// empty views and singleton views
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Collections<span style=color:#666>.</span><span style=color:#7d9029>emptyMap</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>Collections<span style=color:#666>.</span><span style=color:#7d9029>singletonMap</span><span style=color:#666>();</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// Immutable/readonly views
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Person</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> List<span style=color:#666>&lt;</span>Person<span style=color:#666>&gt;</span> <span style=color:#00f>getFriends</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> Collections<span style=color:#666>.</span><span style=color:#7d9029>unmodifiableList</span><span style=color:#666>(</span>friends<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>这样，在视图上进行插入会抛出异常。另外，由于我们之前看到的泛型的不完全安全性，可以让视图来帮我们检查插入对象的类型：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>List<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> strings <span style=color:#666>=</span> Collections<span style=color:#666>.</span><span style=color:#7d9029>checkedList</span><span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> ArrayList<span style=color:#666>&lt;&gt;(),</span> String<span style=color:#666>.</span><span style=color:#7d9029>class</span><span style=color:#666>);</span>
</span></span></code></pre></div><p><code>Collections</code> 还提供了适合并发的视图，但更加推荐使用 <code>concurrent</code> 包中的数据结构，而非这些视图。</p><h1 id=流>流
<a class=anchor href=#%e6%b5%81>#</a></h1><h2 id=创建流>创建流
<a class=anchor href=#%e5%88%9b%e5%bb%ba%e6%b5%81>#</a></h2><ul><li>流不直接存储数据。它按需生成元素，或者直接引用自集合。</li><li>流不改变源数据。例如，<code>filter</code> 不会删除集合中的元素。</li><li>流可以是延迟执行的，因此也可以是无限的。例如，我们只从流中取出 5 个元素，那么就只会对 5 个元素执行运算。</li><li>由于以上的原因，只要流还没有完全使用结束，就不能修改原集合。否则，行为是未定义的。</li></ul><p>大多数集合可以使用 <code>Collection</code> 接口的 <code>Stream()</code>。<code>parallelStream()</code> 生成一个并行流。</p><p>对于数组，使用静态方法 <code>Stream.of()</code>。这里实际上是一个可变参数，因此把元素一个个传入也是可行的。</p><p><code>Arrays.stream(arrya, from, to)</code> 为数组的一部分生成流。<code>Stream.empty()</code> 返回一个空流。这里会自动进行泛型推断，也可以为方法指定泛型的类型变量 <code>Stream.&lt;String>empty()</code>。</p><p>要创建无限流，可以使用 <code>generate</code> 或 <code>iterate</code> 方法。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Stream<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> echos <span style=color:#666>=</span> Stream<span style=color:#666>.</span><span style=color:#7d9029>generate</span><span style=color:#666>(()</span> <span style=color:#666>-&gt;</span> <span style=color:#ba2121>&#34;Echo&#34;</span><span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>// a Supplier&lt;T&gt;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Stream<span style=color:#666>&lt;</span>Double<span style=color:#666>&gt;</span> ramdoms <span style=color:#666>=</span> Stream<span style=color:#666>.</span><span style=color:#7d9029>generate</span><span style=color:#666>(</span>Math<span style=color:#666>::</span>random<span style=color:#666>);</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Stream<span style=color:#666>&lt;</span>BigInteger<span style=color:#666>&gt;</span> integers <span style=color:#666>=</span> Stream<span style=color:#666>.</span><span style=color:#7d9029>iterate</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    BigInteger<span style=color:#666>.</span><span style=color:#7d9029>ZERO</span><span style=color:#666>,</span> n <span style=color:#666>-&gt;</span> n<span style=color:#666>.</span><span style=color:#7d9029>add</span><span style=color:#666>(</span>BigInteger<span style=color:#666>.</span><span style=color:#7d9029>ONE</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// a seed and an UnaryOperator&lt;T&gt; to apply on it
</span></span></span></code></pre></div><p>除此之外还有很多其他地方的生成流的方法。例如，用于正则表达式的 <code>Pattern</code> 类有一个方法：<code>splitToStream</code> 用来使用正则表达式分割字符串成流。</p><h2 id=流转换>流转换
<a class=anchor href=#%e6%b5%81%e8%bd%ac%e6%8d%a2>#</a></h2><p>对于包含流的流，使用 <code>flatMap</code> 将其展开。<code>limit(n)</code> 用来返回一个包含一定数量元素的子流。<code>skip(n)</code> 与其相反，是跳过前 n 个元素。例如，生成 100 个随机数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Stream<span style=color:#666>&lt;</span>Double<span style=color:#666>&gt;</span> randoms <span style=color:#666>=</span> Stream<span style=color:#666>.</span><span style=color:#7d9029>generate</span><span style=color:#666>(</span>Math<span style=color:#666>::</span>random<span style=color:#666>).</span><span style=color:#7d9029>limit</span><span style=color:#666>(</span>100<span style=color:#666>);</span>
</span></span></code></pre></div><p><code>Stream.concat</code> 将两个流连接起来。当然，这时第一个流不能是无限的。</p><p><code>sorted</code> 用来对流进行排序。可以使用 <code>Comparator</code>，也可以接收 <code>Comparable</code> 对象。</p><p>最后，<code>peek</code> 方法是一个 &ldquo;透明的&rdquo; 流，不改变流的内容，适合用来打印调试信息甚至打断点：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>intStream<span style=color:#666>.</span><span style=color:#7d9029>peek</span><span style=color:#666>(</span>System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>::</span>println<span style=color:#666>).</span><span style=color:#7d9029>limit</span><span style=color:#666>(</span>20<span style=color:#666>).</span><span style=color:#7d9029>toArray</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>这样，将会打印 20 个随机数，并生成相应的数组。这里也可以看出之前说的延迟执行特性。</p><h1 id=optional>Optional
<a class=anchor href=#optional>#</a></h1><h2 id=创建-optional>创建 Optional
<a class=anchor href=#%e5%88%9b%e5%bb%ba-optional>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Optional<span style=color:#666>.</span><span style=color:#7d9029>empty</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>Optional<span style=color:#666>.</span><span style=color:#7d9029>of</span><span style=color:#666>(</span>obj<span style=color:#666>);</span>
</span></span><span style=display:flex><span>Optional<span style=color:#666>.</span><span style=color:#7d9029>ofNullable</span><span style=color:#666>(</span>obj<span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>// empty if null
</span></span></span></code></pre></div><h2 id=使用-optional>使用 Optional
<a class=anchor href=#%e4%bd%bf%e7%94%a8-optional>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>String s <span style=color:#666>=</span> opt<span style=color:#666>.</span><span style=color:#7d9029>get</span><span style=color:#666>();</span>  <span style=color:#408080;font-style:italic>// if empty, throw NoSuchElementException
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>String s <span style=color:#666>=</span> opt<span style=color:#666>.</span><span style=color:#7d9029>orElse</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;&#34;</span><span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>// default value
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>String s <span style=color:#666>=</span> opt<span style=color:#666>.</span><span style=color:#7d9029>orElseGet</span><span style=color:#666>(()</span> <span style=color:#666>-&gt;</span> System<span style=color:#666>.</span><span style=color:#7d9029>getProperty</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;user.dir&#34;</span><span style=color:#666>));</span>  <span style=color:#408080;font-style:italic>// calculate default
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>String s <span style=color:#666>=</span> opt<span style=color:#666>.</span><span style=color:#7d9029>orElseThrow</span><span style=color:#666>(</span>IllegalStateException<span style=color:#666>::</span><span style=color:green;font-weight:700>new</span><span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>// throw an exception
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// use value in optional, or do nothing
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>opt<span style=color:#666>.</span><span style=color:#7d9029>ifPresent</span><span style=color:#666>(</span>results<span style=color:#666>::</span>add<span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>// return void
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// or check the return value
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Optional<span style=color:#666>&lt;</span>Boolean<span style=color:#666>&gt;</span> added <span style=color:#666>=</span> opt<span style=color:#666>.</span><span style=color:#7d9029>map</span><span style=color:#666>(</span>results<span style=color:#666>::</span>add<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//now added may be true or false(return of add) or empty optional(if opt is empty)
</span></span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> Optional<span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span> <span style=color:#00f>f</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#666>...</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//in the T class
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Optional<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span> <span style=color:#00f>g</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#666>...</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>Optional<span style=color:#666>&lt;</span>U<span style=color:#666>&gt;</span> result <span style=color:#666>=</span> s<span style=color:#666>.</span><span style=color:#7d9029>f</span><span style=color:#666>().</span><span style=color:#7d9029>flatMap</span><span style=color:#666>(</span>T<span style=color:#666>::</span>g<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// s.f() returns a Optional&lt;T&gt;, flatMap to T , then T::g
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// overall ,if s.f() presents, call g. otherwise, return empty Optinal&lt;U&gt;
</span></span></span></code></pre></div><p>显然，这种方式可以链式地调用，任何一步返回 empty 都会终止。</p><h1 id=收集和处理流>收集和处理流
<a class=anchor href=#%e6%94%b6%e9%9b%86%e5%92%8c%e5%a4%84%e7%90%86%e6%b5%81>#</a></h1><h2 id=收集到集合内>收集到集合内
<a class=anchor href=#%e6%94%b6%e9%9b%86%e5%88%b0%e9%9b%86%e5%90%88%e5%86%85>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>stream<span style=color:#666>.</span><span style=color:#7d9029>toArray</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>toList</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>toSet</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>toCollection</span><span style=color:#666>(</span>TreeSet<span style=color:#666>::</span><span style=color:green;font-weight:700>new</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// collect to string
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>String result <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>joining</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>String result <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>joining</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;\t&#34;</span><span style=color:#666>));</span>
</span></span><span style=display:flex><span>String result <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>map</span><span style=color:#666>(</span>Object<span style=color:#666>::</span>toString<span style=color:#666>).</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>joining</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// same with long and double, sum and min and such
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>IntSummaryStatics summary <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>summarizingInt</span><span style=color:#666>(</span>String<span style=color:#666>::</span>length<span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#b00040>double</span> averageLength <span style=color:#666>=</span> summary<span style=color:#666>.</span><span style=color:#7d9029>getAverage</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#b00040>double</span> maxLength <span style=color:#666>=</span> summary<span style=color:#666>.</span><span style=color:#7d9029>getMax</span><span style=color:#666>();</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// collect to Map
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Map<span style=color:#666>&lt;</span>Integer<span style=color:#666>,</span> String<span style=color:#666>&gt;</span> idToName <span style=color:#666>=</span> people<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Collectors<span style=color:#666>.</span><span style=color:#7d9029>toMap</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getId<span style=color:#666>,</span> Person<span style=color:#666>::</span>getName<span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// or
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Map<span style=color:#666>&lt;</span>Integer<span style=color:#666>,</span> Person<span style=color:#666>&gt;</span> idToPerson <span style=color:#666>=</span> people<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Collectors<span style=color:#666>.</span><span style=color:#7d9029>toMap</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getId<span style=color:#666>,</span> Function<span style=color:#666>.</span><span style=color:#7d9029>identity</span><span style=color:#666>()));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// thows IllegalStateException if has same ids, or
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>toMap</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getId<span style=color:#666>,</span> Function<span style=color:#666>.</span><span style=color:#7d9029>identity</span><span style=color:#666>,</span>
</span></span><span style=display:flex><span>                 <span style=color:#666>(</span>exsitingVal<span style=color:#666>,</span> newVal<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> existingVal<span style=color:#666>);</span>  <span style=color:#408080;font-style:italic>//to keep the old one
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// if you want to specify the map, since it is the 4th param, must write the 3rd
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>toMap</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getId<span style=color:#666>,</span> Function<span style=color:#666>.</span><span style=color:#7d9029>identity</span><span style=color:#666>,</span>
</span></span><span style=display:flex><span>                 <span style=color:#666>(</span>exsitingVal<span style=color:#666>,</span> newVal<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> existingVal<span style=color:#666>,</span> TreeMap<span style=color:#666>::</span><span style=color:green;font-weight:700>new</span><span style=color:#666>);</span>
</span></span></code></pre></div><p>另外还有相应的 <code>toConcurrentMap</code> 方法。</p><h2 id=归约操作-reduce>归约操作 reduce
<a class=anchor href=#%e5%bd%92%e7%ba%a6%e6%93%8d%e4%bd%9c-reduce>#</a></h2><p>之前见到的<code>count</code> 方法就是一个简单的归约操作。类似地，<code>max</code> <code>min</code> 返回流中的最大值和最小值，返回一个 <code>Optional&lt;T></code> 对象。当流为空的时候，就不会返回 null。除此之外，还有 <code>findAny</code> 匹配，以及经常和 <code>filter</code> 一起使用的 <code>findFirst</code>。</p><p>如果需要知道流中是否含有匹配元素，使用 <code>anyMatch</code> 方法接受一个 <code>predicate&lt;T></code>，返回 <code>boolean</code>。类似的还有 <code>noneMatch</code>。</p><p>除此之外，还常常使用 <code>forEach</code>，或者在并行流上可能需要 <code>forEachOrdered</code>。这时是为了使用代码的 &ldquo;副作用&rdquo;。</p><p>此外，Java 提供了强大的 <code>reduce</code> 方法。简单地说，它接收一个二元操作，并对所有元素连续进行这个操作。操作必须满足结合律。这类操作包括最大值最小值、加法、拼接等。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// sum of all elements, empty if stream is empty
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Optional<span style=color:#666>&lt;</span>Integer<span style=color:#666>&gt;</span> sum <span style=color:#666>=</span> values<span style=color:#666>.</span><span style=color:#7d9029>stream</span><span style=color:#666>().</span><span style=color:#7d9029>reduce</span><span style=color:#666>((</span>x<span style=color:#666>,</span> y<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> x <span style=color:#666>+</span> y<span style=color:#666>);</span>
</span></span><span style=display:flex><span>Optional<span style=color:#666>&lt;</span>Integer<span style=color:#666>&gt;</span> sum <span style=color:#666>=</span> values<span style=color:#666>.</span><span style=color:#7d9029>stream</span><span style=color:#666>().</span><span style=color:#7d9029>reduce</span><span style=color:#666>(</span>Integer<span style=color:#666>::</span>sum<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// or offer an &#34;start point&#34;, 0 for add, 1 for multiply, etc. act as default value.
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>int</span> sum <span style=color:#666>=</span> values<span style=color:#666>.</span><span style=color:#7d9029>stream</span><span style=color:#666>().</span><span style=color:#7d9029>reduce</span><span style=color:#666>(</span>0<span style=color:#666>,</span> Integer<span style=color:#666>::</span>sum<span style=color:#666>);</span>
</span></span></code></pre></div><p>这里，0充当的是运算的起点，即单位元的作用。对于累加是 0，对于累乘就应当是 1。不过，<code>reduce</code> 只能接收一个 <code>(T, T) -> T</code> 类型的方法，即二元操作。如果要进行更复杂的操作：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Optional<span style=color:#666>&lt;</span>Integer<span style=color:#666>&gt;</span> result <span style=color:#666>=</span> words<span style=color:#666>.</span><span style=color:#7d9029>reduce</span><span style=color:#666>((</span>total<span style=color:#666>,</span> word<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> total <span style=color:#666>+</span> word<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>(),</span>
</span></span><span style=display:flex><span>                                        <span style=color:#666>(</span>total1 <span style=color:#666>,</span>total2<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> total1 <span style=color:#666>+</span> total2<span style=color:#666>);</span>
</span></span></code></pre></div><p>这是说，我们需要进行两类累加操作，并分别提供函数。当然，这种情况下将其 map 到一个 <code>IntStream</code> 再处理要简单得多。</p><p>Java 中提供了三种基本类型流 <code>IntStream</code> <code>LongStream</code> <code>DoubleStream</code>，它们的 <code>toArray</code> 得到的是基本类型数组，具有 <code>max</code> <code>sum</code> <code>average</code> 等方法，并可能返回 <code>OptinalInt</code> 等类型。</p><h2 id=分组分片下游收集器>分组，分片，下游收集器
<a class=anchor href=#%e5%88%86%e7%bb%84%e5%88%86%e7%89%87%e4%b8%8b%e6%b8%b8%e6%94%b6%e9%9b%86%e5%99%a8>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#666>&lt;</span>String<span style=color:#666>,</span> List<span style=color:#666>&lt;</span>Locale<span style=color:#666>&gt;&gt;</span> contryToLocales <span style=color:#666>=</span> locales<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Collectors<span style=color:#666>.</span><span style=color:#7d9029>groupingBy</span><span style=color:#666>(</span>Locale<span style=color:#666>::</span>getCountry<span style=color:#666>));</span>  <span style=color:#408080;font-style:italic>// group by country
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// while group by boolean, faster method
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Map<span style=color:#666>&lt;</span>Boolean<span style=color:#666>,</span> List<span style=color:#666>&lt;</span>Locale<span style=color:#666>&gt;&gt;</span> englishAndOthers <span style=color:#666>=</span> locales<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Collectors<span style=color:#666>.</span><span style=color:#7d9029>partitioningBy</span><span style=color:#666>(</span>l <span style=color:#666>-&gt;</span> l<span style=color:#666>.</span><span style=color:#7d9029>getLanguage</span><span style=color:#666>().</span><span style=color:#7d9029>equals</span><span style=color:#666>(</span><span style=color:#ba2121>&#34;en&#34;</span><span style=color:#666>)));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// concurrent map
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>groupingByConcurrent</span><span style=color:#666>(</span>Locale<span style=color:#666>::</span>getCountry<span style=color:#666>);</span>
</span></span></code></pre></div><p>上面都是默认使用了 <code>List</code> 作为 Map 的 value。如果要使用其他的，比如 Set，可以提供一个下游收集器（downstream collector）。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Map<span style=color:#666>&lt;</span>String<span style=color:#666>,</span> List<span style=color:#666>&lt;</span>Locale<span style=color:#666>&gt;&gt;</span> contryToLocales <span style=color:#666>=</span> locales<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Collectors<span style=color:#666>.</span><span style=color:#7d9029>groupingBy</span><span style=color:#666>(</span>Locale<span style=color:#666>::</span>getCountry<span style=color:#666>,</span> Collectors<span style=color:#666>.</span><span style=color:#7d9029>toSet</span><span style=color:#666>()));</span>
</span></span></code></pre></div><p>类似这里 <code>toSet</code> 用法的还包括：<code>counting</code> <code>summing</code> <code>maxBy(Comparator)</code> <code>minBy(Comparator)</code>，以及比较复杂的 <code>mapping</code>。也有相应的 <code>groupingByConcurrent</code> 等。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.util.stream.Collectors.*</span>
</span></span><span style=display:flex><span>Map<span style=color:#666>&lt;</span>String<span style=color:#666>,</span> Set<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;&gt;</span> counttryToLangs <span style=color:#666>=</span> locales<span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>    groupingBy<span style=color:#666>(</span>Locale<span style=color:#666>::</span>getCountry<span style=color:#666>,</span> mapping<span style=color:#666>(</span>Locale<span style=color:#666>::</span>getDisplayLanguage<span style=color:#666>,</span> toSet<span style=color:#666>())));</span>
</span></span></code></pre></div><p>如果返回的值是 <code>int</code> <code>long</code> <code>double</code>，就可以用上面出现的 <code>summarizingInt</code> 系列方法来替代 <code>toSet</code> 进行统计。</p><p>当然，下游收集器这种方法只适合在使用 <code>groupingBy</code> 和 <code>partitioningBy</code> 时使用，否则只需要直接对流使用归约 <code>max</code> <code>count</code> <code>reduce</code> 等即可。</p><h1 id=并行流>并行流
<a class=anchor href=#%e5%b9%b6%e8%a1%8c%e6%b5%81>#</a></h1><p>获得并行流：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>words<span style=color:#666>.</span><span style=color:#7d9029>parallelStream</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>Stream<span style=color:#666>.</span><span style=color:#7d9029>of</span><span style=color:#666>(</span>wordArr<span style=color:#666>).</span><span style=color:#7d9029>parallel</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>显然，并行流中的操作不应该使用共享的内容。也就是说，所有操作都应当是无状态的，可以以任意顺序执行。例如，对字符串中的单词长度进行计数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// WRONG way
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#b00040>int</span><span style=color:#666>[]</span> shortWords <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> in<span style=color:#666>[</span>12<span style=color:#666>];</span>
</span></span><span style=display:flex><span>words<span style=color:#666>.</span><span style=color:#7d9029>parallelStream</span><span style=color:#666>().</span><span style=color:#7d9029>foreach</span><span style=color:#666>(</span>s <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>if</span> <span style=color:#666>(</span>s<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>()</span> <span style=color:#666>&lt;</span> 12<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        shortWords<span style=color:#666>[</span>s<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>()]++;</span>  <span style=color:#408080;font-style:italic>// competing condition
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>});</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//Right Way
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Map<span style=color:#666>&lt;</span>Integer<span style=color:#666>,</span> Long<span style=color:#666>&gt;</span> shortWordCounts <span style=color:#666>=</span> words<span style=color:#666>.</span><span style=color:#7d9029>parallelStream</span><span style=color:#666>()</span>
</span></span><span style=display:flex><span>    <span style=color:#666>.</span><span style=color:#7d9029>filter</span><span style=color:#666>(</span>s <span style=color:#666>-&gt;</span> s<span style=color:#666>.</span><span style=color:#7d9029>length</span> <span style=color:#666>&lt;</span> 12<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    <span style=color:#666>.</span><span style=color:#7d9029>collect</span><span style=color:#666>(</span>Collectors<span style=color:#666>.</span><span style=color:#7d9029>groupingBy</span><span style=color:#666>(</span>String<span style=color:#666>::</span>length<span style=color:#666>,</span> counting<span style=color:#666>()));</span>
</span></span></code></pre></div><p>默认，来自有序集合、range、生成器、迭代器和 <code>sorted</code> 得到的流都是有序的。有序不影响并行。但如果顺序不重要，可以使用 <code>unordered</code> 来提高性能。例如使用 <code>limit</code> 来取出几个元素但并不在乎是哪几个时。又比如，使用 <code>distinct</code> 来让流所有元素保持唯一时。</p><p>又比如使用上面的 <code>groupingBy</code> 操作时，代价相当高。但如果使用 <code>groupingByConcurrent</code>，虽然使元素成为无序的，但可以进行并行操作，提高性能。如果你不是用与顺序有关的下游收集器，就无需考虑顺序问题。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#集合>集合</a><ul><li><a href=#collections-的一些静态方法>Collections 的一些静态方法</a></li><li><a href=#迭代器>迭代器</a></li></ul></li><li><a href=#常见的集合>常见的集合</a><ul><li><a href=#set>Set</a></li><li><a href=#map>Map</a></li><li><a href=#properties---一种-map>Properties - 一种 Map</a></li><li><a href=#bitset>BitSet</a></li><li><a href=#枚举-set-和-map>枚举 Set 和 Map</a></li><li><a href=#队列栈优先级队列>队列，栈，优先级队列</a></li><li><a href=#weakhashmap>WeakHashMap</a></li></ul></li><li><a href=#视图>视图</a></li><li><a href=#流>流</a><ul><li><a href=#创建流>创建流</a></li><li><a href=#流转换>流转换</a></li></ul></li><li><a href=#optional>Optional</a><ul><li><a href=#创建-optional>创建 Optional</a></li><li><a href=#使用-optional>使用 Optional</a></li></ul></li><li><a href=#收集和处理流>收集和处理流</a><ul><li><a href=#收集到集合内>收集到集合内</a></li><li><a href=#归约操作-reduce>归约操作 reduce</a></li><li><a href=#分组分片下游收集器>分组，分片，下游收集器</a></li></ul></li><li><a href=#并行流>并行流</a></li></ul></nav></div></aside></main></body></html>