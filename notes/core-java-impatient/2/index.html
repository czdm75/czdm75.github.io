<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="接口 #   在 cast 之前，先使用 instanceof 进行检查。  继承接口 #  public interface Closable {  void close(); }  public interface Channel extends Closable {  boolean isOpen(); } 那么，实现 Channel 接口的类必须实现两个方法。
静态方法和默认方法 #  接口中的静态方法是后来才加入到 Java 中的。在这种语法出现之前，这些方法被放到伴随类中。例如，Collection 接口和 Collections 类。接口中的静态方法，意味着这个方法是属于这个接口类型的。因此，必须提供实现。调用时，使用 Interface.method。
可以为方法提供默认的实现，在方法前加上 default 关键字即可。除了提供默认实现之外，这种方式还提供了不同版本间接口变化的可能性。例如，Collection 接口现在新加入了一个有默认方法体的 Stream 方法。如果引入的 class 文件是以前编译的，即其不包含 Stream 方法，将抛出 AbstractMethodError 异常。
在实现多个接口时，可能存在默认方法的冲突。（如果两个接口都不提供默认方法体，因为我们只会实现一个，所以不存在冲突。如果有一个默认方法体，即使另一个方法不提供默认的，也属于冲突情况，因为非默认的方法可能被默认的覆盖。）这时，编译器会报错。我们需要自己解决冲突的情况。
public class Employee implements Person, Identified {  public int getId() {  // 调用父类型的方法  return Identified."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="2. Interface, Lambda"><meta property="og:description" content="接口 #   在 cast 之前，先使用 instanceof 进行检查。  继承接口 #  public interface Closable {  void close(); }  public interface Channel extends Closable {  boolean isOpen(); } 那么，实现 Channel 接口的类必须实现两个方法。
静态方法和默认方法 #  接口中的静态方法是后来才加入到 Java 中的。在这种语法出现之前，这些方法被放到伴随类中。例如，Collection 接口和 Collections 类。接口中的静态方法，意味着这个方法是属于这个接口类型的。因此，必须提供实现。调用时，使用 Interface.method。
可以为方法提供默认的实现，在方法前加上 default 关键字即可。除了提供默认实现之外，这种方式还提供了不同版本间接口变化的可能性。例如，Collection 接口现在新加入了一个有默认方法体的 Stream 方法。如果引入的 class 文件是以前编译的，即其不包含 Stream 方法，将抛出 AbstractMethodError 异常。
在实现多个接口时，可能存在默认方法的冲突。（如果两个接口都不提供默认方法体，因为我们只会实现一个，所以不存在冲突。如果有一个默认方法体，即使另一个方法不提供默认的，也属于冲突情况，因为非默认的方法可能被默认的覆盖。）这时，编译器会报错。我们需要自己解决冲突的情况。
public class Employee implements Person, Identified {  public int getId() {  // 调用父类型的方法  return Identified."><meta property="og:type" content="article"><meta property="og:url" content="/notes/core-java-impatient/2/"><meta property="article:section" content="notes"><title>2. Interface, Lambda | czdm75 Blog</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.97cfda4f5e3c9fa49a2bf8d401f4ddc0eec576c99cdcf6afbec19173200c37db.css><script defer src=/flexsearch.min.js></script>
<script defer src=/en.search.min.60f5c0362a1b15384bf6fbb748ad6fb49d79819ad4313fc4618ffb6d1f645f15.js></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>czdm75 Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-25b8c894ab868b34ecd6cce0ce4c79c7 class=toggle>
<label for=section-25b8c894ab868b34ecd6cce0ce4c79c7 class="flex justify-between"><a href=/cs/>Computer Science</a></label><ul><li><a href=/cs/linux-io-multiplex/>Linux IO Multiplexing</a></li></ul></li><li><input type=checkbox id=section-d5643d9c227c9fc0bfaa81dc6e0249af class=toggle>
<label for=section-d5643d9c227c9fc0bfaa81dc6e0249af class="flex justify-between"><a href=/distributed/>Distributed Systems</a></label><ul><li><a href=/distributed/hadoop-basic/>Hadoop Basic Concepts</a></li><li><a href=/distributed/spark-rdd/>Spark RDD Programming</a></li><li><a href=/distributed/spark-sql/>Spark SQL Programming</a></li></ul></li><li><a href=/notes/>Notes on Books</a><ul><li><input type=checkbox id=section-f9c54ee28ad742882651b9afb106f923 class=toggle checked>
<label for=section-f9c54ee28ad742882651b9afb106f923 class="flex justify-between"><a href=/notes/core-java-impatient/>Core Java for Impatients</a></label><ul><li><a href=/notes/core-java-impatient/1/>1. Basic OOP</a></li><li><a href=/notes/core-java-impatient/2/ class=active>2. Interface, Lambda</a></li><li><a href=/notes/core-java-impatient/3/>3. Inheritance, Reflection</a></li><li><a href=/notes/core-java-impatient/4/>4. Exception, Logging</a></li><li><a href=/notes/core-java-impatient/5/>5. Generics</a></li><li><a href=/notes/core-java-impatient/6/>6. Collections, Streams</a></li><li><a href=/notes/core-java-impatient/7/>7. IO, Regexp, Serialization</a></li><li><a href=/notes/core-java-impatient/8/>8. Threading</a></li><li><a href=/notes/core-java-impatient/9/>9. Notations</a></li></ul></li><li><input type=checkbox id=section-9d0fb26a4934bb77406a56b94138590b class=toggle>
<label for=section-9d0fb26a4934bb77406a56b94138590b class="flex justify-between"><a href=/notes/in-depth-jvm/>In-depth Understanding JVM</a></label><ul><li><a href=/notes/in-depth-jvm/gc/>Garbage Collection</a></li><li><a href=/notes/in-depth-jvm/synchronization/>Java Synchronization</a></li><li><a href=/notes/in-depth-jvm/memory-model/>JVM Memory Model</a></li><li><a href=/notes/in-depth-jvm/memory-region/>JVM Memory Regions</a></li><li><a href=/notes/in-depth-jvm/threadlocal-reference/>ThreadLocal and Reference</a></li></ul></li><li><input type=checkbox id=section-4d028229be962782539eef651433109e class=toggle>
<label for=section-4d028229be962782539eef651433109e class="flex justify-between"><a href=/notes/intro-algo/>Introduction to Algorithms</a></label><ul><li><a href=/notes/intro-algo/1/>1. Compexity, Divide</a></li><li><a href=/notes/intro-algo/2/>2. Sorting, Order Statistic</a></li><li><a href=/notes/intro-algo/3/>3. LinkedList, HashTable</a></li><li><a href=/notes/intro-algo/4/>4. BST, Balanced BSTs</a></li><li><a href=/notes/intro-algo/5/>5. Trie-Tree, Extending Data Structures</a></li><li><a href=/notes/intro-algo/6/>6. Dynamic Programming, Greedy, Amortize</a></li><li><a href=/notes/intro-algo/7/>7. B-Tree, Fibonacci Heap, vEB Tree</a></li><li><a href=/notes/intro-algo/8/>8. Graphs</a></li></ul></li><li><input type=checkbox id=section-76be9453a58f37863458b83352d3ff3c class=toggle>
<label for=section-76be9453a58f37863458b83352d3ff3c class="flex justify-between"><a href=/notes/programming-scala/>Programming in Scala</a></label><ul><li><a href=/notes/programming-scala/1/>1. Basics</a></li><li><a href=/notes/programming-scala/2/>2. Functions</a></li><li><a href=/notes/programming-scala/3/>3 .Inheritance, Package, Assertion</a></li><li><a href=/notes/programming-scala/4/>4. Pattern Matching, Collections</a></li><li><a href=/notes/programming-scala/5/>5. Generics, Abstract, Implicits</a></li><li><a href=/notes/programming-scala/6/>6. Collections, Extractor, etc</a></li></ul></li></ul></li><li><input type=checkbox id=section-9784d97422a8bbe41d06f74a08150515 class=toggle>
<label for=section-9784d97422a8bbe41d06f74a08150515 class="flex justify-between"><a href=/pl/>Programming Languages</a></label><ul><li><a href=/pl/java-nio-2/>Java NIO Internal</a></li><li><a href=/pl/java-nio-1/>Java NIO Usage</a></li><li><a href=/pl/lambda/>Lambda Calculus and Y Combinator</a></li><li><a href=/pl/curry/>Scala: Currying, Partially Applied, Partial</a></li><li><a href=/pl/monad/>Scala: Monad, from Scala Perspective</a></li></ul></li></ul><ul><li><a href=https://github.com/czdm75 target=_blank rel=noopener>GitHub</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Theme</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>2. Interface, Lambda</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#接口>接口</a><ul><li><a href=#继承接口>继承接口</a></li><li><a href=#静态方法和默认方法>静态方法和默认方法</a></li></ul></li><li><a href=#常用的接口>常用的接口</a><ul><li><a href=#comparable>Comparable</a></li><li><a href=#comparator>Comparator</a></li><li><a href=#runnable>Runnable</a></li></ul></li><li><a href=#lambda-表达式和方法引用>lambda 表达式和方法引用</a><ul><li><a href=#lambda-表达式>lambda 表达式</a><ul><li><a href=#通用的函数式接口>通用的函数式接口</a></li><li><a href=#lambda-表达式和变量作用域>lambda 表达式和变量作用域</a></li><li><a href=#闭包>闭包</a></li></ul></li><li><a href=#方法引用>方法引用</a><ul><li><a href=#形式>形式</a></li><li><a href=#构造函数的引用>构造函数的引用</a></li></ul></li></ul></li><li><a href=#高阶函数>高阶函数</a><ul><li><a href=#comparator-方法>Comparator 方法</a></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=接口>接口
<a class=anchor href=#%e6%8e%a5%e5%8f%a3>#</a></h1><ul><li>在 cast 之前，先使用 <code>instanceof</code> 进行检查。</li></ul><h2 id=继承接口>继承接口
<a class=anchor href=#%e7%bb%a7%e6%89%bf%e6%8e%a5%e5%8f%a3>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Closable</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>void</span> <span style=color:#00f>close</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Channel</span> <span style=color:green;font-weight:700>extends</span> Closable <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>boolean</span> <span style=color:#00f>isOpen</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>那么，实现 <code>Channel</code> 接口的类必须实现两个方法。</p><h2 id=静态方法和默认方法>静态方法和默认方法
<a class=anchor href=#%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95%e5%92%8c%e9%bb%98%e8%ae%a4%e6%96%b9%e6%b3%95>#</a></h2><p>接口中的静态方法是后来才加入到 Java 中的。在这种语法出现之前，这些方法被放到伴随类中。例如，<code>Collection</code> 接口和 <code>Collections</code> 类。接口中的静态方法，意味着这个方法是属于这个接口类型的。因此，<strong>必须提供实现</strong>。调用时，使用 <code>Interface.method</code>。</p><p>可以为方法提供默认的实现，在方法前加上 <code>default</code> 关键字即可。除了提供默认实现之外，这种方式还提供了不同版本间接口变化的可能性。例如，<code>Collection</code> 接口现在新加入了一个有默认方法体的 <code>Stream</code> 方法。如果引入的 class 文件是以前编译的，即其不包含 <code>Stream</code> 方法，将抛出 <code>AbstractMethodError</code> 异常。</p><p>在实现多个接口时，可能存在默认方法的冲突。（如果两个接口都不提供默认方法体，因为我们只会实现一个，所以不存在冲突。如果有一个默认方法体，即使另一个方法不提供默认的，也属于冲突情况，因为非默认的方法可能被默认的覆盖。）这时，编译器会报错。我们需要自己解决冲突的情况。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Employee</span> <span style=color:green;font-weight:700>implements</span> Person<span style=color:#666>,</span> Identified <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>int</span> <span style=color:#00f>getId</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>// 调用父类型的方法
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        <span style=color:green;font-weight:700>return</span> Identified<span style=color:#666>.</span><span style=color:#7d9029>super</span><span style=color:#666>.</span><span style=color:#7d9029>getId</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h1 id=常用的接口>常用的接口
<a class=anchor href=#%e5%b8%b8%e7%94%a8%e7%9a%84%e6%8e%a5%e5%8f%a3>#</a></h1><h2 id=comparable>Comparable
<a class=anchor href=#comparable>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Comparable</span><span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>int</span> <span style=color:#00f>compareTo</span><span style=color:#666>(</span>T other<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>在实现这个方法时，如果打算返回两个值的差，最好使用 <code>Integer.compare()</code> 和 <code>Double.compare()</code> 方法，这样可以避免溢出的情况，并正确地处理 NaN 和无穷。对于实现了这个接口的类，可以使用 <code>Arrays.sort</code> 方法来进行排序。</p><h2 id=comparator>Comparator
<a class=anchor href=#comparator>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>LengthComparator</span> <span style=color:green;font-weight:700>implements</span> Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>int</span> <span style=color:#00f>compare</span><span style=color:#666>(</span>String o1<span style=color:#666>,</span> String o2<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>return</span> o1<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>()</span> <span style=color:#666>-</span> o2<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> comp <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> LengthComparator<span style=color:#666>();</span>
</span></span><span style=display:flex><span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>arr<span style=color:#666>,</span> comp<span style=color:#666>);</span>
</span></span></code></pre></div><p>更方便的使用这个接口的方法是 lambda 表达式。</p><h2 id=runnable>Runnable
<a class=anchor href=#runnable>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Runnable</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>void</span> <span style=color:#00f>run</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Callable</span><span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> T <span style=color:#00f>call</span><span style=color:#666>()</span> <span style=color:green;font-weight:700>throws</span> Exception<span style=color:#666>;</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Task</span> <span style=color:green;font-weight:700>implements</span> Runnable <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>void</span> <span style=color:#00f>run</span><span style=color:#666>()</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:green;font-weight:700>new</span> Thread<span style=color:#666>(</span><span style=color:green;font-weight:700>new</span> Task<span style=color:#666>).</span><span style=color:#7d9029>start</span><span style=color:#666>();</span>
</span></span></code></pre></div><p>任务将在新的线程里运行。这个接口同样适合使用 lambda 表达式。<code>Callable&lt;T></code> 的作用类似，有返回值，并可以抛出异常。</p><h1 id=lambda-表达式和方法引用>lambda 表达式和方法引用
<a class=anchor href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f%e5%92%8c%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8>#</a></h1><p>lambda 表达式的核心目的是延迟执行。例如，将比较操作延迟到排序算法中，将操作延迟到遍历过程中，将一个调用延迟到另一个线程中，绑定回调函数等。总之，lambda 表达式的书写者不再需要考虑其调用。</p><h2 id=lambda-表达式>lambda 表达式
<a class=anchor href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f>#</a></h2><p>lambda 表达式被用来代替<strong>函数式接口</strong>，即只有一个抽象方法的接口。在 Java 中，lambda 表达式是这样实现的：表达式 <code>(Class param) -> {...}</code> 相当于一个继承了函数式接口的对象的实例。例如，可以使用这样的用法：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Function<span style=color:#666>&lt;</span>Integer<span style=color:#666>,</span> Integer<span style=color:#666>&gt;</span> times2 <span style=color:#666>=</span> e <span style=color:#666>-&gt;</span> e <span style=color:#666>*</span> 2<span style=color:#666>;</span>
</span></span></code></pre></div><p>如果要编写自己的函数式接口，建议使用注解 <code>@FunctionalInterface</code> 提示编译器进行检查。</p><h3 id=通用的函数式接口>通用的函数式接口
<a class=anchor href=#%e9%80%9a%e7%94%a8%e7%9a%84%e5%87%bd%e6%95%b0%e5%bc%8f%e6%8e%a5%e5%8f%a3>#</a></h3><table><thead><tr><th>接口</th><th>参数</th><th>返回值</th><th>方法名</th><th>其他方法</th></tr></thead><tbody><tr><td><code>Runnable</code></td><td>none</td><td><code>void</code></td><td><code>run</code></td><td></td></tr><tr><td><code>Supplier&lt;T></code></td><td>none</td><td><code>T</code></td><td><code>get</code></td><td></td></tr><tr><td><code>Consumer&lt;T></code></td><td><code>T</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>andThen</code></td></tr><tr><td><code>BiConsumer&lt;T, U></code></td><td><code>T, U</code></td><td><code>void</code></td><td><code>accept</code></td><td><code>andThen</code></td></tr><tr><td><code>Function&lt;T, R></code></td><td><code>T</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>compose</code> <code>andThen</code> <code>identity</code></td></tr><tr><td><code>BiFunction&lt;T, U, R></code></td><td><code>T, U</code></td><td><code>R</code></td><td><code>apply</code></td><td><code>andThen</code></td></tr><tr><td><code>UnaryOperator&lt;T></code></td><td><code>T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>compose</code> <code>andThen</code> <code>identity</code></td></tr><tr><td><code>BinaryOperator&lt;T></code></td><td><code>T, T</code></td><td><code>T</code></td><td><code>apply</code></td><td><code>andThen</code> <code>maxBy</code> <code>minBy</code></td></tr><tr><td><code>Predicate&lt;T></code></td><td><code>T</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>and</code> <code>or</code> <code>negate</code> <code>isEqual</code></td></tr><tr><td><code>BiPredicate&lt;T></code></td><td><code>T, U</code></td><td><code>boolean</code></td><td><code>test</code></td><td><code>and</code> <code>or</code> <code>negate</code></td></tr></tbody></table><p>这里的"其他方法"，是一类用来组装函数的非抽象方法。形如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>interface</span> <span style=color:#00f;font-weight:700>Predicate</span><span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#b00040>boolean</span> <span style=color:#00f>test</span><span style=color:#666>(</span>T t<span style=color:#666>);</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// 这个方法接收两个Predicate类型，返回一个新的，其效果相当于二者取布尔和。
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:green;font-weight:700>default</span> Predicate<span style=color:#666>&lt;</span>T<span style=color:#666>&gt;</span> <span style=color:#00f>and</span><span style=color:#666>(</span>
</span></span><span style=display:flex><span>        Predicate<span style=color:#666>&lt;?</span> <span style=color:green;font-weight:700>super</span> T<span style=color:#666>&gt;</span> another<span style=color:#666>)</span> <span style=color:#666>{</span> <span style=color:#666>...</span> <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>在这里，<code>compose()</code> 和 <code>andThen()</code> 都接收另一个参数为 <code>? super T</code> 的函数，将二者以不同的顺序组合起来。<code>and</code> <code>or</code> <code>negate</code> 的形式与之类似。</p><p>还有些方法是静态的。<code>identity</code> 返回一个函数，这个函数将其输入原封不动地返回出去。因此其返回值为 <code>Function&lt;T, T></code> 类型。<code>maxBy</code> <code>minBy</code> 接受一个 <code>Comparator&lt;? super T></code> 参数，返回一个用于比较的函数。<code>isEqual</code> 返回一个 null 安全的判断相等的函数。</p><p>此外，还有一些用于未包装类型的接口，如 <code>IntPredicate</code> <code>DoubleConsumer</code> <code>ToIntFunction&lt;T></code> 等。</p><h3 id=lambda-表达式和变量作用域>lambda 表达式和变量作用域
<a class=anchor href=#lambda-%e8%a1%a8%e8%be%be%e5%bc%8f%e5%92%8c%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f>#</a></h3><p>lambda 表达式和嵌套代码块有着相同的作用域。因此，这样的代码是不合法的：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span> first <span style=color:#666>=</span> 0<span style=color:#666>;</span>
</span></span><span style=display:flex><span>Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> comp <span style=color:#666>=</span> <span style=color:#666>(</span>first<span style=color:#666>,</span> second<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> <span style=color:#666>...;</span>  <span style=color:#408080;font-style:italic>// DO NOT compile
</span></span></span></code></pre></div><p>由于作用域的共享，在 lambda 表达式中调用 <code>this</code> 得到的结果将和直接在方法中调用一样。</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Application</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#b00040>void</span> <span style=color:#00f>doSth</span><span style=color:#666>()</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:#408080;font-style:italic>// Calls Application.this.toString(), NOT!! runner.toString()
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>        Runnable runner <span style=color:#666>=</span> <span style=color:#666>()</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span><span style=color:green;font-weight:700>this</span><span style=color:#666>.</span><span style=color:#7d9029>toString</span><span style=color:#666>()}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h3 id=闭包>闭包
<a class=anchor href=#%e9%97%ad%e5%8c%85>#</a></h3><p>考虑一个 lambda 表达式：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> <span style=color:#b00040>void</span> <span style=color:#00f>repeatMessage</span><span style=color:#666>(</span>String text<span style=color:#666>,</span> <span style=color:#b00040>int</span> count<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>new</span> Thread<span style=color:#666>(()</span> <span style=color:#666>-&gt;</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>        <span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span><span style=color:#b00040>int</span> i <span style=color:#666>=</span> 0<span style=color:#666>;</span> i <span style=color:#666>&lt;</span> 1000<span style=color:#666>;</span> i<span style=color:#666>++)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>            System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>text<span style=color:#666>);</span>
</span></span><span style=display:flex><span>        <span style=color:#666>}</span>
</span></span><span style=display:flex><span>    <span style=color:#666>}).</span><span style=color:#7d9029>start</span><span style=color:#666>()</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>在这里，lambda 表达式除了参数和本身的代码块之外，还使用了外部的其他变量，即这里的 <code>text</code>。这种变量叫做<strong>自由变量</strong>，这个 lambda 表达式是一个<strong>闭包</strong>。</p><p>由于 lambda 表达式是延迟执行的。例如，这里的 <code>println</code> 操作在另一个线程里结束之前，这个方法所在的对象很可能已经不被引用而 GC 掉了。所以，lambda 表达式需要在运行之前<strong>捕获</strong>这些变量，保存在这个实现接口（在这里是 <code>Runnable</code>）的匿名类对象里。如果这些变量是可变的，就无法进行正确的捕获。例如：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span><span style=color:#b00040>int</span> i <span style=color:#666>=</span> 0<span style=color:#666>;</span> i <span style=color:#666>&lt;</span> 1000<span style=color:#666>;</span> i<span style=color:#666>++)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>// Error, DO NOT compile
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:green;font-weight:700>new</span> Thread<span style=color:#666>(()</span> <span style=color:#666>-&gt;</span> System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>i<span style=color:#666>)).</span><span style=color:#7d9029>start</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><p>同样的规则也适用于局部内部类。总之，被引用的自由变量必须<strong>可以</strong>被声明为 <code>final</code>，或者叫做<strong>有效 final（effectively final）</strong>。</p><p>不过，在增强的 <code>for</code> 循环中，变量可以在 lambda 表达式中使用。在传统的 <code>for</code> 循环中，变量 <code>i</code> 的作用域是整个 <code>for</code> 循环。而在以下的代码中，变量 <code>s</code> 的作用域只有其所在的唯一一次迭代：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>//start Variable Scope of variable &#34;i&#34;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>for</span> <span style=color:#666>(</span>String s <span style=color:#666>:</span> args<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>//start variable scope of variable &#34;s&#34;
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>    <span style=color:green;font-weight:700>new</span> Thread<span style=color:#666>(()</span> <span style=color:#666>-&gt;</span>  System<span style=color:#666>.</span><span style=color:#7d9029>out</span><span style=color:#666>.</span><span style=color:#7d9029>println</span><span style=color:#666>(</span>s<span style=color:#666>));</span>
</span></span><span style=display:flex><span>    <span style=color:#408080;font-style:italic>//end &#34;s&#34; scope
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>//end &#34;i&#34; scope
</span></span></span></code></pre></div><p>正由于捕获的过程，lambda 表达式不能改变被捕获的自由变量。当然，这样也可以避免一些多线程冲突的问题。</p><p>如果真的需要使用可变的对象，可以通过数组来规避：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#b00040>int</span><span style=color:#666>[]</span> counter <span style=color:#666>=</span> <span style=color:green;font-weight:700>new</span> <span style=color:#b00040>int</span><span style=color:#666>[];</span>
</span></span><span style=display:flex><span>bunnton<span style=color:#666>.</span><span style=color:#7d9029>setOnAction</span><span style=color:#666>(</span>event <span style=color:#666>-&gt;</span> counter<span style=color:#666>[</span>0<span style=color:#666>]++);</span>
</span></span></code></pre></div><p>这样，<code>counter</code> 指向的数组没有变，而其中存储的数据变化了。当然，这样的代码不是线程安全的。</p><h2 id=方法引用>方法引用
<a class=anchor href=#%e6%96%b9%e6%b3%95%e5%bc%95%e7%94%a8>#</a></h2><p>当 lambda 表达式的内容已经在其他方法中被实现，就可以使用方法引用来代替。</p><h3 id=形式>形式
<a class=anchor href=#%e5%bd%a2%e5%bc%8f>#</a></h3><p>方法引用有三种形式：</p><ul><li><p><code>Class::instanceMethod</code></p><p>如，<code>String::compareTo</code> = <code>(x, y) -> x.compareTo(y)</code>，是在对象 <code>x</code> 上调用，并将其他参数，在这里是 <code>y</code>，作为方法的参数。</p></li><li><p><code>Class::staticMethod</code></p><p>如，<code>Object::isNull</code> = <code>x -> Objects.isNull(x)</code>，是在类 <code>Objects</code> 上调用，将表达式的所有参数作为方法的参数。</p></li><li><p><code>Instance::instanceMethod</code></p><p>如，<code>System.out::print</code> = <code>x -> System.out.println(x)</code>，是在给出的对象 <code>out</code> 上调用方法，并把参数传入。</p></li></ul><h3 id=构造函数的引用>构造函数的引用
<a class=anchor href=#%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e7%9a%84%e5%bc%95%e7%94%a8>#</a></h3><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:green;font-weight:700>class</span> <span style=color:#00f;font-weight:700>Employee</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>public</span> <span style=color:#00f>Employee</span><span style=color:#666>(</span>String name<span style=color:#666>)</span> <span style=color:#666>{}</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span>Stream<span style=color:#666>&lt;</span>Employee<span style=color:#666>&gt;</span> stream <span style=color:#666>=</span> names<span style=color:#666>.</span><span style=color:#7d9029>map</span><span style=color:#666>(</span>Employee<span style=color:#666>::</span><span style=color:green;font-weight:700>new</span><span style=color:#666>);</span>
</span></span></code></pre></div><p>使用数组类型的构造函数引用，可以避免对数组类型的 cast（由于 Java 中没有泛型数组）：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span>Object<span style=color:#666>[]</span> employees <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>toArray</span><span style=color:#666>();</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Use constructor reference instead:
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Employee<span style=color:#666>[]</span> buttons <span style=color:#666>=</span> stream<span style=color:#666>.</span><span style=color:#7d9029>toArray</span><span style=color:#666>(</span>Employee<span style=color:#666>::</span><span style=color:green;font-weight:700>new</span><span style=color:#666>);</span>
</span></span></code></pre></div><h1 id=高阶函数>高阶函数
<a class=anchor href=#%e9%ab%98%e9%98%b6%e5%87%bd%e6%95%b0>#</a></h1><p>此前我们已经见过高阶函数，即通用函数式接口里的那些 <code>default</code> 方法。高阶函数可以用来产生新的函数或修改一个函数：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// Return a function
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> <span style=color:#00f>compareInDirection</span><span style=color:#666>(</span><span style=color:#b00040>int</span> direction<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:#666>(</span>x<span style=color:#666>,</span> y<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> direction <span style=color:#666>*</span> x<span style=color:#666>.</span><span style=color:#7d9029>compareTo</span><span style=color:#666>(</span>y<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Modify a function
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>public</span> <span style=color:green;font-weight:700>static</span> Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> <span style=color:#00f>reverse</span><span style=color:#666>(</span>Comparator<span style=color:#666>&lt;</span>String<span style=color:#666>&gt;</span> comp<span style=color:#666>)</span> <span style=color:#666>{</span>
</span></span><span style=display:flex><span>    <span style=color:green;font-weight:700>return</span> <span style=color:#666>(</span>x<span style=color:#666>,</span> y<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> comp<span style=color:#666>.</span><span style=color:#7d9029>compare</span><span style=color:#666>(</span>x<span style=color:#666>,</span> y<span style=color:#666>);</span>
</span></span><span style=display:flex><span><span style=color:#666>}</span>
</span></span></code></pre></div><h2 id=comparator-方法>Comparator 方法
<a class=anchor href=#comparator-%e6%96%b9%e6%b3%95>#</a></h2><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// Sort by name
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>people<span style=color:#666>,</span> Comaprator<span style=color:#666>.</span><span style=color:#7d9029>comparing</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getName<span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Sort by name, with specified comparator
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>people<span style=color:#666>,</span> Comparator<span style=color:#666>.</span><span style=color:#7d9029>comparing</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getName<span style=color:#666>,</span>
</span></span><span style=display:flex><span>           <span style=color:#666>(</span>s<span style=color:#666>,</span> t<span style=color:#666>)</span> <span style=color:#666>-&gt;</span> s<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>()</span> <span style=color:#666>-</span> t<span style=color:#666>.</span><span style=color:#7d9029>length</span><span style=color:#666>());</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// Sort by last name, then first name
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>people<span style=color:#666>,</span> Comparator
</span></span><span style=display:flex><span>    <span style=color:#666>.</span><span style=color:#7d9029>comparing</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getLastName<span style=color:#666>)</span>
</span></span><span style=display:flex><span>    <span style=color:#666>.</span><span style=color:#7d9029>thenComparing</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getFirstName<span style=color:#666>));</span>
</span></span><span style=display:flex><span><span style=color:#408080;font-style:italic>// For basic types:
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>people<span style=color:#666>,</span> Comparator<span style=color:#666>.</span><span style=color:#7d9029>comparingInt</span><span style=color:#666>(</span>Person<span style=color:#666>::</span>getId<span style=color:#666>))</span>
</span></span></code></pre></div><p>在这里被传入的方法引用可以称为 <strong>key 提取器</strong>，这意味着这个方法把对象中的 key 提取出来以供比较。如果 key 提取器可能返回 null，则可以使用两个装饰器方法 <code>nullFirst</code> <code>nullLast</code>：</p><div class=highlight><pre tabindex=0 style=-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#408080;font-style:italic>// 将comparing方法静态导入进来
</span></span></span><span style=display:flex><span><span style=color:#408080;font-style:italic></span><span style=color:green;font-weight:700>import</span> <span style=color:#00f;font-weight:700>java.util.Comparator.*</span>
</span></span><span style=display:flex><span>Arrays<span style=color:#666>.</span><span style=color:#7d9029>sort</span><span style=color:#666>(</span>people<span style=color:#666>,</span> comparing<span style=color:#666>(</span>
</span></span><span style=display:flex><span>    Person<span style=color:#666>::</span>getMiddleName<span style=color:#666>,</span> nullsFirst<span style=color:#666>(</span>natualOrder<span style=color:#666>())))</span>  <span style=color:#408080;font-style:italic>// or reverseOrder()
</span></span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(n){const e=window.getSelection(),t=document.createRange();t.selectNodeContents(n),e.removeAllRanges(),e.addRange(t)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#接口>接口</a><ul><li><a href=#继承接口>继承接口</a></li><li><a href=#静态方法和默认方法>静态方法和默认方法</a></li></ul></li><li><a href=#常用的接口>常用的接口</a><ul><li><a href=#comparable>Comparable</a></li><li><a href=#comparator>Comparator</a></li><li><a href=#runnable>Runnable</a></li></ul></li><li><a href=#lambda-表达式和方法引用>lambda 表达式和方法引用</a><ul><li><a href=#lambda-表达式>lambda 表达式</a><ul><li><a href=#通用的函数式接口>通用的函数式接口</a></li><li><a href=#lambda-表达式和变量作用域>lambda 表达式和变量作用域</a></li><li><a href=#闭包>闭包</a></li></ul></li><li><a href=#方法引用>方法引用</a><ul><li><a href=#形式>形式</a></li><li><a href=#构造函数的引用>构造函数的引用</a></li></ul></li></ul></li><li><a href=#高阶函数>高阶函数</a><ul><li><a href=#comparator-方法>Comparator 方法</a></li></ul></li></ul></nav></div></aside></main></body></html>